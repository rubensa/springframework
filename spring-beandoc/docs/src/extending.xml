<?xml version="1.0" encoding="UTF-8"?>
<chapter id="extending">
  <title>Extending BeanDoc</title>

  <sect1>
    <title>Implementable interfaces</title>

    <para>Generally it should be possible to get BeanDoc to do whatever you
    need by implementing either
    <literal>org.springframework.beandoc.output.Decorator</literal> or
    <literal>org.springframework.beandoc.output.Transformer</literal> or
    possibly both. Built in implemenations of these two interfaces do most of
    the work of generating documentation from the input files. The rest is
    handled by the <literal>ContextProcessor</literal>
    implementation(s).</para>

    <para>This chapter will explore by way of a simple example the steps
    involved in adding the required files to produce additional output from
    that already produced by the tool. If you're genuinely of need of this
    stuff, the <ulink
    url="http://springframework.sourceforge.net/beandoc/api/">API
    documentation</ulink> is going to be your most important resource.</para>

    <para>Our trivial example will create a <literal>Transformer</literal>
    that produces a CSV file (Comma Separated Values) which could be loaded
    into a spreadsheet or otherwise parsed by text handling tools. All of the
    information that we might need in such a file is probably already
    available in standard DOM trees after decoration by the
    <literal>DefaultContextProcessor</literal>, so in a slightly contrived
    manner we'll assume that we also need a sequential ID for each bean in
    order to make it necessary to also implement a custom
    <literal>Decorator</literal>. In fact this could be done with an XSL
    <literal>Transformer</literal> implementation, but I'm not going to use
    XSL for our <literal>Transformer</literal> example.</para>

    <para><literal>Decorator</literal>s and <literal>Transformer</literal>s
    use JDOM API's for XML processing.</para>
  </sect1>

  <sect1>
    <title id="extending-decorators">Writing Decorators</title>

    <para>A Decorator has the ability to markup or decorate the XML elements
    in the DOM tree after the ContextProcessor has created the in-memory
    representation and performed some remedial decoration of its own.
    Decoration is incremental and decorators should be careful not to
    overwrite each other's attributes or element values. To ensure this is the
    case in our example, we'll use an attribute prefix of "beandocCSV" for all
    our attribute names.</para>

    <note>
      <para>It's worth ALWAYS specifying attribute names that start with
      "beandoc" as some of the standard transformations ignore such attributes
      when actually documenting the context.</para>
    </note>

    <para>Let's start by extending the included SimpleDecorator class from the
    BeanDoc source. This class implements the required
    <literal>decorate()</literal> method for us and delegates to a
    <literal>decorateElement()</literal> method which gives us access to every
    individual element in each context file in turn.</para>

    <programlisting>public class CsvDecorator extends SimpleDecorator {

    private static final String ATTRIBUTE_PREFIX = "beandocCSV";

    public static final String ATTRIBUTE_COUNTER = ATTRIBUTE_PREFIX + "Count";

    private int count = 0;

    /**
     * @see org.springframework.beandoc.output.SimpleDecorator#decorateElement
     */
    protected void decorateElement(Element element) {
        // we're only interested in bean elements..
        if ("bean".equals(element.getName()))
            element.setAttribute(ATTRIBUTE_COUNTER, String.valueOf(++count));            
    }
}</programlisting>

    <para>That's it. There's nothing else for our <literal>Decorator</literal>
    implementation to do - we've added a sequential id to each bean in the
    context. All the other information we need for our transformation to the
    CSV file is already available.</para>

    <para>One more caveat when writing <literal>Decorator</literal>s: you can
    add attributes and change the value of <literal>Element</literal>s in the
    context, but any attempt to ADD new <literal>Element</literal>s will
    result in a runtime exception.</para>
  </sect1>

  <sect1>
    <title>Writing Transformers</title>

    <para>Our transformation could use XSLT to generate the CSV but here we'll
    do it on the cheap and just use a FileWriter to output our document.
    Satisfying the <literal>Transformer</literal> interface involves
    implementing a single method - <literal>transform(Document[],
    File)</literal>. Here's our CSV transformer;</para>

    <programlisting>public class CsvTransformer implements Transformer {

    /**
     * create a new CSV file for each context file
     */
    public void transform(Document[] contextDocuments, File outputDir) {
        for (int i = 0; i &lt; contextDocuments.length; i++) {
            Document doc = contextDocuments[i];
            File outputFile = new File(
                outputDir, doc.getRootElement().getAttributeValue("beandocFileName") + ".csv"
            );
            
            try {
                FileWriter out = new FileWriter(outputFile);
                String csvLine = "";
                
                List beans = doc.getRootElement().getChildren("bean");
                for (Iterator iter = beans.iterator(); iter.hasNext();) {
                    Element bean = (Element) iter.next();
                    csvLine = 
                        bean.getAttributeValue(CsvDecorator.ATTRIBUTE_COUNTER) + "," +
                        bean.getAttributeValue("id") + "," + 
                        bean.getAttributeValue("class") + "\n";

                    out.write(csvLine);
                }
                out.flush();
                out.close();
                
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</programlisting>
  </sect1>

  <sect1>
    <title>Supplying a new context definition file</title>

    <para>[todo]</para>
  </sect1>
</chapter>