<?xml version="1.0" encoding="UTF-8"?>
<chapter id="extending">
  <title>Extending BeanDoc</title>

  <sect1>
    <title>Before extending</title>

    <para>In the first instance, make sure that extending the tool is really
    what you need to do. The standard setup is very flexible and you can
    change the look and feel of the HTML, generate a completely different
    output language and manipulate graphs to a high degree without writing
    code to extend BeanDoc. Check the previous chapters if this sounds more
    like what you want to do.</para>
  </sect1>

  <sect1>
    <title>Implementable interfaces</title>

    <para>Generally it should be possible to get BeanDoc to do whatever you
    need by implementing either
    <literal>org.springframework.beandoc.output.Decorator</literal> or
    <literal>org.springframework.beandoc.output.Transformer</literal> or
    possibly both. Built in implemenations of these two interfaces do most of
    the work of generating documentation from the input files. The rest is
    handled by the <literal>ContextProcessor</literal>
    implementation(s).</para>

    <para>This chapter will explore by way of a simple example the steps
    involved in adding the required files to produce additional output from
    that already produced by the tool. If you're genuinely of need of this
    stuff, the <ulink
    url="http://springframework.sourceforge.net/beandoc/apidoc/">API
    documentation</ulink> is going to be your most important resource.</para>

    <para>Our trivial example will create a <literal>Transformer</literal>
    that produces a CSV file (Comma Separated Values) which could be loaded
    into a spreadsheet or otherwise parsed by text handling tools. All of the
    information that we might need in such a file is probably already
    available in standard DOM trees after decoration by the
    <literal>DefaultContextProcessor</literal>, so in a slightly contrived
    manner we'll assume that we also need a sequential ID for each bean in
    order to make it necessary to implement a custom
    <literal>Decorator</literal>. In fact this could be done with an XSL
    <literal>Transformer</literal> implementation, but I'm not going to use
    XSL for our <literal>Transformer</literal> example.</para>

    <para><literal>Decorator</literal>s, <literal>Transformer</literal>s and
    <literal>DocumentCompiler</literal>s use <ulink
    url="http://www.jdom.org">JDOM</ulink> API's for XML processing.</para>
  </sect1>

  <sect1>
    <title id="extending-decorators">Writing Decorators</title>

    <para>A Decorator has the ability to markup or decorate the XML elements
    in the DOM tree after the ContextProcessor has created the in-memory
    representation and performed some remedial decoration of its own.
    Decoration is incremental and decorators should be careful not to
    overwrite each other's attributes or element values. To ensure this is the
    case in our example, we'll use an attribute prefix of "beandocCSV" for all
    our attribute names.</para>

    <note>
      <para>It's worth ALWAYS specifying attribute names that start with
      "beandoc" as some of the standard transformations ignore such attributes
      when actually documenting the context.</para>
    </note>

    <para>Let's start by extending the included SimpleDecorator class from the
    BeanDoc source. This class implements the required
    <literal>decorate()</literal> method for us and delegates to a
    <literal>decorateElement()</literal> method which gives us access to every
    individual element in each context file in turn.</para>

    <para>The <literal>Decorator</literal> interface is simple with a single
    method to implement;</para>

    <programlisting>public interface Decorator {

    public void decorate(Document[] contextDocuments);
    
}</programlisting>

    <para>The default context processor implementation in BeanDoc will pass in
    the array of JDOM <literal><ulink
    url="http://www.jdom.org/docs/apidocs/org/jdom/Document.html">Document</ulink></literal>s
    that it has built in order that the implementation might amend values or
    add attributes. A convenience implementation of this interface called
    <literal>SimpleDecorator</literal> subsequently iterates each
    <literal>Element</literal> of each <literal>Document</literal> and calls a
    protected <literal>decorateElement()</literal> method for subclasses to
    fill out. A subclass can specify a <literal>Filter</literal> to restrict
    the <literal>Element</literal> types it is presented with for decoration
    This is the pattern we'll follow here;</para>

    <programlisting>public class CsvDecorator extends SimpleDecorator {

    private static final String ATTRIBUTE_PREFIX = "beandocCSV";

    static final String ATTRIBUTE_COUNTER = ATTRIBUTE_PREFIX + "Count";

    private int count = 0;

    /**
     * specify only 'bean' elements as a Filter - we're not interested in
     * decorating anything else
     */
    public CsvDecorator() {
        setFilter(new ElementFilter("bean"));
    }
    
    /**
     * @see org.springframework.beandoc.output.SimpleDecorator#decorateElement(org.jdom.Element)
     */
    protected void decorateElement(Element element) {
        element.setAttribute(ATTRIBUTE_COUNTER, String.valueOf(++count));      
    }
}</programlisting>

    <para>That's it. There's nothing else for our <literal>Decorator</literal>
    implementation to do - we've added a sequential id to each bean in the
    context. All the other information we need for our transformation to the
    CSV file is already available.</para>

    <remark>One more important point to note when writing
    <literal>Decorator</literal>s: you can add or change attributes and change
    the value of <literal>Element</literal>s, but any attempt to change the
    structure of the DOM by adding, removing or moving
    <literal>Element</literal>s will result in a runtime exception.</remark>
  </sect1>

  <sect1>
    <title>Writing Transformers</title>

    <para>Our transformation could use XSLT to generate the CSV but here we'll
    do it on the cheap and just use a FileWriter to output our document.
    Satisfying the <literal>Transformer</literal> interface involves
    implementing a single method as shown;</para>

    <programlisting>public interface Transformer {

    public void transform(Document[] contextDocuments, File outputDir);
    
}</programlisting>

    <para>Here's our CSV implementation;</para>

    <programlisting>public class CsvTransformer implements Transformer {

    /**
     * create a new CSV file for each context file
     */
    public void transform(Document[] contextDocuments, File outputDir) {
        for (int i = 0; i &lt; contextDocuments.length; i++) {
            Document doc = contextDocuments[i];
            File outputFile = new File(
                outputDir, doc.getRootElement().getAttributeValue("beandocFileName") + ".csv"
            );
            
            try {
                FileWriter out = new FileWriter(outputFile);
                String csvLine = "";
                
                List beans = doc.getRootElement().getChildren("bean");
                for (Iterator iter = beans.iterator(); iter.hasNext();) {
                    Element bean = (Element) iter.next();
                    csvLine = 
                        bean.getAttributeValue(CsvDecorator.ATTRIBUTE_COUNTER) + "," +
                        bean.getAttributeValue("id") + "," + 
                        bean.getAttributeValue("class") + "\n";

                    out.write(csvLine);
                }
                out.flush();
                out.close();
                
            } catch (IOException e) {
                // should be handled properly!
                e.printStackTrace();
            }
        }
    }
}</programlisting>

    <note>
      <para>The class is instructive only, it clearly doesn't attempt to
      handle exceptions correctly or ensure that resources are flushed or
      closed under such cases.</para>
    </note>

    <para>The two classes detailed above are included in the main source tree
    of BeanDoc and compiled into spring-beandoc.jar. If you do want to try
    them out, you only need folllow the instructions in the next
    section.</para>
  </sect1>

  <sect1>
    <title>Writing DocumentCompilers</title>

    <para>After decoration and transformation of DOM trees, the default
    context processor will then offer any configured
    <literal>DocumentCompiler</literal>s the chance to pull the output
    resources together. In many cases this won't be necessary as
    transformation will produce documents in the required format. In the case
    of our simple example, we don't need to implement a new
    <literal>DocumentCompiler</literal>.</para>

    <para>Should you need to do so, the operation is trivial involving writing
    a class to implement the single interface method in similar fashion to
    <literal>Decorator</literal>s and <literal>Transformer</literal>s.</para>

    <programlisting>public interface DocumentCompiler {    

    public void compile(Document[] contextDocuments, File outputDir);

}</programlisting>
  </sect1>

  <sect1>
    <title>Supplying a new context definition file</title>

    <para>If you are extending BeanDoc with your own classes such as those
    outlined in this chapter, you will need to instruct the ContextProcessor
    implementation to use them. BeanDoc uses a Spring bean factory to
    configure itself and the Ant task has an attribute that permits you to
    specify a context definition file to override the internal one. This is
    what you must do in order to make use of your new
    <literal>Decorator</literal> or <literal>Transformer</literal>
    implementations.</para>

    <para>The samples directory contains a context file that includes the CSV
    output classes as part of the <literal>List</literal> of
    <literal>Decorator</literal> and <literal>Transformer</literal>
    implementations supplied to the processor;</para>

    <programlisting>&lt;bean id="processor" class="org.springframework.beandoc.DefaultContextProcessor"&gt;
    &lt;description&gt;
        main processor for generating output
    &lt;/description&gt;
    &lt;constructor-arg index="0"&gt;&lt;value&gt;${input.files}&lt;/value&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg index="1"&gt;&lt;value&gt;${output.dir}&lt;/value&gt;&lt;/constructor-arg&gt;
    &lt;property name="decorators"&gt;
        &lt;list&gt;
            &lt;ref local="javadoc"/&gt;
            &lt;ref local="html"/&gt; 
            &lt;ref local="graphs"/&gt;
            <emphasis role="bold">&lt;ref local="csvDecorator"/&gt;</emphasis> 
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="transformers"&gt;
        &lt;list&gt;
            &lt;ref local="htmlIndexTransformer"/&gt;
            &lt;ref local="htmlNavigationTransformer"/&gt;
            &lt;ref local="htmlMainTransformer"/&gt; 
            &lt;ref local="htmlDetailTransformer"/&gt;    
            &lt;ref local="graphVizTransformer"/&gt;   
            <emphasis role="bold">&lt;ref local="csvTransformer"/&gt;</emphasis>
        &lt;/list&gt;
    &lt;/property&gt;   

    ...
  
&lt;/bean&gt;

<emphasis role="bold">&lt;bean id="csvDecorator" class="org.springframework.beandoc.output.CsvDecorator"/&gt;               
    
&lt;bean id="csvTransformer" class="org.springframework.beandoc.output.CsvTransformer"/&gt;</emphasis>

...</programlisting>

    <para><note>
        <para>It may appear more natural to nest the "csv" beans as anonymous
        inner beans instead of supplying <literal>&lt;ref&gt;</literal> tags
        for them in the <literal>&lt;list&gt;</literal>s. Remember though that
        unless they are top level beans with a referenceable id, you will be
        unable to post-process them by setting properties in
        <literal>beandoc.properties</literal>.</para>
      </note>Your <literal>&lt;beandoc/&gt;</literal> task in Ant's buildfile
    will need to be told where your alternative context definition file is,
    for example;</para>

    <programlisting>&lt;beandoc 
    inputFiles="${basedir}/petclinic/*.xml" 
    outputDir="/some/other/outputdir/html/"
    beandocContext="${basedir}/alternative-beandoc.xml"
/&gt;</programlisting>

    <para>See <xref linkend="running-ant" /> for information on running
    BeanDoc from an Ant script.</para>
  </sect1>
</chapter>