<?xml version="1.0" encoding="UTF-8"?>
<chapter id="flow-definition">
	<title>Flow definition</title>
	<sect1 id="flow-intro">
		<title>Introduction</title>
		<para>
			Spring Web Flow allows developers to build reusable, self-contained controller modules
			called flows.  A flow is a blueprint for a user conversation (or dialog)
			that drives the execution of application code to complete a business goal.
		</para>
		<para>
			Flows are defined declaratively using a rich domain-specific language (DSL) 
			tailored to the problem domain of page flow.  Currently, Java-based and XML-based
			forms of this language are provided.
		</para>
		<para>
			This chapter documents Spring Web Flow's core flow definition language.  You'll
			learn the core domain constructs of the system and how those constructs are
			representable in an externalized XML form.
		</para>
    </sect1>
    <sect1 id="flow">
    	<title>Flow</title>
    	<para>
    		A flow is defined by a single instance of <literal>org.springframework.webflow.Flow</literal>.
    		This is the central domain artifact representing the definition of a conversation.
		</para>
		<para>
    		A flow consists of a set of one or more states, where each state defines a step in
    		the flow that, when entered, executes a behavior.  What behavior is executed is 
    		a function of the state's type and configuration.  The outcome of a state's
    		execution, called an event, is used by the flow to drive a state transition.
    	</para>
    	<para>
		Exactly one of a flow's states is the <literal>startState</literal> 
		that defines the starting point of the flow. Optionally, a flow can have one or more end states
		defining the ending points of the flow.
    	</para>
    	<para>
    		The properties of a <literal>org.springframework.webflow.Flow</literal> are summarized 
    		below:
    	</para>
        <table frame="all">
            <title>Flow properties</title>
            <tgroup cols="4">
                <colspec colname="c1" colwidth="2*" />
                <colspec colname="c2" colwidth="4*" />
                <colspec colname="c2" colwidth="2*" />
                <colspec colname="c2" colwidth="2*" />
                <thead>
                    <row>
                        <entry>Property name</entry>
                        <entry>Description</entry>
                        <entry>Cardinality</entry>
                        <entry>Default value</entry>
                    </row>
               </thead>
               <tbody>
                   <row>
                       <entry>id</entry>
                       <entry>The identifier of the flow, typically unique to all other flows of the application.</entry>
				       <entry>
				           <emphasis>1</emphasis>
				       </entry>
                   </row>         
                   <row>
                       <entry>properties</entry>
                       <entry>Additional custom properties about the flow.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>None</entry>
                   </row>
                   <row>
                       <entry>states</entry>
                       <entry>The steps of the flow.</entry>
				       <entry>
				           <emphasis>1..*</emphasis>
				       </entry>
                   </row>
                   <row>
                       <entry>startState</entry>
                       <entry>The starting point of the flow.</entry>
				       <entry>
				           <emphasis>1</emphasis>
				       </entry>
                   </row>
                   <row>
                       <entry>startActions</entry>
                       <entry>The list of actions to execute each time an execution of the flow is started.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
                   <row>
                       <entry>globalTransitions</entry>
                       <entry>The set of transitions shared by all states of this flow.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
                   <row>
                       <entry>endActions</entry>
                       <entry>The list of actions to execute each time an execution of the flow ends.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
                   <row>
                       <entry>exceptionHandlers</entry>
                       <entry>An ordered set of handlers to be applied when an exception is thrown within a state of the flow.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
                   <row>
                       <entry>inlineFlows</entry>
                       <entry>A set of inner flows that will be called as subflows; these flows are locally scoped to the outer flow.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
               </tbody>
          </tgroup>
        </table>
        <para>
            Below is a high level example of how these Flow properties can be configured in XML form
            or directly in Java code.
        </para>
        <sect2 id="flow-xml">
        	<title>XML-based flow template</title>
       	    <programlisting>
    &lt;flow start-state="startingPoint"&gt;
        &lt;property .../&gt;
        
        &lt;start-actions&gt;
            ...
        &lt;/start-actions&gt;
        
        &lt;-- your state definitions go here --&gt;

        &lt;global-transitions&gt;
            ...
        &lt;/global-transitions&gt;
        
        &lt;end-actions&gt;
            ...
        &lt;/end-actions&gt;

        &lt;exception-handler .../&gt;

        &lt;inline-flow&gt;
            ...
        &lt;/inline-flow&gt;
    &lt;/flow&gt;
         	</programlisting>
        </sect2>
        <sect2 id="flow-java">
           <title>Java flow API example</title>
           <programlisting>
    Flow flow = new Flow("id");
    flow.setProperty(..., ...);
    flow.addState(...);
    flow.setStartState("startingPoint");
    flow.addStartAction(...);
    flow.addGlobalTransition(...);
    flow.addEndAction(...);
    flow.addExceptionHandler(...);
    flow.addInlineFlow(...);
          </programlisting>
        </sect2>
    </sect1>
    <sect1 id="state">
    	<title>State</title>
    	<para>
    	    A state defines the behavior for a step of a flow.
    	    The base class for all Flow state types is <literal>org.springframework.webflow.State</literal>.
    	    This abstract class defines common properties applicable to all state types, which include:
    	</para>
    	<table>
            <title>State properties</title>
            <tgroup cols="4">
                <colspec colname="c1" colwidth="2*" />
                <colspec colname="c2" colwidth="4*" />
                <colspec colname="c2" colwidth="2*" />
                <colspec colname="c2" colwidth="2*" />
                <thead>
                    <row>
                        <entry>Property name</entry>
                        <entry>Description</entry>
                        <entry>Cardinality</entry>
                        <entry>Default value</entry>
                    </row>
               </thead>
               <tbody>
                   <row>
                       <entry>id</entry>
                       <entry>The id of the state, unique to its containing Flow.</entry>
				       <entry>
				           <emphasis>1</emphasis>
				       </entry>
                   </row>
                   <row>
                       <entry>flow</entry>
                       <entry>The owning Flow.</entry>
				       <entry>
				           <emphasis>1</emphasis>
				       </entry>
                   </row>
                   <row>
                       <entry>properties</entry>
                       <entry>Additional custom properties about the state.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>None</entry>
                   </row>
                   <row>
                       <entry>entryActions</entry>
                       <entry>The list of actions to execute each time the state is entered.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
                   <row>
                       <entry>exceptionHandlers</entry>
                       <entry>An ordered set of handlers to be applied when an exception is thrown within the state.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
               </tbody>
          </tgroup>
        </table>
    </sect1>
    <sect1 id="transitionable-state">
    	<title>Transitionable State</title>
    	<para>
    	    A central subclass of State is <literal>org.springframework.webflow.TransitionableState</literal>.
    	    This abstract class defines common properties applicable to all state types that execute
    	    transitions to other states in response to events.  These properties include:
    	</para>
    	<table>
            <title>TransitionableState properties</title>
            <tgroup cols="4">
                <colspec colname="c1" colwidth="2*" />
                <colspec colname="c2" colwidth="4*" />
                <colspec colname="c2" colwidth="2*" />
                <colspec colname="c2" colwidth="2*" />
                <thead>
                    <row>
                        <entry>Property name</entry>
                        <entry>Description</entry>
                        <entry>Cardinality</entry>
                        <entry>Default value</entry>
                    </row>
               </thead>
               <tbody>
                   <row>
                       <entry>transitions</entry>
                       <entry>The eligible paths out of this state.</entry>
				       <entry>
				           <emphasis>1..*</emphasis>
				       </entry>
                   </row>
                   <row>
                       <entry>exitActions</entry>
                       <entry>The list of actions to execute each time this state is exited.</entry>
				       <entry>
				           <emphasis>0..*</emphasis>
				       </entry>
				       <entry>Empty</entry>
                   </row>
               </tbody>
          </tgroup>
        </table>
        <para>
            Below is a high-level example of how these common TransitionableState properties can be configured in XML form
            or directly in Java code.
        </para>
        <sect2 id="state-xml">
        	<title>XML-based state template</title>
       	    <programlisting>
    &lt;flow start-state="stateId"&gt;
        &lt;some-state id="stateId"&gt;
            &lt;property .../&gt;
            
            &lt;entry-actions&gt;
                ...
            &lt;/entry-actions&gt;

            &lt;transition .../&gt;
            
            &lt;exit-actions&gt;
    	        ...
            &lt;/exit-actions&gt;

            &lt;exception-handler ../&gt;
        &lt;/some-state&gt;
    &lt;/flow&gt;
         	</programlisting>
        </sect2>
        <sect2 id="state-java">
           <title>Java state API example</title>
           <programlisting>
    Flow flow = new Flow("id");
    TransitionableState state = new SomeConcreteStateType(flow, "stateId");
    state.setProperty(..., ...);
    state.addEntryAction(...);
    state.addTransition(...);
    state.addExitAction(...);
          </programlisting>
        </sect2>
    </sect1>
    <sect1 id="transition">
    	<title>Transition</title>
    	<para>
    	    A transition takes a flow from one state to another, defining a <emphasis>path</emphasis> through the flow.
    	</para>
    	<para>
    	    Recall that all TransitionableStates have a set of one or more transitions, each defining a 
    	    path to another state in the flow (or a recursive path back to the same state).  When a transitionable state is entered, it executes a behavior.
    	    For example, a transitionable state called "Display Form" may display a form to the user.
    	    The outcome of the state's execution, called an event, is used to drive execution of 
    	    one of the state's transitions.  For example, the user may press the form submit button which
    	    signals a <emphasis>submit</emphasis> event that matches the transition to
    	    the "Process Submit" state.
    	</para>
    	<para>
    		This event-driven transition execution process is shown graphically below:
    	</para>
		<mediaobject>
			<imageobject role="fo">
				<imagedata fileref="images/transition-statediagram.jpg" format="JPEG" align="center"/>
			</imageobject>
			<imageobject role="html">
				<imagedata fileref="images/transition-statediagram.jpg" format="JPEG" align="center"/>
			</imageobject>
			<caption>
				<para>Transition execution</para>
			</caption>
		</mediaobject>
		<para>
			A transition is defined by an instance of <literal>org.springframework.webflow.Transition</literal>.
			Its properties are summarized below:
		</para>
    	<table>
   	        <title>Transition properties</title>
       	    <tgroup cols="4">
           	    <colspec colname="c1" colwidth="2*" />
       			<colspec colname="c2" colwidth="4*" />
   	            <colspec colname="c2" colwidth="2*" />
                <colspec colname="c2" colwidth="2*" />
                <thead>
    	            <row>
           		        <entry>Property name</entry>
           				<entry>Description</entry>
                        <entry>Cardinality</entry>
    	                <entry>Default value</entry>
       				</row>
	  			</thead>
			  	<tbody>
           			<row>
           				<entry>properties</entry>
						<entry>Additional properties describing the transition.</entry>
					    <entry>
							<emphasis>0..*</emphasis>
						</entry>
						<entry>None</entry>
       	           </row>
          		</tbody>
			  	<tbody>
           			<row>
           				<entry>matchingCriteria</entry>
						<entry>The strategy that determines if the transition matches on the occurence an event.</entry>
					    <entry>
							<emphasis>1</emphasis>
						</entry>
						<entry>Always matches</entry>
       	           </row>
          		</tbody>
				<tbody>
           			<row>
           				<entry>executionCriteria</entry>
						<entry>The strategy that determines if the transition, once matched, is allowed to execute.</entry>
					    <entry>
							<emphasis>1</emphasis>
						</entry>
						<entry>Always allowed</entry>
       	           </row>
           	   </tbody>
				<tbody>
           			<row>
           				<entry>targetStateResolver</entry>
						<entry>The strategy that calculates the target state of the transition.</entry>
					    <entry>
							<emphasis>1</emphasis>
						</entry>
						<entry></entry>
       	           </row>
           	   </tbody>
          </tgroup>
   	    </table>
   	    <para>
            Below is a high-level example of how a Transition can be configured in XML form
            or directly in Java code.
   	    </para>
        <sect2 id="transition-xml">
        	<title>Transition XML template</title>
       	    <programlisting>
    &lt;transition on="event" to="targetState"&gt;
        &lt;property .../&gt;
        &lt;action ../&gt;
    &lt;/transition&gt;
         	</programlisting>
        </sect2>
        <sect2 id="transition-java">
        	<title>Transition Java API example</title>
       	    <programlisting>
    Transition transition = new Transition(new StaticTargetStateResolver("targetState"));
    transition.setProperty(..., ...);
    transition.setMatchingCriteria(new EventIdTransitionCriteria("event"));
    transition.setExecutionCriteria(...);
         	</programlisting>
        </sect2>
        <sect2 id="transition-actioncriteria">
        	<title>Action transition criteria</title>
         	<para>
         		In the XML example note the support for the <literal>action</literal> element within the <literal>transition</literal> element.
         	</para>
         	<para>
         		A transition may be configured with one or more actions that execute <emphasis>before</emphasis> the transition itself
         		executes, as part of the <literal>executionCriteria</literal>.  If one or more of these
         		actions do not complete successfully the transition will <emphasis>not</emphasis> be allowed.
         		This <emphasis>action transition criteria</emphasis> makes it possible to execute arbitrary logic
         		after a transition is matched but before it is executed.  This is useful when you want to execute 
         		event post-processing logic.  A good example is executing data binding and validation behavior 
         		after a form submit event.
         	</para>
        </sect2>
        <sect2 id="transition-global">
        	<title>Global transitions</title>
        	<para>
        		As outlined, one or more transitions are added to all TransitionableState types, 
        		attached at the state-level.  Optionally, transitions may also be added at the
        		<emphasis>flow-level</emphasis> where they are shared by all states.  These shared
        		transitions are called <emphasis>global transitions</emphasis>.
        	</para>
        	<para>
        	    When an event is signaled in a transitionable state the state will first try and 
        	    match one of its own transitions.  If there is no match at the state level the set of
        	    global transitions will be tested.  If there still no match
        	    a <literal>NoMatchingTransitionException</literal> will be thrown.
        	</para>
        	<para>
        	    Global transitions are useful in situations where many states of the flow share 
        	    the same transitional criteria.  For example, consider a navigation menu that displays 
        	    alongside each view of a flow.  Logic to process navigation menu events is needed 
        	    by all view states.  This is the problem global transitions are designed to solve.
        	</para>
        	<sect3 id="transition-globalXml">
    	    	<title>Global transitions - XML example</title>
    	    	<para>
    	    	    The following example shows transitions defined at the state level, as well as 
    	    	    global transitions inherited from the flow level.
    	    	</para>
    	    	<programlisting>
    &lt;flow start-state="state1"&gt;
    
        &lt;some-state id="state1"&gt;
            &lt;transition on="localEvent1" to="state2"/&gt;
        &lt;/some-state&gt;

        &lt;some-state id="state2"&gt;
            &lt;transition on="localEvent1" to="state1"/&gt;
        &lt;/some-state&gt;
		        
        &lt;global-transitions&gt;
            &lt;transition on="globalEvent1" to="state1"/&gt;
            &lt;transition on="globalEvent2" to="state2"/&gt;
        &lt;/global-transitions&gt;
               
    &lt;/flow&gt;
    			</programlisting>
    			<para>
    			    In this example <literal>state1</literal> defines one transition and also inherits
    			    the two others defined within the <literal>global-transitions</literal> element.
    			    Any other states defined within this flow would also inherit those global 
    			    transitions.
    			</para>
    			<para>
    			    This example is shown graphically below:
    			</para>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/globaltransitions-statediagram.png" format="PNG" align="center"/>
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/globaltransitions-statediagram.png" format="PNG" align="center"/>
					</imageobject>
					<caption>
						<para>Global transitions</para>
					</caption>
				</mediaobject>    			
			</sect3>
		</sect2>
    </sect1>
    <sect1 id="core-states">
    	<title>Concrete state types</title>
    	<para>
    		Spring Web Flow has five (5) built-in concrete state types, all contained within the 
    		<literal>org.springframework.webflow</literal> package.  These states execute common 
    		controller behaviors including:
    		<orderedlist>
    			<listitem><para>allowing the user to participate in a flow (ViewState)</para></listitem>
    			<listitem><para>executing business application code (ActionState)</para></listitem>
    			<listitem><para>making a flow routing decision (DecisionState)</para></listitem>
    			<listitem><para>spawning another flow as a subflow (SubflowState)</para></listitem>
    			<listitem><para>terminating a flow (EndState)</para></listitem>
    		</orderedlist>
    	</para>
    	<para>
    		Each of these state types, with the exception of EndState, is transitionable.
    		This hierarchy is illustrated below:
    	</para>
		<mediaobject>
			<imageobject role="fo">
				<imagedata fileref="images/state-classdiagram.jpg" format="JPEG" align="center"/>
			</imageobject>
			<imageobject role="html">
				<imagedata fileref="images/state-classdiagram.jpg" format="JPEG" align="center"/>
			</imageobject>
			<caption>
				<para>State class diagram</para>
			</caption>
		</mediaobject>
    	<sect2 id="viewState">
    		<title>ViewState</title>
    		<para>
    			When entered, a view state allows the user (or other external client) to participate
    			in a flow.  This participation process goes as follows:
    			<orderedlist>
    				<listitem>
    					<para>
	    					The entered view state makes a <literal>org.springframework.webflow.ViewSelection</literal> 
		   	 				that selects a <emphasis>logical</emphasis> response to issue with the data necessary 
   			 				to issue it.
   		 			</para>
    				</listitem>
    				<listitem>
    					<para>
	    					The flow execution 'pauses' in this state, and control is returned to the calling 
    						system.
    					</para>
    				</listitem>
    				<listitem>
    					<para>
	    				    The calling system uses the returned <literal>ViewSelection</literal> to present an
    					    interface (or other response) to the user.
    					</para>
    				</listitem>
    				<listitem>
    					<para>
	    				    After some 'think time', the user submits an input event to resume the flow execution 
    					    from the 'paused' point.
    					</para>
    				</listitem>
    			</orderedlist>
    		</para>
    		<para>
    		    Spring Web Flow gives you full control over the view selection process and, on resume,
    		    how a view state responds to an user input event.  It's important to understand that Spring Web Flow does <emphasis>not</emphasis>
    		    care for response rendering--as a controller, a flow makes <emphasis>logical</emphasis> view selections when user input is required. 
    		    It is up to the calling system to issue a response suitable for the environment in which the flow is executing.
    		</para>
    	    <para>
    	    	The properties of a <literal>org.springframework.webflow.ViewState</literal> are summarized below:
    	    </para>
	    	<table>
    	        <title>ViewState properties</title>
        	    <tgroup cols="4">
            	    <colspec colname="c1" colwidth="2*" />
        			<colspec colname="c2" colwidth="4*" />
    	            <colspec colname="c2" colwidth="2*" />
	                <colspec colname="c2" colwidth="2*" />
	                <thead>
       		            <row>
               		        <entry>Property name</entry>
               				<entry>Description</entry>
	                        <entry>Cardinality</entry>
       		                <entry>Default value</entry>
           				</row>
		  			</thead>
				  	<tbody>
            			<row>
              				<entry>viewSelector</entry>
							<entry>The strategy that makes the view selection when this state is entered.</entry>
						    <entry>
								<emphasis>0..1</emphasis>
					       </entry>
					       <entry>Null</entry>
        	           </row>
            	   </tbody>
	          </tgroup>
    	    </table>
    	    <para>
    	    	The properties of a <literal>org.springframework.webflow.ViewSelection</literal> are summarized below:
    	    </para>
	    	<table>
    	        <title>ViewSelection properties</title>
        	    <tgroup cols="4">
            	    <colspec colname="c1" colwidth="2*" />
        			<colspec colname="c2" colwidth="4*" />
	                <colspec colname="c2" colwidth="2*" />
    	            <colspec colname="c2" colwidth="2*" />
	                <thead>
       		            <row>
               		        <entry>Property name</entry>
               				<entry>Description</entry>
	                        <entry>Cardinality</entry>
       		                <entry>Default value</entry>
           				</row>
		  			</thead>
				  	<tbody>
            			<row>
              				<entry>viewName</entry>
							<entry>The <emphasis>logical</emphasis> identifier of a response that should be issued.</entry>
						    <entry>
								<emphasis>1</emphasis>
							</entry>
 						</row>
            			<row>
              				<entry>modelMap</entry>
							<entry>The data that will be issued in the response.</entry>
						    <entry>
								<emphasis>0..*</emphasis>
							</entry>
							<entry>Empty</entry>
 						</row>
            			<row>
              				<entry>redirect</entry>
							<entry>Requests whether a browser redirect should be triggered.</entry>
						    <entry>
								<emphasis>1</emphasis>
							</entry>
							<entry>False</entry>
 						</row>
            	   </tbody>
	          </tgroup>
    	    </table>
    	    <sect3 id="viewSelector">
    			<title>ViewSelector</title>
	    		<para>
    				The creational strategy that is responsible for making a <literal>ViewSelection</literal> when an <literal>ViewState</literal> is entered
    				is <literal>org.springframework.webflow.ViewSelector</literal>.  This provides a plugin-point for customizing <emphasis>how</emphasis>
    				the <literal>viewName</literal> is calculated, how the <literal>modelMap</literal> is prepared, and whether a redirect should be issued.
    			</para>
    			<para>
    			    Two <literal>ViewSelector</literal> implementations are provided with Spring Web Flow:
    			</para>
	    		<table>
    	   			<title>ViewSelector implementations</title>
        		    <tgroup cols="2">
		           	    <colspec colname="c1" colwidth="2*" />
        				<colspec colname="c2" colwidth="4*" />
	        	        <thead>
       		    	        <row>
               			        <entry>Implementation</entry>
               					<entry>Description</entry>
               			    </row>
						</thead>
					  	<tbody>
            				<row>
              					<entry>SimpleViewSelector</entry>
								<entry>
									Returns a ViewSelection with a static <literal>viewName</literal> and <literal>modelMap</literal> containing the union of 
									the attributes in flow scope and request scope.  Supports setting a <literal>requestConversationRedirect</literal>
									flag that triggers a browser redirect to the selected view.  The default implementation.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>RedirectViewSelector</entry>
								<entry>
									Returns a ViewSelection that triggers a browser redirect to an abitrary external URL.
									The <literal>viewName</literal> is the relative URL to redirect to.  Attributes added to the <literal>modelMap</literal>
									become URL query parameters.  Mainly used by end states to
									<emphasis>redirect after flow completion</emphasis>.
								</entry>
	        	   	        </row>
	            		</tbody>
		       		</tgroup>
    		    </table> 	
    		</sect3>
    		<para>
    			The class diagram below shows the ViewState and the associated types used to carry
    			out the view selection process:
    		</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/viewstate-classdiagram.jpg" format="JPEG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/viewstate-classdiagram.jpg" format="JPEG" align="center"/>
				</imageobject>
				<caption>
					<para>ViewState class diagram</para>
				</caption>
			</mediaobject>
    	    <sect3 id="viewStateXml">
    	    	<title>ViewState XML - simple view selection</title>
    	    	<para>
    	    	    The following example shows a <literal>view-state</literal> definition in XML that makes a simple view 
    	    	    selection when entered, selecting the <literal>searchForm</literal> view for display and, on resume, responding to 
    	    	    two possible user input events (submit and cancel) in different ways:
    	    	</para>
    	    	<programlisting>
    &lt;flow start-state="displaySearchForm"&gt;
        &lt;view-state id="displaySearchForm" view="searchForm"&gt;
            &lt;transition on="submit" to="processFormSubmission"/&gt;
            &lt;transition on="cancel" to="processCancellation"/&gt;
        &lt;/view-state&gt;
        
        ...
    &lt;/flow&gt;
    			</programlisting>
			</sect3>  		
    	    <sect3 id="viewStateJava">
    	    	<title>ViewState API - simple view selection</title>
    	    	<para>
    	    	    The following example shows the equivalent view state definition using 
    	    	    the FlowBuilder API:
    	    	</para>
    	    	<programlisting>
    public class SearchFlowBuilder extends AbstractFlowBuilder {
    	public void buildStates() {
    	    addViewState("displaySearchForm", "searchForm",
    	        new Transition[] {
    	            transition(on("submit"), to("processFormSubmission")),
    	            transition(on("cancel"), to("processFormCancellation"))
    	        }
    	    );
            ...    	          
        }
    }	
    			</programlisting>
			</sect3>
    	    <sect3 id="viewStateXml-redirect">
    	    	<title>ViewState XML - conversation redirect</title>
    	    	<para>
    	    	    The following example illustrates a <literal>view-state</literal> definition in XML that makes a simple view 
    	    	    selection when entered, redirecting to the <literal>yourList</literal> view for display.
    	    	</para>
    	    	<programlisting>
    &lt;flow start-state="displayList"&gt;
        &lt;view-state id="displayList" view="yourList" redirect="true"&gt;
            &lt;transition on="add" to="addListItem"/&gt;
        &lt;/view-state&gt;
        
        ...
    &lt;/flow&gt;
    			</programlisting>
			</sect3>
			<para>
			    This is example is called a <emphasis>conversation redirect</emphasis> because the ViewSelection made is cached 
			    between request as the "current view selection" for the active conversation.  The actual redirect sent is a
			    conversation URL that renders the current view selection on a request into the server.
			</para>
    	    <sect3 id="viewStateJava-redirect">
    	    	<title>ViewState API - conversation redirect</title>
    	    	<para>
    	    	    The following example shows the equivalent view state definition using 
    	    	    the FlowBuilder API:
    	    	</para>
    	    	<programlisting>
    public class SearchFlowBuilder extends AbstractFlowBuilder {
    	public void buildStates() {
    	    addViewState("displayList", new SimpleViewSelector("yourView", true),
   	            transition(on("add"), to("addListItem"))
    	    );
            ...    	          
        }
    }	
    			</programlisting>
			</sect3>
    	    <sect3 id="viewStateXml-formState">
    	    	<title>ViewState XML - form state behavior</title>
    	    	<para>
    	    	    The following example illustrates a <literal>view-state</literal> definition in XML that encapsulates 
    	    	    typical "form state" behavior.
    	    	</para>
    	    	<para>
    	    	    Consider the requirements of typical input forms.  Most forms require <emphasis>pre-render</emphasis> or
    	    	    <emphasis>setup</emphasis> logic to execute before the form is displayed.  For example, such logic might 
    	    	    load the <emphasis>backing form object</emphasis> from the database, install formatters for formatting 
    	    	    form field values, and pull in supporting form data needed to populate drop-down menus.
    	    	</para>
    	    	<para>
    	    	    In addition, most forms require <emphasis>post-back</emphasis> or <emphasis>submission</emphasis> logic 
    	    	    to execute when the form is submitted.  This logic typically involves binding form input to the
    	    	    <emphasis>backing form object</emphasis> and performing type conversion and data validation.
    	    	</para>
    	    	<para>
    	    	    This "form state" behavior of form setup, display, and post-back is handled elegantly in Spring Web Flow 
    	    	    by the capabilities of the <literal>view-state</literal> construct.  See below:
    	    	</para>
    	    	<programlisting>
    &lt;flow start-state="displayForm"&gt;
        &lt;view-state id="displayForm" view="form"&gt;
            &lt;entry-actions&gt;
                &lt;action bean="formAction" method="setupForm"/&gt;
            &lt;/entry-actions&gt;
            
            &lt;transition on="submit" to="saveForm"&gt;
                &lt;action bean="formAction" method="bindAndValidate"/&gt;
            &lt;/transition&gt;
        &lt;/view-state&gt;
        ...
    &lt;/flow&gt;
    			</programlisting>
    			<para>
    			   This reads "<emphasis>when the <literal>displayForm</literal> state is entered, execute the <literal>setupForm</literal> method on the 
    			   <literal>formAction</literal> and render the <literal>form</literal> view.  On <literal>submit</literal> transition to the <literal>saveForm</literal> state if the 
    			   <literal>bindAndValidate</literal> method on the <literal>formAction</literal> executes successfully.</emphasis>"
    			</para>
			</sect3>
    	</sect2>
    	<sect2 id="actionState">
    		<title>ActionState</title>
    		<para>
    			When entered, an action state executes business application code, then responds to the result of that 
    			execution by deciding what state in the flow to enter next.  Specifically:
    			<orderedlist>
    				<listitem>
    					<para>
	    					The entered action state executes an ordered list of one or more <literal>org.springframework.webflow.Action</literal> 
    						instances.  This <literal>Action</literal> interface is the central abstraction that 
    						encapsulates the execution of a logical unit of application code.
    					</para>
    				</listitem>
    				<listitem>
    					<para>
	    					The state determines if the outcome of the first action's execution matches a 
   		 					transition.  If there is a match, the transition is executed.  If there is no match, 
    						the next action in the list is executed.  This process continues until a transition is 
    						matched or the list of actions is exhausted.
    					</para>
    				</listitem>
    			</orderedlist>
    		</para>
    		<para>
    		    Spring Web Flow gives you full control over implementing your own actions and configuring when they should be invoked 
    		    within the lifecycle of a flow.  The system can also <emphasis>automatically</emphasis> adapt methods on
    		    your existing application objects (POJOs) to the <literal>Action</literal> interface in a non-invasive manner.
    		</para>
    		<sect3>
    			<title>Action execution points</title>
    			<para>
    			    As outlined, the <literal>ActionState</literal> is the central state type for invoking one 
    			    or more actions and responding to their result to drive a state transition.  There are
    			    also other points within the lifecycle of a flow where an Action can be executed.
    			    At all of these points the only requirement is that these actions implement the central
    			    <literal>org.springframework.webflow.Action</literal> interface.
	    		</para>
	    		<table>
    	   			<title>Points in a Flow where an Action can be executed</title>
        		    <tgroup cols="2">
		           	    <colspec colname="c1" colwidth="2*" />
        				<colspec colname="c2" colwidth="4*" />
	        	        <thead>
       		    	        <row>
               			        <entry>Point</entry>
               					<entry>Description</entry>
               			    </row>
						</thead>
					  	<tbody>
            				<row>
              					<entry>on flow start</entry>
								<entry>
									Each time an execution of a flow starts.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>on state entry</entry>
								<entry>
									Each time a state enters.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>on transition</entry>
								<entry>
									Each time a state transition is matched but before it is executed.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>on state exit</entry>
								<entry>
									Each time a transitionable state exits.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>on flow end</entry>
								<entry>
									Each time an execution of a flow terminates.
								</entry>
	        	   	        </row>
	            		</tbody>
		       		</tgroup>
    		    </table> 	
    		</sect3>
    		<sect3>
    			<title>Action properties</title>
    			<para>
    			    An <literal>Action</literal> may be annotated with properties by wrapping the Action 
    			    in a decorator, an instance of <literal>org.springframework.webflow.AnnotatedAction</literal>.
    			    These properties may provide descriptive characteristics, or may be used to affect
    			    the action's execution in a specific usage context.
	    		</para>
    			<para>
    			    Support for setting several common properties are provided for convenience.  These 
    			    include:
	    		</para>
	    		<table>
    	   			<title>Common Action properties</title>
        		    <tgroup cols="2">
		           	    <colspec colname="c1" colwidth="2*" />
        				<colspec colname="c2" colwidth="4*" />
	        	        <thead>
       		    	        <row>
               			        <entry>Property name</entry>
               					<entry>Description</entry>
               			    </row>
						</thead>
					  	<tbody>
            				<row>
              					<entry>caption</entry>
								<entry>
									A short description about the action, suitable for display as a tooltip.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>description</entry>
								<entry>
									A long description about the action, suitable for display in a text box.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>name</entry>
								<entry>
									The name of the action, used to qualify the action's result event.
									For example, an Action named <literal>placeOrder</literal> that returns <literal>success</literal>
									would be assigned a result event identified by <literal>placeOrder.success</literal>.
									This allows you to distinguish logical execution outcomes by action, useful when 
									invoking multiple actions as part of a chain.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>method</entry>
								<entry>
									The name of the target method on the Action instance to invoke to carry out execution.
									This facilitates multiple <emphasis>action methods</emphasis> per Action instance.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>resultName</entry>
								<entry>
									If the target method is an arbitrary public method that returns a value, this is the name of the attribute
									the value should be indexed under.
								</entry>
	        	   	        </row>
            				<row>
              					<entry>resultScope</entry>
								<entry>
									If the resultName property is specified, this is the scope the result attribute should be indexed in.
									For example, "request" or "flow" scope.
								</entry>
	        	   	        </row>
	            		</tbody>
		       		</tgroup>
    		    </table> 	
			</sect3>    		
    		<para>
    			The class diagram below shows the ActionState and the associated types used to carry
    			out the action execution process:
    		</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/actionstate-classdiagram.jpg" format="JPEG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/actionstate-classdiagram.jpg" format="JPEG" align="center"/>
				</imageobject>
				<caption>
					<para>ActionState class diagram</para>
				</caption>
			</mediaobject>
    	    <sect3 id="actionStateXml-simple">
    	    	<title>ActionState XML - simple action execution</title>
    	    	<para>
    	    	    The following example constructs an <literal>ActionState</literal> definition from
    	    	    XML that executes a single action when entered and then responds to its result:
    	    	<programlisting>
    &lt;flow start-state="displaySearchCriteria"&gt;
        ...
        &lt;action-state id="executeSearch"&gt;
            &lt;action bean="searchAction"/&gt;
            &lt;transition on="success" to="displayResults"/&gt;
        &lt;/action-state&gt;
        ...
    &lt;/flow&gt;
    			</programlisting>
    			    This state definition reads "<emphasis>when the <literal>executeSearch</literal>
    			    state is entered, execute the <literal>searchAction</literal>.  On successful execution,
    			    transition to the <literal>displayResults</literal> state</emphasis>."
    			</para>
    			<para>
    			    The association between the <literal>searchAction</literal> id and an 
    			    <literal>Action</literal> implementation is made by the XmlFlowBuilder at 
    			    Flow configuration time using a service registry, typically a
    			    Spring BeanFactory.  For example:
    	    	<programlisting>
    &lt;beans&gt;
        &lt;bean id="searchAction" class="example.webflow.SearchAction"/&gt;
    &lt;/beans&gt;
    			</programlisting>
    			    ... associates the <literal>searchAction</literal> with a single instance of 
    			    <literal>example.webflow.SearchAction</literal>.
    			</para>
    			<para>
    			    A simple <literal>SearchAction</literal> implementation might look like this:
    			<programlisting>
    public class SearchAction implements Action {
        private SearchService searchService;
        
        public SearchAction(SearchService searchService) {
            this.searchService = searchService;
        }
        
        public Event execute(RequestContext context) {
            // lookup the search criteria in "flow scope"
            SearchCriteria criteria =
                (SearchCriteria)context.getFlowScope().getAttribute("criteria");
    	        
            // execute the search
            Collection results = searchService.executeSearch(criteria);
    	    
            // set the results in "request scope"
            context.getRequestScope().setAttribute("results", results);
    	    
            // return "success"
            return new Event(this, "success");
        }
    }
    			</programlisting>
    			</para>
			</sect3>		
    	    <sect3 id="actionStateJava-simple">
    	    	<title>ActionState API - simple action execution</title>
    	    	<para>
    	    	    The following example constructs the equivalent action state definition using 
    	    	    the FlowBuilder API:
    	    	</para>
    	    	<programlisting>
    public class SearchFlowBuilder extends AbstractFlowBuilder {
    	public void buildStates() {
            ...
            addActionState("executeSearch", action("searchAction"),
                transition(on("success"), to("displayResults")));
            ...    	          
        }
    }	
    			</programlisting>
			</sect3> 		
    	    <sect3 id="actionStateXml-multiActionMethod">
    	    	<title>ActionState XML - action method execution</title>
    	    	<para>
    	    	    The next example constructs an <literal>ActionState</literal> definition from XML that 
			executes a single <emphasis>action method</emphasis> on a <literal>org.springframework.webflow.MultiAction</literal>
			and then responds to its result:
    	    	<programlisting>
    &lt;flow start-state="displaySearchCriteria"&gt;
        ...
        &lt;action-state id="executeSearch"&gt;
            &lt;action bean="searchFlowAction" method="executeSearch"/&gt;
            &lt;transition on="success" to="displayResults"/&gt;
        &lt;/action-state&gt;
        ...
    &lt;/flow&gt;
    			</programlisting>
    			    This state definition reads "<emphasis>when the <literal>executeSearch</literal>
    			    state is entered, execute the <literal>executeSearch</literal> method on the
    			    <literal>searchFlowAction</literal>.  On successful execution,
    			    transition to the <literal>displayResults</literal> state</emphasis>."
    			</para>
    			<para>
    			    A <literal>SearchFlowAction</literal> implementation containing multiple action methods 
    			    might look like this:
    			<programlisting>
    public class SearchFlowAction extends MultiAction {
        private SearchService searchService;
        
        public SearchAction(SearchService searchService) {
            this.searchService = searchService;
        }
        
        public Event executeSearch(RequestContext context) {
            // lookup the search criteria in "flow scope"
            SearchCriteria criteria =
                (SearchCriteria)context.getFlowScope().getAttribute("criteria");
    	        
            // execute the search
            Collection results = searchService.executeSearch(criteria);
    	    
            // set the results in "request scope"
            context.getRequestScope().setAttribute("results", results);
    	    
            // return "success"
            return success();
        }

        public Event someOtherRelatedActionMethod(RequestContext context) {
            return success();
        }

        public Event yetAnotherRelatedActionMethod(RequestContext context) {
            return success();
        }
    }	
    			</programlisting>
    				As you can see, this allows you to define one to many action methods per Action class. 
    				With this approach, there are two requirements:
    				<orderedlist>
 						<listitem>
 							<para>
 								Your Action class must extend from <literal>org.springframework.webflow.MultiAction</literal>, or 
 								another class that extends from <literal>MultiAction</literal>.  The multi action cares 
    							for the action method dispatch that is based on the value of the <literal>method</literal>
    							property.
 							</para>
 						</listitem>
 						<listitem>
 							<para>
			    				Each action method must conform to the signature illustrated above: <literal>public Event ${method}(RequestContext) { ... }	</literal>
 							</para>
 						</listitem>   				
    				</orderedlist> 
    			</para>
			</sect3>    		
    	    <sect3 id="actionStateJava-multiActionMethod">
    	    	<title>ActionState API - action method execution</title>
    	    	<para>
    	    	    The following example constructs the equivalent action state definition using 
    	    	    the FlowBuilder API:
    	    	</para>
    	    	<programlisting>
    public class SearchFlowBuilder extends AbstractFlowBuilder {
    	public void buildStates() {
            ...
            addActionState("executeSearch", method("executeSearch", action("searchAction")),
                transition(on("success"), to("displayResults")));
            ...    	          
        }
    }	
    			</programlisting>
			</sect3>    		
    	    <sect3 id="actionStateXml-pojoActionMethod">
    	    	<title>ActionState XML - POJO action method execution</title>
    	    	<para>
    	    	    The next example constructs a <literal>ActionState</literal> definition from XML that 
					executes a single method on your Plain Old Java Object (POJO) and then responds to the result:
    	    	<programlisting>
    &lt;flow start-state="displaySearchCriteria"&gt;
        ...
        &lt;action-state id="executeSearch"&gt;
            &lt;action bean="searchService" method="executeSearch(${flowScope.criteria})"
                       resultName="results"/&gt;
            &lt;transition on="success" to="displayResults"/&gt;
        &lt;/action-state&gt;
        ...
    &lt;/flow&gt;
    			</programlisting>
    			    This state definition reads "<emphasis>when the <literal>executeSearch</literal>
    			    state is entered, execute the <literal>executeSearch</literal> method on the
    			    <literal>searchService</literal> passing it the object indexed by name <literal>criteria</literal>
    			    in <literal>flowScope</literal>.  On successful execution, expose the method 
    			    return value in request scope under the name <literal>results</literal> 
    			    and transition to the <literal>displayResults</literal> state</emphasis>."
    			</para>
    			<para>
    				In this example, the referenced bean <literal>searchService</literal> would be
    				<emphasis>your application object</emphasis>, typically a transactional
    				business service.  Such a service implementation must have defined the
    				the <literal>Collection executeSearch(SearchCriteria)</literal> method, 
    				typically by implementing a service interface:
    			</para>
    			<programlisting>
    public interface SearchService {
        public Collection executeSearch(SearchCriteria criteria);
    }	
    			</programlisting>
    			<para>
    			    With this approach there are no requirements on the signature of the methods that carry out 
    			    action execution, nor is there any requirement to extend from a Web Flow specific base class.
    			    Basically, you are not required to write a custom <literal>Action</literal> implementation at all--you 
    			    simply instruct Spring Web Flow to call your business methods directly.  The need
    			    the for custom "glue code" to bind your web-tier to your middle-tier is eliminated.
    			</para>
    			<para>
    			    Spring Web Flow achieves this by automatically adapting the method on your existing
    			    application object to the <literal>Action</literal> interface and caring for
    			    exposing any return value in the correct scope.
    			</para>
    			<para>
    			    This is adaption process is shown graphically below:
    			</para>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/actionadapter-classdiagram.png" format="PNG" align="center"/>
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/actionadapter-classdiagram.png" format="PNG" align="center"/>
					</imageobject>
					<caption>
						<para>Bean-&gt;Action adapter</para>
					</caption>
				</mediaobject>
			</sect3>    		
    	    <sect3 id="actionStateJava-pojoActionMethod">
    	    	<title>ActionState API - POJO action method execution</title>
    	    	<para>
    	    	    The following example constructs the equivalent action state definition using 
    	    	    the FlowBuilder API:
    	    	</para>
    	    	<programlisting>
    public class SearchFlowBuilder extends AbstractFlowBuilder {
    	public void buildStates() {
    	    ...
            AnnotatedAction searchAction =
                method("executeSearch(${flowScope.criteria})", action("searchAction"));
            searchAction.setResultName("results");
            addActionState("executeSearch", searchAction,
                transition(on("success"), to("displayResults")));
            ...    	          
        }
    }	
    			</programlisting>
			</sect3>    		
    	</sect2>
    	<sect2 id="decisionState">
    		<title>DecisionState</title>
    		<para>
    			When entered, a decision state makes a flow routing decision.  This process consists of:
    			<orderedlist>
    				<listitem>
    					<para>
	    					Evaluating one or more boolean expressions against the executing flow to decide 
	    					what state to transition to next.
    					</para>
    				</listitem>
    				<listitem>
    					<para>
	    					Alternatively, executing a single <emphasis>decision action</emphasis> and evaluating its return event to 
	    					decide what state to transition to next.  This action should be idempotent; that is, it should not 
	    					have side effects.  Convenient support for evaluating return values of methods invoked 
	    					on your application objects (POJOs) is provided.
    					</para>
    				</listitem>
    			</orderedlist>
    		</para>
    	    <sect3 id="decisionStateXml-expression">
    	    	<title>DecisionState XML - expression evaluation</title>
    	    	<para>
    	    	    The following example constructs an <literal>DecisionState</literal> from
    	    	    XML that evalutes a boolean expression to determine what transition 
    	    	    to execute:
    	    	</para>
    	    	<programlisting>
    &lt;flow start-state="shippingRequired"&gt;
    
        &lt;decision-state id="shippingRequired"&gt;
            &lt;if test="${flowScope.order.needsShipping} then="enterShippingDetails" else="placeOrder"/&gt;
        &lt;/decision-state&gt;
        ...
    &lt;/flow&gt;
    			</programlisting>
    			<para>
    			    This state definition reads "<emphasis>if the <literal>needsShipping</literal> property on the 
    			    <literal>order</literal> object in flow scope is true, transition to the <literal>enterShippingDetails</literal>
    			    state, otherwise transition to the <literal>placeOrder</literal> state</emphasis>."
    			</para>
    			<para>
    			    <emphasis>Caution</emphasis>: flow definitions should <emphasis>not</emphasis> be vehicles for 
    			    business logic.  In this case the decision made was controller logic, reasoning on a
    			    pre-calculated value to decide what step of the flow to transition to next.  That is the kind of logic that 
    			    should be in a flow definition.  In contrast, having the state <emphasis>itself</emphasis> embed 
    			    the business rule defining how shipping status is calculated is a misuse.
    			    Instead, push such a calculation into application code where it belongs and <emphasis>instruct</emphasis>
    			    the flow to invoke that code using an action.
    			</para>
			</sect3>
    	    <sect3 id="decisionStateXml-action">
    	    	<title>DecisionState XML - decision action</title>
    	    	<para>
    	    	    The following example constructs an <literal>DecisionState</literal> from
    	    	    XML that executes a action that forms the basis for the transition decision:
    	    	</para>
    	    	<programlisting>
    &lt;flow start-state="shippingRequired"&gt;
    
        &lt;decision-state id="shippingRequired"&gt;
            &lt;action bean="shippingService" method="isShippingRequired"/&gt;
            &lt;transition on="yes" to="enterShippingDetails"/&gt;
            &lt;transition on="no" to="placeOrder"/&gt;
        &lt;/decision-state&gt;
        ...
    &lt;/flow&gt;
    			</programlisting>
    			<para>
    			    This state definition reads "<emphasis>if the <literal>isShippingRequired</literal> method on the 
    			    <literal>shippingService</literal> returns true, transition to the <literal>enterShippingDetails</literal>
    			    state, otherwise transition to the <literal>placeOrder</literal> state</emphasis>."
    			</para>
    			<para>
    			    Note how the boolean return value of the <literal>isShippingRequired</literal> method is
    			    converted to the event identifiers <literal>yes</literal> or <literal>no</literal>.
    			</para>
    			<para>
    			    This conversion process is handled by the action adapter responsible for adapting the method on your 
    			    application object to the <literal>org.springframework.webflow.Action</literal> interface.  By default, this
    			    adapter applies a number of rules for creating a result event from a method return value.
    			</para>
    			<para>
	    			These conversion rules are:
    			</para>
		    	<table>
    		        <title>Default method return value to Event conversion rules</title>
	        	    <tgroup cols="2">
   		         	    <colspec colname="c1" colwidth="2*" />
   		     			<colspec colname="c2" colwidth="4*" />
	   		    	    <thead>
       		        	    <row>
               		    	    <entry>Return type</entry>
	               				<entry>Event identifier</entry>
	           				</row>
			  			</thead>
					  	<tbody>
			        	    <row>
               		    	    <entry>boolean</entry>
               		    	    <entry>yes or no</entry>
	           				</row>
			        	    <row>
               		    	    <entry>java.lang.Enum</entry>
               		    	    <entry>this.name()</entry>
	           				</row>
	           				<row>
	           				    <entry>org.springframework.core.enum.LabeledEnum</entry>
	           				    <entry>this.getLabel()</entry>
	           				</row>
	           				<row>
	           				    <entry>null</entry>
	           				    <entry>null</entry>
	           				</row>
	            	   </tbody>
					</tgroup>
    		    </table>
    			<para>
    				You may customize these default conversion policies by setting a custom <literal>EventFactory</literal>
    				instance on the bean invoking action performing the adaption.
    			</para>
			</sect3>
    	    <sect3 id="decisionStateXml-actionenum">
    	    	<title>DecisionState XML - decision action with enum return value</title>
    	    	<para>
    	    	    The following example constructs an <literal>DecisionState</literal> from
    	    	    XML that executes a action that invokes a method on an application object that 
    	    	    returns a java.lang.Enum:
    	    	</para>
    	    	<programlisting>
    &lt;flow start-state="shippingRequired"&gt;
    
        &lt;decision-state id="shippingRequired"&gt;
            &lt;action bean="shippingService" method="calculateShippingMethod(${flowScope.order})"/&gt;
            &lt;transition on="BASIC" to="enterBasicShippingDetails"/&gt;
            &lt;transition on="EXPRESS" to="enterExpressShippingDetails"/&gt;
            &lt;transition on="NONE" to="placeOrder"/>
        &lt;/decision-state&gt;
        ...
    &lt;/flow&gt;
    			</programlisting>
    			<para>
    			    This state definition reads "<emphasis>if the <literal>getShippingMethod</literal> method on the 
    			    <literal>shippingService</literal> returns <literal>BASIC</literal> for the current order, transition to the <literal>enterBasicShippingDetails</literal>
    			    state.  If the return value is <literal>EXPRESS</literal> transition to the <literal>enterExpressShippingDetails</literal> state.
    			    If the return value is <literal>NONE</literal> transition to the <literal>placeOrder</literal> state</emphasis>."
    			</para>
			</sect3>
    	</sect2>
    	<sect2 id="subflowState">
    		<title>SubflowState</title>
    		<para>
    			When entered, a subflow state spawns another flow as a subflow.
    		</para>
    		<para>
    			Recall that a flow is a reusable, self-contained controller module.  The ability for one flow to <emphasis>call</emphasis> another flow
    			gives you the ability to compose independent modules together to create complex controller workflows.  Any flow can be used as subflow 
    			by any other flow, and there is a well-defined contract in play by what it means to be a flow.
    			Specifically:
    		</para>
    		<para>
    			<orderedlist>
    				<listitem>
    					<para>
    						A Flow is an instance of <literal>org.springframework.webflow.Flow</literal>.
    					</para>
    				</listitem>
    				<listitem>
    					<para>
    						A newly launched flow can be passed input attributes which it may choose 
    						to map into its own local scope.
    					</para>
    				</listitem>
    				<listitem>
    					<para>
    						A ending flow can return output attributes.  If the flow was launched as a subflow,
    						the resuming parent flow may choose to map the output attributes into its own scope.
    					</para>
    				</listitem>
    			</orderedlist>
    		</para>
    		<para>
    		   It is helpful to think of the process of calling a flow as similiar to calling a Java method.  Flows can 
    		   be passed input arguments and can produce return values just like methods can.  Flows are more powerful because 
    		   they are potentially long-running, as they can span more than one request into the server.
    		</para>
    		<para>
    		   The SubflowState constructs used in spawning a flow as a subflow is shown graphically below:
    		</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/subflowstate-classdiagram.png" format="PNG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/subflowstate-classdiagram.png" format="PNG" align="center"/>
				</imageobject>
				<caption>
					<para>SubflowState class diagram</para>
				</caption>
			</mediaobject>
    	</sect2>
    	<sect2 id="endState">
    		<title>EndState</title>
    		<para>
    			When entered, an end state terminates a flow.
    		</para>
    	</sect2>
    </sect1>
</chapter>