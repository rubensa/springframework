<?xml version="1.0" encoding="UTF-8"?>
<chapter id="phonebook">
	<title>Phonebook - a typical Spring Web Flow application</title>
	<sect1>
		<title>Introduction</title>
		<para>
			This chapter explains some of the basic concepts of Spring Web Flow
			to you, using the Phonebook sample application distributed with the
			Spring Web Flow release. The phonebook application incorporates
			one of the most often found flows in web applications; i.e. the
			<emphasis>search + master/detail flow</emphasis>. In the next couple of
			sections, we will explain how to build that flow using Spring Web Flow.
			Let's first discuss a good process for building flows into your
			web application:
		</para>
		<para>
			<orderedlist spacing="compact">
				<listitem>
					<para>The first step in the process of adding a flow to your
					application is to actually <emphasis>design</emphasis> the flow.
					Storyboarding the flow helps here with simple sketches (and/or)
					a state diagram</para>
				</listitem>
				<listitem>
					<para>The next step is to <emphasis>create the configuration for
					the Flow</emphasis>. The configuration should reflect the flow you've
					previously drawn on paper for example.</para>
				</listitem>
				<listitem>
					<para>After you've created the configuration for the flow, it's time
					to <emphasis>test the execution</emphasis> of the flow. This can be done using implementations
					of actions that haven't been fully completed yet.</para>
				</listitem>
				<listitem>
					<para>After you've ensured the flow executes correctly, you can
					implement the logic encapsulated in your flow by <emphasis>completing the
					action classes</emphasis> you've added to your flow configuration.
					In other words: the Action classes are <emphasis>the</emphasis> place
					where you can implement logic and they somewhat resemble Spring MVC controllers
					(in fact, they can be Spring MVC controllers or action-like artifacts
					from any other MVC framework).</para>
				</listitem>
				<listitem>
					<para>The last thing you need to do before you can deploy your flow is
					to <emphasis>implement the views</emphasis> for your flow. The views
					are the individual pages presented to the user. So remember:
					the views are the places where users are allowed to interact with the flow.</para>
				</listitem>
				<listitem>
					<para>Deploy the flow for in-container testing. Of course there is
					nothing out-of-the-ordinary here, it's just deploying your WAR file for
					example to a servlet container or application server.</para>
				</listitem>
			</orderedlist>
		</para>
		<para>
			<emphasis>Note that of course, some of these steps can happen in parallel; coding
			of artifacts such as Action classes can perfectly be done right along with
			implementing your view resources (JSP, Velocity templates, et cetera).</emphasis>
		</para>
	</sect1>
	<sect1>
		<title>Designing the flow</title>
		<para>
			As we've said, we're going to implement a simple phonebook application that
			will allow a user to search for a specific person's information, view that
			information and edit it.
		</para>
		<sect2>
			<title>A small narrative</title>
			<para>
				Let's start with a small narrative that completely lays out our flow.
			</para>
			<para>
				<orderedlist spacing="compact">
					<listitem>
						<para>View a <emphasis>search page</emphasis> where the user
						can enter the criteria he or she wishes to use for locating
						people.</para>
					</listitem>
					<listitem>
						<para>From the <emphasis>search page</emphasis> a 
						<emphasis role="bold">submit</emphasis> button
						triggers the process of transferring the criteria to the server,
						<emphasis role="string">binding</emphasis> those criteria to a form backing object and
						<emphasis role="bold">validating</emphasis> the criteria.  For a validation
						<emphasis role="bold">error</emphasis> the user will be redirected
						back to the search page.
						If however validation succeeds, the actual search will be <emphasis role="bold">executed</emphasis>.
						After the search has completed the user will be able to
						<emphasis role="bold">view</emphasis> the list of people that have been
						found (on the <emphasis>results page</emphasis>).</para>
					</listitem>
					<listitem>
						<para>From the <emphasis>results page</emphasis> the user can <emphasis role="bold">select</emphasis>
						one of the people that have been found based on the search criteria and
						<emphasis role="bold">view</emphasis> their details on the <emphasis>details page</emphasis>. Details in this
						case are things like the person's name, contact information and people
						the person works with (colleagues).</para>
					</listitem>
					<listitem>
						<para>From the <emphasis>details page</emphasis> the user will be able to
						<emphasis role="bold">select</emphasis> a colleague and <emphasis role="bold">view</emphasis> their respective information on another
						<emphasis>details page</emphasis> and after that go back to the previously selected person.</para>
					</listitem>
				</orderedlist>
			</para>
			<para>
				<emphasis>Note: some of the text in the description above is printed in bold.
				These (usually) verbs translate directly to the events that will be signaled or
				the actions that will have to be executed in the flow. Later on, we'll explain
				in more details what these events and actions really mean.</emphasis>
			</para>
		</sect2>
		<sect2>
			<title>Graphical representation of our flow</title>
			<para>
				After we've written down our flow, we can also storyboard it a bit.
				The storyboard helps us identifying possible bottlenecks in the flow
				and see if it's complete.	
			</para>
			<para>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/phonebook-storyboard.jpg" format="JPEG" align="center"/>
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/phonebook-storyboard.jpg" format="JPEG" align="center"/>
					</imageobject>
					<caption>
						<para>The storyboard-version of our flow</para>
					</caption>
				</mediaobject>
			</para>
			<para>
				Another way to put it, is a state diagram. The following diagram depicts our flow
				in somewhat more detail.
			</para>
			<para>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/phonebook-statediagram.jpg" format="JPG" align="center"/>
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/phonebook-statediagram.jpg" format="JPG" align="center"/>
					</imageobject>
					<caption>
						<para>State diagram of the phonebook flow (maybe update state diagram)
						</para>
					</caption>
				</mediaobject>
			</para>
			<para>
				The state diagram above provides the most detailed glimpse into the design of the Flow: from it, you see all the states of the flow, what actions occur at what state, and the transitions between states.
			</para>
		</sect2>
		<sect2>
			<title>Web flow: a state machine</title>
			<para>
				You'll see shortly that a flow implementation maps very elegantly from such a diagram. Indeed, if you understand the picture above, you understand Spring Web Flow. Specifically:
			</para>
			<para>
				<itemizedlist spacing="compact">
					<listitem>
						<para>Flow definitions have one or more <emphasis>states</emphasis>, 
						one of which is marked the <emphasis>start-state</emphasis>.</para>
					</listitem>
					<listitem>
						<para>Each <emphasis>state</emphasis>, when entered, executes some kind of <emphasis>action</emphasis>.
						What action is executed varies based on the state's type and is executed 
						in polymorphic fashion. For example, a <emphasis>view state</emphasis> renders a view resource.
						An <emphasis>action state</emphasis> executes a controller Action. <emphasis>sub-flow states</emphasis> spawn sub flows
						(so flows are reusable). <emphasis>End states</emphasis>
						terminate an active execution of a flow (later on called a <literal>FlowExecution</literal>).</para>
					</listitem>
					<listitem>
						<para>Each <emphasis>state</emphasis> has one or more <emphasis>transitions</emphasis>. A <emphasis>transition</emphasis> 
						is a path from one state to another. A transition executes on the signaling of an event.</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				In general, when a user enters the flow (typically by clicking a link
				leading him to the flow or by opening up his or her browser with a particular
				URL) a new flow is started, specifically for this user. This is what we call
				the <literal>FlowExecution</literal>. The flow (obviously) starts in the start state. 
			</para>
			<para>
				There are several state types. The first (and this is what our flow starts with) is
				the <emphasis role="bold">view state</emphasis>. The view state allows users to interact
				with the flow. Typically a view state is a web page with for example a form.
				Nothing happens, until the user indicates he wants to move forward in the flow
				(by filling out a form and clicking the submit button for example).
				Clicking the submit button signals an event. The event (received by the server)
				will be translated to a transition of the flow to a different state
				(of course predefined in the flow). In other words, the <literal>FlowExecution</literal>
				(remember: this is the execution of the flow for this specific user) has
				gotten a new active state.
			</para>
			<para>
				The second state is an <emphasis role="bold">action state</emphasis>. Whereas
				view states allow for user interaction, action states don't. They execute
				actions on the server, for example the binding of the form data to a
				form backing object, or the execution of a search query.
			</para>
			<para>
				Apart from those, there are several other state types which we'll describe
				in more detail in other chapters of this reference manual.
			</para>
			<para>
				<emphasis>Remember: both action states and view states can signal events, 
				causing a transition to happen.</emphasis>
			</para>
			<para>
				When applying this to the phonebook application, we end up with the following:
				The user starts the flow with the <literal>View Search Criteria</literal> state.
				This will render the search page, with a form and a submit button. When the 
				user signals the <literal>submit</literal> event in the <literal>View Search Criteria</literal>
				state (by clicking the submit button), he will trigger a transition to the 
				<literal>Execute Query</literal> state (which, as we'll see actually 
				comprises a couple of different steps all with the different possible outcomes).
				The <literal>Execute Query</literal> state is an action state. When the
				<literal>Execute Query</literal> state completes successfully (binding and validation
				both complete without errors and the querying has been executed) another event
				is signaled, causing the <literal>FlowExecution</literal> to move to the next
				state, in this case the <literal>View Results</literal> state.
				This process of <emphasis>event -&gt; state transition -&gt; new state</emphasis>
				(either action or view) continues until an <emphasis>end state</emphasis>
				has been reached and the FlowExecution terminates.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Configuring the flow implementation using Java or XML</title>
		<para>
			So now we've got the design for the flow fleshed out and we can start creating
			the configuration for our flow. One thing we didn't yet explain is <emphasis>sub flows</emphasis>.
			When a user views a person's details and clicks on a colleague name, what he's actually
			doing is entering the same state the flow has been in before, but now for a different
			person (retrieve users details, view user details). Because this process can be
			repeated over and over again, we are going to model this as a sub flow.
			A sub flow is a reusable flow that can be spawned from a parent flow.
		</para>
		<para>
			So what we need is a top-level search flow and a person detail flow that we're going
			to embed in our top-level search flow.
		</para>
		<para>
			Configuring flows can be done in both Java and XML. You can use whatever you prefer
			and we're going to show you both ways in a minute. For more information
			about the different ways to configure your flows using flow builders, refer to other parts of the reference manual, where 
			the so-called <literal>XmlFlowBuilder</literal> and the <literal>AbstractFlowBuilder</literal>
			are explained in more detail.
		</para>
		<sect2>
			<title>Configuring the flow in XML</title>
			<para>
				Let's first configure the phonebook flow in XML. Spring Web Flow features 
				a dedicated XML format entirely developed to express web flows in.
				The file we're creating is called <literal>search.xml</literal> meaning
				our flow will later on be identified as <emphasis role="bold">search</emphasis>.
				First, we'll have to mention the DOCTYPE and start with identifying the
				start state of the flow. Remember: this is the initial state a flow will
				be in after it's been started.
			</para>
			<para>
<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE flow PUBLIC "-//SPRING//DTD WEBFLOW 1.0//EN"
	"http://www.springframework.org/dtd/spring-webflow-1.0.dtd">

<flow start-state="displayCriteria">

  <!-- our flow goes here -->

</flow>]]></programlisting>
			</para>
			<para>
				After we've defined the start state (<literal>displayCriteria</literal> in this case),
				we need to start adding other states. These states can be in any arbitrary order.
				In other words: the order in the XML file does not reflect the actual order
				or states in the flow since the states are identified by a unique <literal>id</literal>.
				Of course it's handy to keep them well-organized.
				The first state we're going to create is the start state. As we've seen in our
				state diagram, it's a view state and it's called <literal>displayCriteria</literal>.
				While defining the view state, we need to assign it an id. In this case,
				we're also assigning it a view identifier which in this specific case is
				resolved by a Spring MVC <literal>ViewResolver</literal>.
				The skeleton for our state is ready.
			</para>
			<para>
<programlisting><![CDATA[  <view-state id="displayCriteria" view="searchCriteria">

    <!-- the remainder of the state definition goes here -->

  </view-state>]]></programlisting>
			</para>
			<para>
				The next thing we need to do is identify actions assotiated to the state and
				transitions that will allow the flow to transition to a different state.
				Each state can have actions assigned to it that will execute just before the
				state is entered into, as well as exit actions, executed right before the flow
				transitions to another state. In this specific example, we're only using an
				entry action. The entry action is used set up the form the user will use
				to enter his search criteria in. More specifically, it calls a method on a 
				action object specifically designed for form operations that will
				set up the form backing object (i.e. the object the search criteria will
				be bound to later on).
			</para>
			<para>
				The action object by the way is identified by the <literal>bean</literal>
				attribute. This attribute reflects a <emphasis>Spring IoC bean identifier</emphasis>,
				meaning that this bean is a normal Spring-managed bean, defined elsewhere.
				When using Spring Web Flow you don't necessarily have to work with Spring IoC,
				but in this example we do. In other words, the bean identified by the 
				<literal>searchFormAction</literal> is a bean defined in a Spring ApplicationContext.
			</para>
			<para>
<programlisting><![CDATA[  <entry-actions>
    <action bean="searchFormAction" method="setupForm"/>
  </entry-actions>]]></programlisting>
			</para>
			<para>
				The last thing we need to do in order to get our first state working is
				to add one or more transitions that allow the flow to transition to a different
				state. The only thing a user can do in this case really, is submit the form.
				So we add a transition that will fire when the <literal>search</literal> event
				is being signaled by the user (we'll see later on how to actually signal events
				to flows). When a different event is signaled, an exception will be raised.
				In this case, if the <literal>search</literal> event is signaled, the flow
				will transition to the <literal>executeSearch</literal> state 
				<emphasis>if and only if</emphasis> the embedded action succeeds
				(more on how Web Flow decides whether or not to actually execute transitions
				can be found in other chapters of this reference manual).
				So in this case, if the <literal>bindAndValidate</literal> method succeeds
				(meaning binding to the form object and validation of the form object succeeds)
				the transition will take place. In all other cases the transition
				<emphasis>won't</emphasis> take place and the flow will stick in its current
				state (causing the view to be re-rendered).
			</para>
			<para>
<programlisting><![CDATA[    <transition on="search" to="executeSearch">
      <action bean="searchFormAction" method="bindAndValidate"/>
    </transition>]]></programlisting>
    		</para>
    		<para>
    			The first state is done. We've gone through the entire process of creating
    			a state, assigning it with an <literal>id</literal>, associating an
    			entry action and a transition, along with a criteria for the transition to
    			happen (or not). The next thing we need to do is provide the next state in the
    			flow. The previous state allowed for a user to enter some criteria and submit them.
    			Binding and validation will occur and depending on the result of this process
    			(successful or unsuccessful) the transition will be executed. Let's not
    			bother with the actual process of binding and validation for now. This is something
    			we'll explain later. Just imagine it automagically happens.
    		</para>
			<para>
				Together with the view, the view state will result in the following screen
				being available (with the screen showing a validation error in this case,
				indicating the user hasn't entered any criteria).
			</para>
			<para>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/phonebook-screen-1.jpg" format="JPEG" align="center"/>
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/phonebook-screen-1.jpg" format="JPEG" align="center"/>
					</imageobject>
					<caption>
						<para>Validation errors while entering criteria</para>
					</caption>
				</mediaobject>
			</para>
    		<para>
    			After validation has succeeded, the next state in our flow is the execution
    			of the search, based on the search criteria the user has passed in. We can
    			derive this from the <literal>to</literal>-attribute of the transition associated
    			to the first state we've jotted down.
    			Execution
    			of logic on the server, comprised in a separate step, is implemented using an
    			<emphasis>action state</emphasis>. An action state is not very different from
    			a view state; the difference being that an action state does not have a view
    			associated with it. Instead it has a nested action that will execute. In other
    			words, where the view state interacts with the user, the action executes logic
    			on the server. In the phonebook example, the action state executes the actual
    			search, based on criteria the user has given.
    		</para>
			<para><programlisting><![CDATA[  <action-state id="executeSearch">

    <!-- actions go here -->

  </action-state>]]></programlisting>
			</para>
			<para>
				The action is again identified by a Spring bean identifier, hence defined in 
				a Spring ApplicationContext.
			</para>
			<para><programlisting><![CDATA[    <action bean="phonebook" method="search({flowScope.searchCriteria})" resultName="results"/>]]></programlisting></para>
			<para>
				The actual action in this case is the calling of a
				method called <literal>search</literal> with one parameter. This parameter is
				the form object, which will talk about later when implementing the
				Java classes needed for the phonebook application. All you need to know right now
				is the signature of the method:
			</para>
			<para>
				<programlisting><![CDATA[public List search(SearchCriteria c);]]></programlisting>
			</para>
			<para>
				The result of the method is automatically bound in the context of the flow,
				meaning that views rendered after this state will have access to it
				(if for example the application uses JSP, you can access the List returned by
				the <literal>search</literal> by using EL: <literal>${results}</literal>).
			</para>
			<para>
				If the execution of the <literal>search</literal> method is successful
				(in other words: no exception has been raised), the flow transitions to the
				next state. Why? Because together with the action (inside the action-state)
				we're also mentioning a transition that says for every event called
				<literal>success</literal> we should go to the <literal>displayResults</literal>
				state.
			</para>
			<para>
				<programlisting><![CDATA[    <transition on="success" to="displayResults"/>]]></programlisting>
			</para>
			<para>
				As we've said, the next state is the <literal>displayResults</literal> state.
				This is another view state, with this time, the <literal>searchResults</literal>
				view resource associated to it, as well as a different transition to the next state.
				Remember that transitions are signaled by events and since this is a view state,
				the user will interact with the system. By signaling a <literal>select</literal>
				event, the flow will transition to the next state (browsing user details).
			</para>
			<para>
				<programlisting><![CDATA[  <view-state id="displayResults" view="searchResults">
    <transition on="newSearch" to="displayCriteria"/>
    <transition on="select" to="browseDetails"/>
  </view-state>]]></programlisting>
			</para>
    	</sect2>
    </sect1>
</chapter>