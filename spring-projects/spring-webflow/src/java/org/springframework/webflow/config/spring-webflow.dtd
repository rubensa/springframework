<?xml version="1.0" encoding="UTF-8"?>

<!--
	Spring Web Flow 1.0 DTD
	Authors: Erwin Vervaet, Keith Donald
	
	This DTD defines the Spring Web Flow (SWF) XML syntax.
	
	The root "flow" element of this document defines exactly one Flow definition.
    A Flow definition is a blueprint for an executable, single-user process
	(or conversation).
	
	A flow is composed of one or more states (or steps).  Each state executes 
	behavior when entered.  What behavior is executed is a function of the
	state's type.  Core state types include view states, action states,
	subflow states, decision states, and end states.
    
    Each flow definition must specify exactly one start state and at least one end state.
    Events that occur in transitionable states drive state transitions.
    
	XML documents that conform to this DTD should declare the following doctype:

	<!DOCTYPE flow PUBLIC "-//SPRING//DTD WEBFLOW 1.0//EN"
		"http://www.springframework.org/dtd/spring-webflow.dtd">
-->

<!--
	Defines a exactly one flow definition.  A flow is composed of one or more states.  A flow may
	be annotated with properties and may be configured to handle state exceptions.  A flow may also
	define one or more local bean definitions defining custom related services.
-->
<!ELEMENT flow ( property*, ( action-state | view-state | decision-state | subflow-state | end-state )+, exception-handler*, bean* )>

<!--
	The identifier for this flow; this identifier should be descriptive and unique to all other flows.
-->
<!ATTLIST flow id ID #REQUIRED>

<!--
	The the start state of this flow; the start state is the point where flow execution will begin.
-->
<!ATTLIST flow start-state IDREF #REQUIRED>

<!--
	Defines an action state, a state where one or more Actions (command objects) are executed.
	An action state is a transitionable state.  An action state transition is triggered by an
	action result event.
-->
<!ELEMENT action-state ( property*, entry-action?, action+, transition+, exit-action?, exception-handler* )>

<!--
	The unique identifier of this action state; must be unique to this flow.
-->
<!ATTLIST action-state id ID #REQUIRED>

<!--
	Defines a single action to be executed in this state.  An action is a command that executes
	arbitrary state behavior.  An action may be annotated with properties.  These properties can be
	used to effect the action's	execution in this state.
-->
<!ELEMENT action ( property* )>

<!--
	The logical identifier of the action implementation to execute, typically a index into
	a service registry like a Spring Bean Factory.  This is similar to the <ref bean="myBean"/>
	notation of	the Spring beans DTD.
-->
<!ATTLIST action bean CDATA #IMPLIED>

<!--
	An optional name qualifier for this action. When specified this action will
	qualify execution result event ids by this name.  For example, if this action is
	named "processOrder" and signals a "success" result event after execution, the
	fully qualified result event the flow can respond to would be "processOrder.success".
	
	An action with a name is often referred to as a "named action".
-->
<!ATTLIST action name CDATA #IMPLIED>

<!--
	The name of the target method to invoke to execute this action, allowing for
	action method binding.
	
	If this action extends MultiAction, the method's signature must
	be of the form: 'public Event <method>(RequestContext) throws Exception'

    For example:
        method="setupForm"
        	
	If this action is an abritrary bean (POJO), the method's signature can 
	match any public method on the bean's implementation.  In this case the
	method format is as follows: <method>(${arg1}, ${arg n}) where any 
	${argument expression}s are evaluated against this flow's RequestContext.

	For example:
        method="processOrder(${flowScope.order})"	
	
-->
<!ATTLIST action method CDATA #IMPLIED>

<!--
	Defines a transition from one state to another.
	
	A transitions defines a supported paths through the flow.
	A transitions may be annotated with properties and may specify one or more
	actions to execute before executing.
-->
<!ELEMENT transition ( property*, action* )>

<!--
	The criteria that matches this transition's execution, typically reasoning on the
	last event that occured in an execution of this flow to determine if this transition 
	should execute.
	
	The most basic value is a static event id.  For example:
  	    on="success"
	
	Sophisticated, custom transitional expressions are also supported.  For example:
	    on="${#result == 'submit' && flowScope.attribute == 'foo'}"
  	    on="bean:myCustomCriteria"
	
	The exact interpretation of the attribute value depends on the TextToTransitionCriteria
	converter that is installed.
-->
<!ATTLIST transition on CDATA #REQUIRED>

<!--
	The target state of this transition.
-->
<!ATTLIST transition to IDREF #REQUIRED>

<!--
	Defines a view state, a state where a view will be selected for rendering and control will be 
	returned to the user.

	A view state is a transitionable state.  A view state transition is triggered by an
	user input event.
-->
<!ELEMENT view-state ( property*, entry-action?, transition+, exit-action?, exception-handler* )>

<!--
	The unique identifier of this view state; must be unique to this flow.
-->
<!ATTLIST view-state id ID #REQUIRED>

<!--
	The name of the view to to render when this view state is entered.
	
	This value may be a static view name or even a direct pointer to a view template.  For example:
	    "priceForm", or "/WEB-INF/jsp/priceForm.jsp"
	
	This value may also be qualified with a prefix to denote a specific (possibly custom)
	ViewSelector strategy.  Specifically:
	
	Use of the "redirect:" prefix triggers creation of a RedirectViewSelector which will request
	a redirect to a specific URL.  For example:
	    "redirect:/home.html"
	
	Redirect query parameters may also be specified using ${expressions} that evaluate against
	the request context.  For example:
	    "redirect:/thankyou.htm?confirmationNumber=${flowScope.order.confirmation.id}"
	
	Use of the "bean:" prefix will plug in the custom ViewSelector implementation with that bean id:
	    "bean:myCustomViewSelector"

	The exact semantics regarding the interpretation of this value are determined by the
	installed TextToViewSelector converter.

	Note when no view name is provided, this view state will act as a marker state. A marker
	view state does not request the rendering of a view, it only pauses the flow and returns control 
	the client. Use a marker view state when another state is expected to generate the response.
-->
<!ATTLIST view-state view CDATA #IMPLIED>

<!--
	Defines state entry logic to be executed.  This logic will always execute when this state is entered.
-->
<!ELEMENT entry-action ( action+ )>

<!--
	Defines state exit logic to be executed.  This logic will always execute when this state is exited 
	regardless of what transition is executed.
-->
<!ELEMENT exit-action ( action+ )>

<!--
	Defines a decision state, a state that evaluates one or more expressions to	decide which
	state to go to next.  Also referred to as a "routing" state.
	
	A decision state is a transitionable state.  A decision state transition is triggered by an
	boolean expression evaluating true against the flow execution request context.
-->
<!ELEMENT decision-state ( property*, entry-action?, if+, exit-action?, exception-handler* )>

<!--
	The unique identifier of this decision state; must be unique to this flow.
-->
<!ATTLIST decision-state id ID #REQUIRED>

<!--
	A transition specification that defines a criteria expression and a state to
	transition to if that expression is true.  Optionally, this element may also define
	an 'else' attribute to note the state to transition to if the expression is false.
	The form is:
	    <if test="${criteria}" then="<trueStateId>" else="<falseStateId>"/>
-->
<!ELEMENT if EMPTY>

<!--
	The transition criteria expression to be tested.  This should be a ${expression} that
	evaluates against this flow's crequest context.  For example:
	    <if test="${flowScope.sale.shipping} then="enterShippingDetails"/>
-->
<!ATTLIST if test CDATA #REQUIRED>

<!--
	The state to transition to if the criteria expression is true.
-->
<!ATTLIST if then IDREF #REQUIRED>

<!--
	The state to transition to if the criteria expression is false (optional).
-->
<!ATTLIST if else IDREF #IMPLIED>

<!--
	Defines a sub flow state, a state that spawns a sub flow when entered.

	A subflow state is a transitionable state.  A subflow state transition is triggered by a 
	subflow result event, typically by reasoning on the id of the subflow end state that was reached.
	
	While the subflow is active, this flow is suspended waiting for the subflow to complete execution.
	When the sub flow completes execution by reaching an end state, this state is expected 
	to respond to the result of that execution.  The result of subflow execution, the end state 
	that was reached, should be used as grounds for a transition out of this state.
-->
<!ELEMENT subflow-state ( property*, entry-action?, attribute-mapper?, transition+, exit-action?, exception-handler* )>

<!--
	The unique identifier of this subflow state; must be unique to this flow.
-->
<!ATTLIST subflow-state id ID #REQUIRED>

<!--
	The id of the flow to be spawned as a subflow when this subflow state is entered.
-->
<!ATTLIST subflow-state flow CDATA #REQUIRED>

<!--
	An optional mapper that will map attributes from the parent flow to/from the spawned subflow. 
-->
<!ELEMENT attribute-mapper ( input*, output* )>

<!--
	The identifier of a custom flow attribute mapper implementation exported in the
	configured registry, typically a Spring Bean Factory. This is similar
	to the <ref bean="myBean"/> notation of the Spring beans DTD.
	
	Use this as an alternative to the convenient "input" and "output" element attributes 
	when you need full control of attribute mapping behavior for this subflow state.
-->
<!ATTLIST attribute-mapper bean CDATA #IMPLIED>

<!--
	A single input mapping that maps an attribute from this flow to the subflow.
-->
<!ELEMENT input EMPTY>

<!--
	The name of a attribute in this flow to map as input into the spawning the subflow.

	If the 'as' attribute is not specified, the mapped attribute will be assigned 
	the same name in the subflow.

	If the 'as' attribute is specified, the mapped attribute will be assigned the name specified 
	in the subflow.
	
	Use this or the value attribute, not both.
-->
<!ATTLIST input name CDATA #IMPLIED>

<!--
	A value expression evaluated against this flow's request context.
	The evaluated expression value is what is mapped as an input attribute into the spawning subflow.
	
	Note: you must specify the 'as' attribute to assign the expression value an attribute name 
	in the subflow.
	
	Use this or the name attribute, not both.
-->
<!ATTLIST input value CDATA #IMPLIED>

<!--
	The name of the target attribute in the subflow. This is optional when used in
	conjunction with the 'name' attribute; by default, the same attribute name will be
	used between this flow and the subflow.
	
	Note: this is required when used in conjunction with the 'value' attribute: you must
	assign a name to the value returned by the expression for storage in the subflow.
-->
<!ATTLIST input as CDATA #IMPLIED>

<!--
	The type of the source attribute value in this flow; used with the "to" attribute to perform
	a value type conversion during attribute mapping.
-->
<!ATTLIST input from CDATA #IMPLIED>

<!--
	The target type of the subflow attribute value; used with the "from" attribute to perform
	a value type conversion during attribute mapping.
-->
<!ATTLIST input to CDATA #IMPLIED>

<!--
	A single output mapping that maps data from the subflow to this flow when the subflow ends and 
	this flow resumes.
-->
<!ELEMENT output EMPTY>

<!--
	The name of an attribute in the ending subflow to map up into this resuming flow.
	
	If the 'as' attribute is not specified, the mapped attribute will be assigned
	the same name in this flow.
	
	If the 'as' attribute is specified, the mapped attribute will be assigned the name specified 
	in this flow.
	
	Use this or the value attribute, not both.
-->
<!ATTLIST output name CDATA #IMPLIED>

<!--
	A value expression evaluated against the subflow's request context.
	The evaluated expression value is what is mapped as output up to this resuming flow.
	
	Note: you must specify the 'as' attribute to assign the expression value a attribute name 
	in this flow.
	
	Use this or the name attribute, not both.
-->
<!ATTLIST output value CDATA #IMPLIED>

<!--
	The name of the target attribute in this flow. This is optional when used in
	conjunction with the 'name' attribute; by default, the same name will be used between
	the subflow and this flow.

	Note: this is required when used in conjunction with the 'value' attribute: you must
	assign a name to the value returned by the expression for storage in this flow.
-->
<!ATTLIST output as CDATA #IMPLIED>

<!--
	The type of the attribute to map from the subflow; used with the "to" attribute to perform
	a value type conversion during attribute mapping.
-->
<!ATTLIST output from CDATA #IMPLIED>

<!--
	The type of the target attribute to set in this flow; used with the "from" attribute to perform
	a value type conversion during attribute mapping.
-->
<!ATTLIST output to CDATA #IMPLIED>

<!--
	Defines an end state, a state that terminates this flow when entered.
	
	A end state is not transitionable, there are no transitions out of an end state.
	When an end-state is entered, a instance of this flow is terminated.
	
	Every flow must define at least one end-state.  When an end state is entered, if the executing
	flow is a "root flow" the entire execution (conversation) is terminated.  If the executing flow
	is a "subflow" the subflow session ends and the parent session resumes.  To resume, the parent
	session responds to the result of the subflow, typically by reasoning on the id of the 
	end state that was reached.
-->
<!ELEMENT end-state ( property*, entry-action?, exception-handler* )>

<!--
	The unique identifier of this end state; must be unique to this flow.
-->
<!ATTLIST end-state id ID #REQUIRED>

<!--
	The name of the view to to render when this end state is entered.
	
	This value may be a static view name or even a direct pointer to a view template.  For example:
	    "priceForm", or "/WEB-INF/jsp/priceForm.jsp"
	
	This value may also be qualified with a prefix to denote a specific (possibly custom)
	ViewSelector strategy.  Specifically:
	
	Use of the "redirect:" prefix triggers creation of a RedirectViewSelector which will request
	a redirect to a specific URL.  For example:
	    "redirect:/home.html"
	
	Redirect query parameters may also be specified using ${expressions} that evaluate against
	the request context.  For example:
	    "redirect:/thankyou.htm?confirmationNumber=${flowScope.order.confirmation.id}"
	
	Use of the "bean:" prefix will plug in the custom ViewSelector implementation with that bean id.

	The exact semantics regarding the interpretation of this value are determined by the
	installed TextToViewSelector converter.

	Note when no view name is provided, this end state will act as a marker state. A marker
	end state does not request the rendering of a view, it only terminates the flow and returns control 
	the client. Use a marker end state when another state is expected to generate the response.
-->
<!ATTLIST end-state view CDATA #IMPLIED>

<!--
	Defines a state exception handler to handle one or more exceptions that may occur during the
	execution of this flow definition.  Exception handles may be attached at the state or flow level.
-->
<!ELEMENT exception-handler EMPTY>

<!--
	The class of exception that may occur that you wish to handle.
-->
<!ATTLIST exception-handler on CDATA #IMPLIED>

<!--
	The id of the state to transition to when this class of exception does occur.
-->
<!ATTLIST exception-handler to IDREF #IMPLIED>

<!--
	The id of a custom exception handler implementation to attach.  Specify this attribute or 
	the class and state attributes, not both.
-->
<!ATTLIST exception-handler bean CDATA #IMPLIED>

<!--
	Defines a single (usually named) bean associated with this flow definition.  Typically used to
	configure instances of services local to this flow, like an Action, ViewSelector,
	TransitionCriteria,	or FlowAttributeMapper.
	
	A flow bean definition may reference any other bean defined in this file, as well as 
	beans managed in the registry associated with the builder that constructed this flow.

	A bean definition may contain nested tags for constructor arguments,
	property values, lookup methods, and replaced methods. Mixing constructor
	injection and setter injection on the same bean is explicitly supported.
-->
<!ELEMENT bean (
	description?,
	(constructor-arg | property | lookup-method | replaced-method)*
)>

<!--
	Beans can be identified by an id, to enable reference checking.

	There are constraints on a valid XML id: if you want to reference your bean
	in Java code using a name that's illegal as an XML id, use the optional
	"name" attribute. If neither is given, the bean class name is used as id
	(with an appended counter like "#2" if there is already a bean with that name).
-->
<!ATTLIST bean id ID #IMPLIED>

<!--
	Optional. Can be used to create one or more aliases illegal in an id.
	Multiple aliases can be separated by any number of spaces or commas.
-->
<!ATTLIST bean name CDATA #IMPLIED>

<!--
	Each bean definition must specify the fully qualified name of the class,
	except if it pure serves as parent for child bean definitions.
-->
<!ATTLIST bean class CDATA #IMPLIED>

<!--
	Optionally specify a parent bean definition.

	Will use the bean class of the parent if none specified, but can
	also override it. In the latter case, the child bean class must be
	compatible with the parent, i.e. accept the parent's property values
	and constructor argument values, if any.

	A child bean definition will inherit constructor argument values,
	property values and method overrides from the parent, with the option
	to add new values. If init method, destroy method, factory bean and/or factory
	method are specified, they will override the corresponding parent settings.

	The remaining settings will always be taken from the child definition:
	depends on, autowire mode, dependency check, singleton, lazy init.
-->
<!ATTLIST bean parent CDATA #IMPLIED>

<!--
	Is this bean "abstract", i.e. not meant to be instantiated itself but
	rather just serving as parent for concrete child bean definitions.
	Default is "false". Specify "true" to tell the bean factory to not try to
	instantiate that particular bean in any case.
-->
<!ATTLIST bean abstract (true | false) "false">

<!--
	Is this bean a "singleton" (one shared instance, which will
	be returned by all calls to getBean() with the id),
	or a "prototype" (independent instance resulting from each call to
	getBean(). Default is singleton.

	Singletons are most commonly used, and are ideal for multi-threaded
	service objects.
-->
<!ATTLIST bean singleton (true | false) "true">

<!--
	If this bean should be lazily initialized.
	If false, it will get instantiated on startup by bean factories
	that perform eager initialization of singletons.
-->
<!ATTLIST bean lazy-init (true | false | default) "default">

<!--
	Optional attribute controlling whether to "autowire" bean properties.
	This is an automagical process in which bean references don't need to be coded
	explicitly in the XML bean definition file, but Spring works out dependencies.

	There are 5 modes:

	1. "no"
	The traditional Spring default. No automagical wiring. Bean references
	must be defined in the XML file via the <ref> element. We recommend this
	in most cases as it makes documentation more explicit.

	2. "byName"
	Autowiring by property name. If a bean of class Cat exposes a dog property,
	Spring will try to set this to the value of the bean "dog" in the current factory.
	If there is no matching bean by name, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	3. "byType"
	Autowiring if there is exactly one bean of the property type in the bean factory.
	If there is more than one, a fatal error is raised, and you can't use byType
	autowiring for that bean. If there is none, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	4. "constructor"
	Analogous to "byType" for constructor arguments. If there isn't exactly one bean
	of the constructor argument type in the bean factory, a fatal error is raised.

	5. "autodetect"
	Chooses "constructor" or "byType" through introspection of the bean class.
	If a default constructor is found, "byType" gets applied.

	The latter two are similar to PicoContainer and make bean factories simple to
	configure for small namespaces, but doesn't work as well as standard Spring
	behaviour for bigger applications.

	Note that explicit dependencies, i.e. "property" and "constructor-arg" elements,
	always override autowiring. Autowire behaviour can be combined with dependency
	checking, which will be performed after all autowiring has been completed.
-->
<!ATTLIST bean autowire (no | byName | byType | constructor | autodetect | default) "default">

<!--
	Optional attribute controlling whether to check whether all this
	beans dependencies, expressed in its properties, are satisfied.
	Default is no dependency checking.

	"simple" type dependency checking includes primitives and String
	"object" includes collaborators (other beans in the factory)
	"all" includes both types of dependency checking
-->
<!ATTLIST bean dependency-check (none | objects | simple | all | default) "default">

<!--
	The names of the beans that this bean depends on being initialized.
	The bean factory will guarantee that these beans get initialized before.

	Note that dependencies are normally expressed through bean properties or
	constructor arguments. This property should just be necessary for other kinds
	of dependencies like statics (*ugh*) or database preparation on startup.
-->
<!ATTLIST bean depends-on CDATA #IMPLIED>

<!--
	Optional attribute for the name of the custom initialization method
	to invoke after setting bean properties. The method must have no arguments,
	but may throw any exception.
-->
<!ATTLIST bean init-method CDATA #IMPLIED>

<!--
	Optional attribute for the name of the custom destroy method to invoke
	on bean factory shutdown. The method must have no arguments,
	but may throw any exception. Note: Only invoked on singleton beans!
-->
<!ATTLIST bean destroy-method CDATA #IMPLIED>

<!--
	Optional attribute specifying the name of a factory method to use to
	create this object. Use constructor-arg elements to specify arguments
	to the factory method, if it takes arguments. Autowiring does not apply
	to factory methods.

	If the "class" attribute is present, the factory method will be a static
	method on the class specified by the "class" attribute on this bean
	definition. Often this will be the same class as that of the constructed
	object - for example, when the factory method is used as an alternative
	to a constructor. However, it may be on a different class. In that case,
	the created object will *not* be of the class specified in the "class"
	attribute. This is analogous to FactoryBean behavior.

	If the "factory-bean" attribute is present, the "class" attribute is not
	used, and the factory method will be an instance method on the object
	returned from a getBean call with the specified bean name. The factory
	bean may be defined as a singleton or a prototype.

	The factory method can have any number of arguments. Autowiring is not
	supported. Use indexed constructor-arg elements in conjunction with the
	factory-method attribute.

	Setter Injection can be used in conjunction with a factory method.
	Method Injection cannot, as the factory method returns an instance,
	which will be used when the container creates the bean.
-->
<!ATTLIST bean factory-method CDATA #IMPLIED>

<!--
	Alternative to class attribute for factory-method usage.
	If this is specified, no class attribute should be used.
	This should be set to the name of a bean in the current or
	ancestor factories that contains the relevant factory method.
	This allows the factory itself to be configured using Dependency
	Injection, and an instance (rather than static) method to be used.
-->
<!ATTLIST bean factory-bean CDATA #IMPLIED>


<!--
	Bean definitions can specify zero or more constructor arguments.
	This is an alternative to "autowire constructor".
	Arguments correspond to either a specific index of the constructor argument
	list or are supposed to be matched generically by type.

	Note: A single generic argument value will just be used once, rather than
	potentially matched multiple times (as of Spring 1.1).

	constructor-arg elements are also used in conjunction with the factory-method
	element to construct beans using static or instance factory methods.
-->
<!ELEMENT constructor-arg (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	The constructor-arg tag can have an optional index attribute,
	to specify the exact index in the constructor argument list. Only needed
	to avoid ambiguities, e.g. in case of 2 arguments of the same type.
-->
<!ATTLIST constructor-arg index CDATA #IMPLIED>

<!--
	The constructor-arg tag can have an optional type attribute,
	to specify the exact type of the constructor argument. Only needed
	to avoid ambiguities, e.g. in case of 2 single argument constructors
	that can both be converted from a String.
-->
<!ATTLIST constructor-arg type CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST constructor-arg ref CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "value".
-->
<!ATTLIST constructor-arg value CDATA #IMPLIED>


<!--
	A property associated with an another element (action, state, ...). Properties are simple
	strings or typed information that allow you to annotate the element.
	For example, the 'caption' property might serve a GUI tooltip or logging statement, and
	the 'validatorMethod' property might specify a target method to invoke on a form action's
	validator in a particular action state.

	Bean definitions can have also zero or more properties.
	Property elements correspond to JavaBean setter methods exposed
	by the bean classes. Spring supports primitives, references to other
	beans in the same or related factories, lists, maps and properties.
-->
<!ELEMENT property (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	The property name attribute is the name of the JavaBean property.
	This follows JavaBean conventions: a name of "age" would correspond
	to setAge()/optional getAge() methods.
-->
<!ATTLIST property name CDATA #REQUIRED>

<!--
	The target type of the property value; to facilitate from-string type conversion. This type
	string may be an alias (e.g 'int') or a fully-qualified class (e.g. 'java.lang.Integer').
-->
<!ATTLIST property type CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST property ref CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "value".
-->
<!ATTLIST property value CDATA #IMPLIED>

<!--
	A lookup method causes the IoC container to override the given method and return
	the bean with the name given in the bean attribute. This is a form of Method Injection.
	It's particularly useful as an alternative to implementing the BeanFactoryAware
	interface, in order to be able to make getBean() calls for non-singleton instances
	at runtime. In this case, Method Injection is a less invasive alternative.
-->
<!ELEMENT lookup-method EMPTY>

<!--
	Name of a lookup method. This method should take no arguments.
-->
<!ATTLIST lookup-method name CDATA #IMPLIED>

<!--
	Name of the bean in the current or ancestor factories that the lookup method
	should resolve to. Often this bean will be a prototype, in which case the
	lookup method will return a distinct instance on every invocation. This
	is useful for single-threaded objects.
-->
<!ATTLIST lookup-method bean CDATA #IMPLIED>


<!--
	Similar to the lookup method mechanism, the replaced-method element is used to control
	IoC container method overriding: Method Injection. This mechanism allows the overriding
	of a method with arbitrary code. 
-->
<!ELEMENT replaced-method (
	(arg-type)*
)>

<!--
	Name of the method whose implementation should be replaced by the IoC container.
	If this method is not overloaded, there's no need to use arg-type subelements.
	If this method is overloaded, arg-type subelements must be used for all 
	override definitions for the method.
-->
<!ATTLIST replaced-method name CDATA #IMPLIED>

<!--
	Bean name of an implementation of the MethodReplacer interface
	in the current or ancestor factories. This may be a singleton or prototype
	bean. If it's a prototype, a new instance will be used for each method replacement.
	Singleton usage is the norm.
-->
<!ATTLIST replaced-method replacer CDATA #IMPLIED>

<!--
	Subelement of replaced-method identifying an argument for a replaced method
	in the event of method overloading.
-->
<!ELEMENT arg-type (#PCDATA)>

<!--
	Specification of the type of an overloaded method argument as a String. 
	For convenience, this may be a substring of the FQN. E.g. all the
	following would match "java.lang.String":
	- java.lang.String
	- String
	- Str
	
	As the number of arguments will be checked also, this convenience can often
	be used to save typing.
-->
<!ATTLIST arg-type match CDATA #IMPLIED>


<!--
	Defines a reference to another bean in this factory or an external
	factory (parent or included factory).
-->
<!ELEMENT ref EMPTY>

<!--
	References must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	to be checked at runtime.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
-->
<!ATTLIST ref bean CDATA #IMPLIED>
<!ATTLIST ref local IDREF #IMPLIED>
<!ATTLIST ref parent CDATA #IMPLIED>


<!--
	Defines a string property value, which must also be the id of another
	bean in this factory or an external factory (parent or included factory).
	While a regular 'value' element could instead be used for the same effect,
	using idref in this case allows validation of local bean ids by the xml
	parser, and name completion by helper tools.
-->
<!ELEMENT idref EMPTY>

<!--
	ID refs must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	potentially to be checked at runtime by bean factory implementations.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
-->
<!ATTLIST idref bean CDATA #IMPLIED>
<!ATTLIST idref local IDREF #IMPLIED>


<!--
	Contains a string representation of a property value.
	The property may be a string, or may be converted to the
	required type using the JavaBeans PropertyEditor
	machinery. This makes it possible for application developers
	to write custom PropertyEditor implementations that can
	convert strings to objects.

	Note that this is recommended for simple objects only.
	Configure more complex objects by populating JavaBean
	properties with references to other beans.
-->
<!ELEMENT value (#PCDATA)>

<!--
	The value tag can have an optional type attribute, to specify the
	exact type that the value should be converted to. Only needed
	if the type of the target property or constructor argument is
	too generic: for example, in case of a collection element.
-->
<!ATTLIST value type CDATA #IMPLIED>

<!--
	Denotes a Java null value. Necessary because an empty "value" tag
	will resolve to an empty String, which will not be resolved to a
	null value unless a special PropertyEditor does so.
-->
<!ELEMENT null (#PCDATA)>


<!--
	A list can contain multiple inner bean, ref, collection, or value elements.
	Java lists are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
	A list can also map to an array type. The necessary conversion
	is automatically performed by the BeanFactory.
-->
<!ELEMENT list (
	(bean | ref | idref | value | null | list | set | map | props)*
)>

<!--
	A set can contain multiple inner bean, ref, collection, or value elements.
	Java sets are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
-->
<!ELEMENT set (
	(bean | ref | idref | value | null | list | set | map | props)*
)>


<!--
	A Spring map is a mapping from a string key to object.
	Maps may be empty.
-->
<!ELEMENT map (
	(entry)*
)>

<!--
	A map entry can be an inner bean, ref, value, or collection.
	The key of the entry is given by the "key" attribute or child element.
-->
<!ELEMENT entry (
  key?,
	(bean | ref | idref | value | null | list | set | map | props)?
)>

<!--
	Each map element must specify its key as attribute or as child element.
	A key attribute is always a String value.
-->
<!ATTLIST entry key CDATA #IMPLIED>

<!--
  A short-cut alternative to a "key" element with a "ref bean=" child element.
-->
<!ATTLIST entry key-ref CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "value".
-->
<!ATTLIST entry value CDATA #IMPLIED>

<!--
  A short-cut alternative to a child element "ref bean=".
-->
<!ATTLIST entry value-ref CDATA #IMPLIED>

<!--
	A key element can contain an inner bean, ref, value, or collection.
-->
<!ELEMENT key (
	(bean | ref | idref | value | null | list | set | map | props)
)>


<!--
	Props elements differ from map elements in that values must be strings.
	Props may be empty.
-->
<!ELEMENT props (
	(prop)*
)>

<!--
	Element content is the string value of the property.
	Note that whitespace is trimmed off to avoid unwanted whitespace
	caused by typical XML formatting.
-->
<!ELEMENT prop (#PCDATA)>

<!--
	Each property element must specify its key.
-->
<!ATTLIST prop key CDATA #REQUIRED>