/*
 * Copyright 2002-2005 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.webflow.execution;

import java.io.Serializable;

import org.springframework.webflow.Event;

/**
 * Storage strategy for flow executions. A flow execution manager uses
 * this interface to load and save flow executions.
 * <p>
 * Note that the flow execution storage strategy can have an impact
 * on application transaction management for a flow execution. For instance,
 * the default application transaction synchronization implementation
 * ({@link org.springframework.webflow.execution.FlowScopeTokenTransactionSynchronizer})
 * uses a simple <i>synchronizer token</i> stored in the flow scope, which
 * implies that there is a single flow execution for an application transaction.
 * Some flow execution storage strategies (like
 * {@link org.springframework.webflow.execution.ClientContinuationFlowExecutionStorage})
 * create copies (clones) of a flow execution to enable <i>free browsing</i>
 * in a flow. Those strategies are not compatible with the default application
 * transaction implementation. Usually this is not a problem since free browing
 * is not really compatible with any kind of transactional semantics. If required,
 * you can always plug in another transaction synchronizer, e.g. one that stores
 * a transaction token in the database, no longer requiring a single
 * flow execution per application transaction.
 * 
 * @see org.springframework.webflow.execution.FlowExecutionManager
 * @see org.springframework.webflow.execution.FlowExecution
 * 
 * @author Erwin Vervaet
 * @author Keith Donald
 * @author Colin Sampaleanu
 */
public interface FlowExecutionStorage {

	/**
	 * Load an existing flow execution, identified by given unique id, from
	 * the storage.
	 * @param id the unique id of the flow execution, as returned by the
	 *        {@link #save(Serializable, FlowExecution, Event) save} method
	 *        or {@link #generateId(Serializable) method
	 * @param sourceEvent the event requesting the load of the flow execution
	 * @return the loaded flow execution
	 * @throws NoSuchFlowExecutionException when there is no flow execution
	 *         with specified id in the storage
	 * @throws FlowExecutionStorageException when there is a technical problem
	 *         accessing the flow execution storage
	 */
	public FlowExecution load(Serializable id, Event sourceEvent) throws NoSuchFlowExecutionException,
			FlowExecutionStorageException;

	/**
	 * Save given flow execution in the storage.
	 * @param id the unique id of the flow execution, or <code>null</code>
	 *        if the flow execution does not yet have an id (e.g. was not
	 *        previously saved)
	 * @param sourceEvent the event requesting the save of the flow execution
	 * @param flowExecution the flow execution to save
	 * @return the unique id that actually identifies the saved flow execution,
	 *         this could be different from the id passed into the method
	 * @throws FlowExecutionStorageException when there is a technical problem
	 *         accessing the flow execution storage
	 */
	public Serializable save(Serializable id, FlowExecution flowExecution, Event sourceEvent)
			throws FlowExecutionStorageException;
    
    /**
     * Allows storage to be queried as to whether it supports pre-generation of storage
     * IDs, before the save step
     * @return true if the storage supports two step saves (an id may be generated by
     * calling {@link #generateId(Serializable), followed by a subsequent call to 
     * {@link #saveAtId(Serializable, FlowExecution, Event), or false if only a one-step
     * save is supported, via a call to {@link #save(Serializable, FlowExecution, Event)
     */
	public boolean supportsIdPreGeneration();
	
	/**
	 * Generates (or reuses) a flow execution id for subsequent saving of
	 * flow state in this storage.
	 * @param oldId the unique id of the flow execution, or <code>null</code>
	 *        if the flow execution does not yet have an id (e.g. was not
	 *        previously saved)
	 * @return the unique id that actually identifies the saved flow execution,
	 *         this could be different from the id passed into the method
	 * @throws UnsupportedOperationException when this storage does not support
	 *         generation of storage ids as a separate step from saving of flows
	 *         to the storage
	 * @throws FlowExecutionStorageException when there is a technical problem
	 *         accessing the flow execution storage
	 */
    public Serializable generateId(Serializable oldId)
    		throws UnsupportedOperationException, FlowExecutionStorageException;;
	
	/**
	 * Save given flow execution in the storage, using the previously generated
	 * storage id
	 * @param id the unique id of the flow execution, as returned by the
	 *        {@link #save(Serializable, FlowExecution, Event) save} method
	 *        or {@link #generateId(Serializable) method
	 * @throws UnsupportedOperationException when this storage does not support
	 *         generation of storage ids as a separate step from saving of flows
	 *         to the storage
	 * @throws FlowExecutionStorageException
	 */
	public void saveAtId(Serializable id, FlowExecution flowExecution, Event sourceEvent)
			throws UnsupportedOperationException, FlowExecutionStorageException;;
    
	/**
	 * Remove the identified flow execution from the storage.
	 * @param id the unique id of the flow execution, as returned by the
	 *        {@link #save(Serializable, FlowExecution, Event) save} method
	 * @param sourceEvent the event requesting the remove of the flow execution
	 * @throws FlowExecutionStorageException when there is a technical problem
	 *         accessing the flow execution storage
	 */
	public void remove(Serializable id, Event sourceEvent) throws FlowExecutionStorageException;

}