<?xml version="1.0" encoding="UTF-8"?>
<chapter id="oxm">
    <title>Marshalling XML using O/X Mappers</title>

    <section id="oxm-introduction">
        <title>Introduction</title>
        <para>
            Some of the benefits of using Spring for your O/X mapping needs are:
        </para>
        <formalpara>
            <title>Consistent Interfaces</title>
            <para>
                All of Spring-WS's O/X mapping operates through two global interfaces: the
                <classname>Marshaller</classname> and <classname>Unmarshaller</classname> interface. These abstractions
                allow you to switch from one O/X mapping framework to another with relative ease, with little or no
                changes required on the classes that do the marshalling. This approach has the additional benefit of
                making it possible to do XML marshalling with a mix-and-match approach (e.g. some marshalling performed
                using JAXB, other using XMLBeans) in a non-intrusive fashion, leveraging the strength of each
                technology.
            </para>
        </formalpara>
        <formalpara>
            <title>Consistent Exception Hierarchy</title>
            <para>
                Spring-WS provides a conversion from exceptions from the underlying O/X mapping tool to its own
                exception hierarchy with the <classname>XmlMappingException</classname> as the root exception. As can be
                expected, these runtime exceptions wrap the original exception so no information will be lost.
            </para>
        </formalpara>
    </section>
    <section id="oxm-marshaller-unmarshaller">
        <title>Marshaller and Unmarshaller</title>
        <para>
            Within the field of O/X mapping, a <emphasis>marshaller</emphasis> is responsible for serializing an
            object graph to an XML stream. In similar fashion, an <emphasis>unmarshaller</emphasis> deserializes an
            XML stream to an object graph.
        </para>
        <section>
            <title>Marshaller</title>
            <para>
                Spring-WS's basis for marshalling is the <classname>org.springframework.oxm.Marshaller</classname>
                interface, which is listed below.
<programlisting><![CDATA[
public interface Marshaller {

    /**
     * Marshals the object graph with the given root into the provided Result.
     */
    void marshal(Object graph, Result result)
        throws XmlMappingException, IOException;
}]]></programlisting>
                As you can see, the <classname>Marshaller</classname> has just one method, which marshals the given
                object to a <classname>javax.xml.transform.Result</classname>. Result basically is an XML output
                abstraction: concrete implementations wrap a DOM document
                (<classname>javax.xml.transform.dom.DOMResult</classname>), an <classname>OutputStream</classname> or
                <classname>Writer</classname> (<classname>javax.xml.transform.stream.StreamResult</classname>), or a SAX
                <classname>ContentHandler</classname> (<classname>javax.xml.transform.sax.SAXResult</classname>).
            </para>
            <note>
                <para>
                    Although the <methodname>marshal</methodname> method accepts a plain object as its first parameter,
                    most <classname>Marshaller</classname> implementations cannot handle arbitrary objects. Instead, an
                    object class must be mapped in a mapping file, registered with the marshaller, or have a common base
                    class. Refer to the further sections in this chapter to determine how your O/X technology of choice
                    manages this.
                </para>
            </note>
        </section>
        <section>
            <title>Unmarshaller</title>                
            <para>
                Similar to Marshaller, there is the <classname>org.springframework.oxm.Unmarshaller</classname>
                interface.
                <programlisting><![CDATA[
public interface Unmarshaller {

    /**
     * Unmarshals the given provided Source into an object graph.
     */
    Object unmarshal(Source source)
        throws XmlMappingException, IOException;
}]]></programlisting>
                This interface also has one method, which reads from the given
                <classname>javax.xml.transform.Source</classname> (an XML input stream abstraction), and returns the
                object read. As with Result, concrete implementations of Source wrap a DOM document
                (<classname>javax.xml.transform.dom.DOMSource</classname>), an <classname>InputStream</classname> or
                <classname>Reader</classname> (<classname>javax.xml.transform.stream.StreamSource</classname>), or a SAX
                <classname>InputSource</classname> and <classname>XMLReader</classname>
                (<classname>javax.xml.transform.sax.SAXSource</classname>).
            </para>
        </section>
        <para>
            Even though there are two separate interfaces, most implementations found in Spring-WS implement both in one
            class. This means that you need to wire up one class and refer to it as marshaller and unmarshaller.
        </para>
        <section>
            <title>XmlMappingException</title>
            <para>
                Spring-WS provides a conversion of exceptions from the underlying O/X mapping tool to its own
                exception hierarchy with the <classname>XmlMappingException</classname> as the root exception. As can be
                expected, these runtime exceptions wrap the original exception so no information will be lost.
            </para>
            <para>
                Additionally, with the <classname>MarshallingFailureException</classname> and the
                <classname>UnmarshallingFailureException</classname>. Spring-WS makes a distinction between marshalling
                and unmarshalling data in its exception hierarchy, even though the underlying O/X mapping tool does not
                do so.
            </para>
            <para>
                The O/X Mapping exception hierarchy is shown in the following figure:
                <mediaobject>
                    <imageobject role="fo">
                        <imagedata fileref="images/oxm-exceptions.svg"
                                   format="SVG" align="center"/>
                    </imageobject>
                    <imageobject role="html">
                        <imagedata fileref="images/oxm-exceptions.png"
                                   format="PNG" align="center"/>
                    </imageobject>
                    <caption>
                        <para>
                            O/X Mapping exception hierarchy
                        </para>
                    </caption>
                </mediaobject>
            </para>
        </section>
    </section>
    <section id="oxm-usage">
        <title>Using Marshaller and Unmarshaller</title>
        <para>
            Spring's OXM can be used for a wide variety of situations. In the following example, we will use it to
            marshal the settings of a Spring-managed application to disk. The following bean represents the settings:
            <programlisting><![CDATA[
public class Settings {
    private boolean fooEnabled;

    public boolean isFooEnabled() {
        return fooEnabled;
    }

    public void setFooEnabled(boolean fooEnabled) {
        this.fooEnabled = fooEnabled;
    }
}]]></programlisting>
        </para>
        <para>
            The application class has two methods to save and load this settings bean is shown below:
            <programlisting><![CDATA[
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.oxm.Marshaller;
import org.springframework.oxm.Unmarshaller;

public class Application {
    private static final String FILE_NAME = "settings.xml";
    private Settings settings = new Settings();
    private Marshaller marshaller;
    private Unmarshaller unmarshaller;

    public void setMarshaller(Marshaller marshaller) {
        this.marshaller = marshaller;
    }

    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.unmarshaller = unmarshaller;
    }

    public void saveSettings() throws IOException {
        FileOutputStream os = new FileOutputStream(FILE_NAME);
        try {
            this.marshaller.marshal(settings, new StreamResult(os));
        } finally {
            os.close();
        }
    }

    public void loadSettings() throws IOException {
        FileInputStream is = new FileInputStream(FILE_NAME);
        try {
            this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));
        } finally {
            is.close();
        }
    }

    public static void main(String[] args) throws IOException {
        ApplicationContext appContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        Application application = (Application) appContext.getBean("application");
        application.saveSettings();
        application.loadSettings();
    }
}]]></programlisting>
            The <classname>Application</classname> requires both <methodname>marshaller</methodname> and
            <methodname>unmarshaller</methodname> to be set. We can do so using the following 
            <filename>applicationContext.xml</filename>:
            <programlisting><![CDATA[
<beans>
    <bean id="application" class="Application">
        <property name="marshaller" ref="marshaller" />
        <property name="unmarshaller" ref="marshaller" />
    </bean>
    <bean id="marshaller" class="org.springframework.oxm.castor.CastorMarshaller"/>
</beans>

]]></programlisting>
            This application context uses Castor, but we could have used any of the other marshaller instances described
            later in this chapter. Note that Castor does not require any further configuration by default, so the bean
            definition is rather simple. Also note that the <classname>CastorMarshaller</classname> implements both
            <classname>Marshaller</classname> and <classname>Unmarshaller</classname>, so we can refer to it in both
            properties.
        </para>
        <para>
            This sample application produces the following <filename>settings.xml</filename> file:
            <programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<settings foo-enabled="false"/>
]]></programlisting>
        </para>
    </section>
    <section id="oxm-jaxb">
        <title>JAXB</title>
        <para>
            The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a
            <filename>jaxb.properties</filename> file, and possibly other files, depending on the specific
            implementation of JAXB. For instance, Sun's reference implementation compiler generates a
            <filename>bgm.ser</filename> file which contains mapping information.
        </para>
        <para>
            Spring-WS supports the standard JAXB 1.0 API as XML marshalling strategy, following the
            <classname>Marshaller</classname> and <classname>Unmarshaller</classname> interfaces described in <xref
            linkend="oxm-marshaller-unmarshaller"/>. The corresponding integration classes reside in the
            <classname>org.springframework.oxm.jaxb</classname> package.
        </para>
        <section>
            <title>JAXBContext setup</title>
            <para>
                The <classname>JAXBContext</classname> forms the entry point to the JAXB API. You construct it using a
                context path, i.e. a list of colon(:) separated Java package names that contain schema derived classes.
                Within Spring-WS, the <classname>JAXBContext</classname> is constructed using a
                <classname>JaxbContextFactoryBean</classname>:
            </para>
            <programlisting><![CDATA[
<beans>
    <bean id="jaxbContext" class="org.springframework.oxm.jaxb.JaxbContextFactoryBean">
        <property name="contextPath" value="org.springframework.ws.samples.airline.schema"/>
    </bean>

    ...]]></programlisting>
        </section>
        <section>
            <title>JaxbMarshaller</title>
            <para>
                The <classname>JaxbMarshaller</classname> class implements both the Spring-WS
                <classname>Marshaller</classname> and <classname>Unmarshaller</classname> interface. It requires a JAXB
                context to operate, which you can set using the <methodname>jaxbContext</methodname> property. In the
                next example, we refer to the <classname>jaxbContext</classname> defined in the previous snippet of
                Spring config.
            </para>
            <programlisting><![CDATA[
    ...

    <bean id="jaxbMarshaller" class="org.springframework.oxm.jaxb.JaxbMarshaller">
        <property name="jaxbContext" ref="jaxbContext" />
    </bean>

</beans>]]></programlisting>
        </section>
    </section>

    <section id="oxm-castor">
        <title>Castor</title>
        <para>
            Castor XML mapping is an open source XML binding framework. It allows you to transform the data contained in
            a java object model into/from an XML document. By default, it does not require any further configuration,
            though a mapping file can be used to have more control over the behavior of Castor.
        </para>
        <para>
            For more information on Castor, refer to the <ulink url="http://castor.org/xml-framework.html">
            <citetitle>Castor web site</citetitle></ulink>. The Spring-WS integration classes reside in the
            <classname>org.springframework.oxm.castor</classname> package.
        </para>
        <section>
            <title>CastorMarshaller</title>
            <para>
                As with JAXB, the <classname>CastorMarshaller</classname> implements both the
                <classname>Marshaller</classname> and <classname>Unmarshaller</classname> interface. It can be wired up
                as follows:
            </para>
            <programlisting><![CDATA[
<beans>

    <bean id="castorMarshaller" class="org.springframework.oxm.castor.CastorMarshaller" />
    ...

</beans>]]></programlisting>
        </section>
        <section>
            <title>Mapping</title>
            <para>
                Although it is possible to rely on Castor's default marshalling behavior, it might be necessary to have
                more control over it. This can be accomplished using a Castor mapping file. For more information, refer
                to <ulink url="http://castor.org/xml-mapping.html">Castor XML Mapping</ulink>.
            </para>
            <para>
                The mapping can be set using the <methodname>mappingLocation</methodname> resource property, indicated
                below with a classpath resource.
            </para>
            <programlisting><![CDATA[
<beans>
    <bean id="castorMarshaller" class="org.springframework.oxm.castor.CastorMarshaller" >
        <property name="mappingLocation" value="classpath:mapping.xml">
        </property>
    </bean>
</beans>
]]></programlisting>
        </section>
    </section>

    <section id="oxm-xmlbeans">
        <title>XMLBeans</title>
        <para>
            XMLBeans is an XML binding tool that has full XML Schema support, and offers full XML Infoset fidelity. It
            takes a different approach that most other O/X mapping frameworks, in that all java classes that are
            generated from an XML Schema are all derived from <classname>XmlObject</classname>.
        </para>
        <para>
            For more information on XMLBeans, refer to the <ulink url="http://xmlbeans.apache.org/"> <citetitle>XMLBeans
            web site</citetitle></ulink>. The Spring-WS integration classes reside in the
            <classname>org.springframework.oxm.xmlbeans</classname> package.
        </para>
        <section>
            <title>XmlBeansMarshaller</title>
            <para>
                The <classname>XmlBeansMarshaller</classname> implements both the <classname>Marshaller</classname> and
                <classname>Unmarshaller</classname> interface. It can be wired up as follows:
            </para>
            <programlisting><![CDATA[
<beans>

    <bean id="xmlBeansMarshaller" class="org.springframework.oxm.xmlbeans.XmlBeansMarshaller" />
    ...

</beans>]]></programlisting>
            <note>
                <para>
                    Note that the <classname>XmlBeansMarshaller</classname> can only marshal objects of type
                    <classname>XmlObject</classname>, and not every <classname>java.lang.Object</classname>.
                </para>
            </note>
        </section>
            
        
    </section>

    <section id="oxm-jibx">
        <title>JiBX</title>
        <para>
            The JiBX framework offers a solution similar to Hibernate: a binding definition defines the rules for how
            your Java objects are converted to or from XML. After preparing the binding, a binding compiler enhances the
            class files, and adds code to handle converting instances of the classes to or from XML. After running the
            binding compiler you can continue the normal steps you take in assembling your application (such as building
            jar files, etc.).
        </para>
        <para>
            For more information on JiBX, refer to the <ulink url="http://http://jibx.sourceforge.net/"><citetitle>JiBX
            web site</citetitle></ulink>. The Spring-WS integration classes reside in the
            <classname>org.springframework.oxm.jibx</classname> package.
        </para>
        <section>
            <title>JibxBindingFactoryBean</title>
            <para>
                The <classname>IBindingFactory</classname> forms the entry point to the JiBX API. You construct it using 
                the class of the object to be marshalled, and optionally a binding name.
                Within Spring-WS, the <classname>IBindingFactory</classname> is constructed using a 
                <classname>JibxBindingFactoryBean</classname>:
                <programlisting><![CDATA[
<beans>
    <bean id="flightsBindingFactory" class="org.springframework.oxm.jibx.JibxBindingFactoryBean">
        <property name="targetClass">org.springframework.oxm.jibx.Flights</property>
    </bean>
    ...]]></programlisting>
            </para>
            <note>
                <para>
                    A JibxBindingFactoryBean is configured for a single class. If you want to marshal multiple classes,
                    you have to configure multiple <classname>JibxBindingFactoryBean</classname>s.
                </para>
            </note>
        </section>
        <section>
            <title>JibxMarshaller</title>
            <para>
                The <classname>JibxMarshaller</classname> class implements both the <classname>Marshaller</classname>
                and <classname>Unmarshaller</classname> interface. It requires a JiBX
                <classname>IBindingFactory</classname> to operate, which you can set using the
                <methodname>bindingFactory</methodname> property. In the next sample, we refer to the
                <classname>flightsBindingFactory</classname> defined in the previous bean definition.
            </para>
            <programlisting><![CDATA[
    ...
    
    <bean id="jibxFlightsMarshaller" class="org.springframework.oxm.jibx.JibxMarshaller">
        <property name="bindingFactory" ref="flightsBindingFactory" />
    </bean>
]]></programlisting>
            <caution>
                <para>
                    Note that the <classname>JibxMarshaller</classname> only operates on streams, and not on DOM nodes,
                    nor SAX handlers. More specifically, it only unmarshals from <classname>StreamSource</classname>s
                    and <classname>SAXSource</classname>s, and only marshals to <classname>StreamResult</classname>s.
                </para>
            </caution>
        </section>
    </section>
</chapter>