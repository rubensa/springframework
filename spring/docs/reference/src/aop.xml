<?xml version="1.0" encoding="UTF-8"?>
<chapter id="aop">
  <title>Spring AOP: Aspect Oriented Programming with Spring</title>

  <sect1 id="aop-introduction">
    <title>Concepts</title>

    <para><emphasis>Aspect-Oriented Programming</emphasis> (<emphasis>AOP</emphasis>)
    complements OOP by providing another way of thinking about program
    structure. While OO decomposes applications into a hierarchy of objects,
    AOP decomposes programs into <emphasis>aspects</emphasis> or
    <emphasis>concerns</emphasis>. This enables modularization of concerns
    such as transaction management that would otherwise cut across multiple
    objects. (Such concerns are often termed <emphasis>crosscutting</emphasis>
    concerns.)</para>

    <para>One of the key components of Spring is the <emphasis>AOP framework</emphasis>.
    While the Spring IoC containers (BeanFactory and ApplicationContext) do
    not depend on AOP (meaning you don&#39;t need to use AOP if you don&#39;t
    want to), AOP complements Spring IoC to provide a very capable middleware
    solution.</para>

    <para>AOP is used in Spring:</para>

    <itemizedlist>
      <listitem>
        <para>To provide declarative enterprise services, especially as a
        replacement for EJB declarative services. The most important such
        service is <emphasis>declarative transaction management</emphasis>,
        which builds on Spring&#39;s transaction abstraction.</para>
      </listitem>

      <listitem>
        <para>To allow users to implement custom aspects, complementing their
        use of OOP with AOP.</para>
      </listitem>
    </itemizedlist>

    <para>Thus you can view Spring AOP as either an enabling technology that
    allows Spring to provide declarative transaction management without EJB;
    or use the full power of the Spring AOP framework to implement custom
    aspects.</para>

    <remark>If you are interested only in generic declarative services or
    other pre-packaged declarative middleware services such as pooling, you
    don&#39;t need to work directly with Spring AOP, and can skip most of this
    chapter.</remark>

    <sect2 id="aop-introduction-defn">
      <title>AOP concepts</title>

      <para>Let&#39;s begin by defining some central AOP concepts. These terms
      are not Spring-specific. Unfortunately, AOP terminology is not
      particularly intuitive; however, it would be still more confusing for
      Spring to use its own terminology.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Aspect</emphasis>: A modularization of a concern for
          which the implementation might otherwise cut across multiple
          objects. Transaction management is a good example of a crosscutting
          concern in J2EE applications. Aspects are implemented using Spring
          as Advisors or interceptors.</para>
        </listitem>

        <listitem>
          <para><emphasis>Joinpoint</emphasis>: Point during the execution of
          a program, such as a method invocation or a particular exception
          being thrown.</para>
        </listitem>

        <listitem>
          <para><emphasis>Advice</emphasis>: Action taken by the AOP framework
          at a particular joinpoint. Different types of advice include
          &#34;around,&#34; &#34;before&#34; and &#34;throws&#34; advice.
          Advice types are discussed below. Many AOP frameworks, including
          Spring, model an advice as an <emphasis>interceptor</emphasis>,
          maintaining a chain of interceptors &#34;around&#34; the joinpoint.</para>
        </listitem>

        <listitem>
          <para><emphasis>Pointcut</emphasis>: A set of joinpoints specifying
          when an advice should fire. An AOP framework must allow developers
          to specify pointcuts: for example, using regular expressions.</para>
        </listitem>

        <listitem>
          <para><emphasis>Introduction</emphasis>: Adding methods or fields to
          an advised class. Spring allows you to introduce new interfaces to
          any advised object. For example, you could use an introduction to
          make any object implement an <literal>IsModified</literal>
          interface, to simplify caching.</para>
        </listitem>

        <listitem>
          <para><emphasis>Target object</emphasis>: Object containing the
          joinpoint. Also referred to as <emphasis>advised</emphasis> or
          <emphasis>proxied</emphasis> object.</para>
        </listitem>

        <listitem>
          <para><emphasis>AOP proxy</emphasis>: Object created by the AOP
          framework, including advice. In Spring, an AOP proxy will be a JDK
          dynamic proxy or a CGLIB proxy.</para>
        </listitem>

        <listitem>
          <para><emphasis>Weaving</emphasis>: Assembling aspects to create an
          advised object. Some technologies, such as AspectJ, perform weaving
          at compile time. Spring, like other pure Java AOP frameworks,
          performs weaving at runtime.</para>
        </listitem>
      </itemizedlist>

      <para>Different advice types include:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Around advice</emphasis>: Advice that surrounds a
          joinpoint such as a method invocation. This is the most powerful
          kind of advice. Around advices will perform custom behaviour before
          and after the method invocation. They are responsible for choosing
          whether to proceed to the joinpoint or to shortcut executing by
          returning their own return value or throwing an exception.</para>
        </listitem>

        <listitem>
          <para><emphasis>Before advice</emphasis>: Advice that executes
          before a joinpoint, but which does not have the ability to prevent
          execution flow proceeding to the joinpoint (unless it throws an
          exception).</para>
        </listitem>

        <listitem>
          <para><emphasis>Throws advice</emphasis>: Advice to be executed if a
          method throws an exception. Spring provides strongly typed throws
          advice, so you can write code that catches the exception (and
          subclasses) you&#39;re interested in, without needing to cast from
          Throwable or Exception.</para>
        </listitem>

        <listitem>
          <para><emphasis>After returning advice</emphasis>: Advice to be
          executed after a joinpoint completes normally: for example, if a
          method returns without throwing an exception.</para>
        </listitem>
      </itemizedlist>

      <para>Around advice is the most general kind of advice. Most
      interception-based AOP frameworks, such as Nanning Aspects and JBoss 4
      (as or DR2), provide only around advice.</para>

      <para>As Spring, like AspectJ, provides a full range of advice types, we
      recommend that you use the least powerful advice type that can implement
      the required behaviour. For example, if you need only to update a cache
      with the return value of a method, you are better off implementing an
      after returning advice than an around advice, although an around advice
      can accomplish the same thing. Using the most specific advice type
      provides a simpler programming model with less potential for errors. For
      example, you don&#39;t need to invoke the <literal>proceed() </literal>method
      on the MethodInvocation used for around advice, and hence can&#39;t fail
      to invoke it.</para>

      <para>The pointcut concept is the key to AOP, distinguishing AOP from
      older technologies offering interception. Pointcuts enable advice to be
      targeted independently of the OO hierarchy. For example, an around
      advice providing declarative transaction management can be applied to a
      set of methods spanning multiple objects. Thus pointcuts provide the
      structural element of AOP.</para>
    </sect2>

    <sect2 id="aop-introduction-spring-defn">
      <title>Spring AOP capabilities</title>

      <para>Spring AOP is implemented in pure Java. There is no need for a
      special compilation process. Spring AOP does not need to control the
      class loader hierarchy, and is thus suitable for use in a J2EE web
      container or application server.</para>

      <para>Spring currently supports interception of method invocations.
      Field interception is not implemented.</para>

      <remark>Field interception arguably violates OO encapsulation. We
      don&#39;t believe that it&#39;s wise in application development. If you
      require field interception, consider using AspectJ.</remark>

      <para>Spring provides classes to represent pointcuts and different
      advice types. Spring uses the term <emphasis>advisor</emphasis> for an
      object representing an aspect, including both an advice and a pointcut
      targeting it to specific joinpoints.</para>

      <para>Different advice and pointcut types are representing in an
      interface hierarchy in the <literal>org.springframework.aop</literal>
      package. The following UML class diagram shows the hierarchy:</para>

      <figure>
        <title>Spring Advisor hierarchy</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/aop-uml.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Note how each advisor type has a corresponding advice type:
      ThrowsAdvisor and ThrowsAdvice; BeforeAdvisor and BeforeAdvice; and
      InterceptionAroundAdvisor and Interceptor. We&#39;ll discuss advice
      types in detail below.</para>

      <para>Spring implements the <emphasis>AOP Alliance</emphasis>
      interception interfaces (<link linkend="???">http://www.sourceforge.net/projects/aopalliance</link>).
      Around advice must implement the AOP Alliance <literal>org.aopalliance.intercept.MethodInterceptor
      </literal>interface. Implementations of this interface can run in Spring
      or any other AOP Alliance compliant implementation. Currently JAC
      implements the AOP Alliance interfaces, and Nanning is likely to in
      early 2004.</para>
    </sect2>

    <sect2 id="aop-introduction-proxies">
      <title>AOP Proxies in Spring</title>

      <para>Spring defaults to using JDK <emphasis>dynamic proxies</emphasis>
      for AOP proxies. This enables any interface or set of interfaces to be
      proxied.</para>

      <para>Spring can also use CGLIB proxies. This is necessary to proxy
      classes, rather than interfaces. CGLIB is used by default if a business
      object doesn&#39;t implement an interface. As it&#39;s good practice to
      <emphasis>program to interfaces rather than classes</emphasis>, business
      objects normally will implement one or more business interfaces.</para>

      <para>It is possible to force the use of CGLIB: we&#39;ll discuss this
      below, and explain why you&#39;d want to do this.</para>
    </sect2>

    <sect2>
      <title>Quick start</title>

      <para>If you </para>

      <para>Just understand interceptors</para>

      <para>Just understand generic advice?</para>
    </sect2>
  </sect1>

  <sect1 id="aop-introduction-pointcuts">
    <title>Pointcuts in Spring</title>

    <sect2>
      <title>Concepts</title>

      <para>Spring&#39;s pointcut model enables pointcut reuse independent of
      advice types. It&#39;s possible to target different advice using the
      same pointcut.</para>

      <para>The <literal>org.springframework.aop.Pointcut</literal> interface
      is the central interface, used to target advices to particular classes
      and methods. The complete interface is shown below:</para>

      <programlisting>public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</programlisting>

      <para>Splitting the Pointcut interface into two parts allows reuse of
      class and method matching parts, and fine-grained composition operations
      (such as performing a &#34;union&#34; with another method matcher).</para>

      <para>The ClassFilter interface is used to restrict the pointcut to a
      given set of target classes. If the matches() method always returns
      true, all target classes will be matched:</para>

      <programlisting>public interface ClassFilter {

    boolean matches(Class clazz);
}</programlisting>

      <para>The <literal>MethodMatcher</literal> interface is normally more
      important. The complete interface is shown below:</para>

      <programlisting>public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}</programlisting>

      <para>The <literal>matches(Method, Class) </literal>method is used to
      test whether this pointcut ever match a given method on a target class.
      This evaluation can be performed when an AOP proxy is created, to avoid
      the need for a test on every method invocation. If the 2-argument
      matches method returns true for a given method, and the
      <literal>isRuntime() </literal>method for the MethodMatcher returns
      true, the 3-argument matches method will be invoked on every method
      invocation. This enables a pointcut to look at the arguments passed to
      the method invocation immediately before the target advice is to
      execute.</para>

      <para>Most MethodMatchers are static, meaning that their
      <literal>isRuntime()</literal> method returns false. In this case, the
      3-argument matches method will never be invoked.</para>

      <remark>If possible, try to make pointcuts static, allowing the AOP
      framework to cache the results of pointcut evaluation when an AOP proxy
      is created.</remark>
    </sect2>

    <sect2>
      <title>Operations on pointcuts</title>

      <para>COMPOSITION</para>

      <para>The two operations on pointcuts are <emphasis>union</emphasis> and
      <emphasis>intersection</emphasis>. </para>

      <para>Union means the methods that either pointcut matches. </para>

      <para>Intersection means the methods that both pointcuts match.</para>

      <para>Union is usually more useful.</para>

      <para>Pointcuts can be composed using the static methods in the
      <emphasis>org.springframework.aop.support.Pointcuts</emphasis> class, or
      using the <emphasis>ComposablePointcut</emphasis> class in the same
      package.</para>

      <para>Either of these</para>
    </sect2>

    <sect2>
      <title>Convenience pointcut implementations</title>

      <para>Spring provides several convenient pointcut implementations. Some
      can be used out of the box; others are intended to be subclassed in
      application-specific pointcuts.</para>

      <sect3>
        <title>Static pointcuts</title>

        <para>Static pointcuts are based on method and target class, and
        cannot take account of method arguments.</para>

        <sect4>
          <title>Regexp</title>

          <para>One obvious way to specific static pointcuts is regular
          expressions. Several AOP frameworks besides Spring make this
          possible. <literal>org.springframework.aop.support.RegexpMethodPointcut</literal>
          is a generic regular expression pointcut, using Perl 5 regular
          expression syntax.</para>

          <para>**TODO EXAMPLE OF USING IT</para>

          <remark>This class requires the Jakarta ORO regular expression
          package.</remark>
        </sect4>

        <sect4>
          <title>Attribute-driven pointcuts</title>

          <para>An important type of static pointcut is a
          <emphasis>metadata-driven</emphasis> pointcut. This uses the values
          of metadata attributes: typically, source-level metadata.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Dynamic pointcuts</title>

        <para>Dynamic pointcuts are costlier to evaluate than static
        pointcuts.</para>

        <sect4>
          <title>Control flow pointcuts</title>

          <para>Control flow pointcuts are similar to AspectJ
          <emphasis>cflow</emphasis> pointcuts.<note><para>Control flow
          pointcuts are significantly more expensive to evaluate at runtime
          than even other dynamic pointcuts. In Java 1.4, the cost is about 5
          times that of other dynamic pointcuts; in Java 1.3 more than 10.</para></note></para>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Pointcut superclasses</title>

      <para>These are useful if you intend to implement your own pointcuts.</para>

      <para>Because static pointcuts are most useful, you&#39;ll probably
      subclass StaticMethodMatcherPointcut</para>

      <para><programlisting>class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}</programlisting>There is also a superclasses for dynamic pointcuts.</para>
    </sect2>

    <sect2>
      <title>Custom pointcuts</title>

      <para>Because pointcuts in Spring are Java classes, rather than language
      features (as in AspectJ) it&#39;s possible to declare custom pointcuts,
      whether static or dynamic.</para>

      <remark>Later versions of Spring may offer support for &#34;semantic
      pointcuts&#34; as offered by JAC: for example, &#34;all methods that
      change instance variables in the target object.&#34;</remark>
    </sect2>
  </sect1>

  <sect1>
    <title>Advice types in Spring</title>

    <sect2>
      <title>Advice lifecycles</title>

      <para>Spring advices can be shared across all advised objects, or unique
      to each advised object. This corresponds to <emphasis>per-class</emphasis>
      or <emphasis>per-instance</emphasis> advice.</para>

      <para>Per-class advice is used most often. It is appropriate for generic
      advice such as transaction advisors. These do not depend on the state of
      the proxied object or add new state; merely act on the method and
      arguments.</para>

      <para>Per-instance advice is appropriate for introductions, to support
      mixins. In this case, the advice adds state to the proxied object.</para>

      <para>It&#39;s possible to use a mix of shared and per-instance advice
      in the same AOP proxy.</para>
    </sect2>

    <sect2 id="aop-introduction-advice-types">
      <title>Advice types in Spring</title>

      <para>Spring provides several advice types out of the box, and is
      extensible to support arbitrary advice types. Let&#39;s look at the
      basic concepts and standard advice types.</para>

      <sect3>
        <title>Interception around advice</title>

        <para>The most fundamental advice type in Spring is
        <emphasis>interception around advice</emphasis>.</para>

        <para>Spring is compliant with the AOP Alliance interface for around
        advice using method interception. MethodInterceptors implementing
        around advice should implement the following interface:</para>

        <programlisting>public interface MethodInterceptor extends Interceptor {
  
    Object invoke(MethodInvocation invocation) throws Throwable;
}</programlisting>

        <para>The <emphasis>MethodInvocation</emphasis> argument to the
        <emphasis>invoke()</emphasis> method exposes the method being invoked;
        the target joinpoint; the arguments to the method. The i<emphasis>nvoke()</emphasis>
        method should return the invocation&#39;s result: the return value of
        the joinpoint.</para>

        <para>A simple <emphasis>MethodInterceptor</emphasis> looks as
        follows:</para>

        <programlisting>public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println(&#34;Before: invocation=[&#34; + invocation + &#34;]&#34;);
        Object rval = invocation.proceed();
        System.out.println(&#34;Invocation returned&#34;);
        return rval;
    }
}</programlisting>

        <para>Note the call to the MethodInvocation&#39;s
        <emphasis>proceed() </emphasis>method. This proceeds down the
        interceptor chain towards the joinpoint. Most interceptors will invoke
        this method, and return its return value. However, a
        MethodInterceptor, like any around advice, can return a different
        value or throw an exception rather than invoke the proceed method.
        However, you don&#39;t want to do this without good reason!</para>

        <remark>MethodInterceptors offer interoperability with other AOP
        Alliance-compliant AOP implementations. The other advice types
        discussed in the remainder of this section implement common AOP
        concepts, but in a Spring-specific way. While there is an advantage in
        using the most specific advice type, stick with MethodInterceptor
        around advice if you are likely to want to run the aspect in another
        AOP framework. Note that pointcuts are not currently interoperably
        between frameworks, and the AOP Alliance does not currently define
        pointcut interfaces.</remark>
      </sect3>

      <sect3>
        <title>Before advice</title>

        <para>A simpler advice type is a before advice. This does not need a
        MethodInvocation object as</para>

        <para>The main advantage of a before advice is that there is no need
        to invoke the proceed() method, and therefore no possibility of
        inadvertently failing to proceed down the interceptor chain.</para>

        <para>interface</para>

        <programlisting>public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</programlisting>

        <para>Note the the return type is void. Before advice can insert
        custom behaviour before the joinpoint executes, but cannot change the
        return value. If it throws an exception, this will abort further
        execution of the interceptor chain.</para>

        <para>An example of a before advice in Spring, which counts all
        methods that return normally:</para>

        <programlisting>public class CountingBeforeAdvice implements MethodBeforeAdvice {
    private int count;
    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() { 
        return count; 
    }
}</programlisting>

        <remark>Before advice can be used with any pointcut.</remark>
      </sect3>

      <sect3>
        <title>Throws advice</title>

        <para>Throws advice is invoked after the return of the joinpoint if
        the joinpoint threw an exception. Spring offers typed throws advice.
        Note that this means that the <literal>org.springframework.aop.ThrowsAdvice</literal>
        interface does not contain any methods: it is a tag interface
        identifying that the given object implements one or more typed throws
        advice methods. These should be of form</para>

        <programlisting>afterThrowing([Method], [args], [target], subclassOfThrowable) </programlisting>

        <para>Only the last argument is required. Thus there can be either one
        or four arguments, dependent on whether the advice method is
        interested in the method and arguments. The following are examples of
        throws advices.</para>

        <para>This advice will be invoked if a <literal>RemoteException</literal>
        is thrown (including subclasses):</para>

        <programlisting>public  class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
}</programlisting>

        <para>The following advice is invoked if a <emphasis>ServletException</emphasis>
        is thrown. Unlike the above advice, it declares 4 arguments, so that
        it has access to the invoked method, method arguments and target
        object:</para>

        <programlisting>public static class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</programlisting>

        <para>The final example illustrates how these two methods could be
        used in a single class, which handles both <literal>RemoteException</literal>
        and <literal>ServletException</literal>. Any number of throws advice
        methods can be combined in a single class.</para>

        <programlisting>public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
 
    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</programlisting>

        <remark>Throws advice can be used with any pointcut.</remark>
      </sect3>

      <sect3>
        <title>After Returning advice</title>

        <para>An after returning advice in Spring must implement the
        <emphasis>org.springframework.aop.MethodAfterReturningAdvice</emphasis>
        interface, shown below:</para>

        <programlisting>public interface MethodAfterReturningAdvice extends AfterReturningAdvice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable;
}</programlisting>

        <para>An after returning advice has access to the return value (which
        it cannot modify), invoked method, methods arguments and target.</para>

        <para>The following after returning advice counts all successful
        method invocations, that have not thrown exceptions:</para>

        <programlisting>public class CountingAfterReturningAdvice implements MethodAfterReturningAdvice {
    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</programlisting>

        <para>This advice doesn&#39;t change the execution path. If it throws
        an exception, this will be thrown up the interceptor chain instead of
        the return value.</para>

        <remark>After returning advice can be used with any pointcut.</remark>
      </sect3>

      <sect3>
        <title>Introduction advice</title>

        <para>Spring treats introduction advice as a special kind of
        interception around advice.</para>

        <para>After returning</para>

        <programlisting>public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</programlisting>

        <para>The invoke() method inherited from the AOP Alliance
        MethodInterceptor interface must implement the introduction.</para>

        <para>Show example</para>

        <para>Delegating II</para>

        <para>Advice lifecycle</para>

        <para>Introduction advice cannot be used with any pointcut, as it
        applies only at class, rather than method, level. You can only use
        introduction advice with the InterceptionIntroductionAdvisor, which
        has the following methods:</para>

        <programlisting>public interface InterceptionIntroductionAdvisor extends InterceptionAdvisor {

    ClassFilter getClassFilter();

    IntroductionInterceptor getIntroductionInterceptor();

    Class[] getInterfaces();
}</programlisting>

        <para>There is no MethodMatcher, and hence no Pointcut, associated
        with introduction advice. Only class filtering is logical.</para>

        <para>The getInterfaces() method returns the interfaces introduced by
        this advisor. Note that this MAY DIFFER</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Advisors in Spring</title>

    <para>In Spring, an Advisor is a complete modularization of an aspect.
    Advisors typically incorporate both an advice and a pointcut.</para>

    <para>For each advice type listed above, there is a corresponding advisor
    type in the <literal>org.springframework.aop</literal> package. These are,
    respectively:</para>

    <itemizedlist>
      <listitem>
        <para>InterceptionAroundAdvisor</para>
      </listitem>

      <listitem>
        <para>BeforeAdvisor</para>
      </listitem>

      <listitem>
        <para>ThrowsAdvisor</para>
      </listitem>

      <listitem>
        <para>AfterReturningAdvisor</para>
      </listitem>
    </itemizedlist>

    <para>There is a special advice type to support introductions,
    <literal>InterceptionIntroductionAdvisor</literal>. This</para>

    <para>SHOW implementing an advisor:</para>

    <para>**TODO using convenience class</para>

    <para>It is possible to mix advisor and advice types in Spring in the one
    AOP proxy. For example, you could use a interception around advice, throws
    advice and before advice in the one proxy configuration: Spring will
    automatically create the create interceptor chain.</para>
  </sect1>

  <sect1 id="aop-pfb">
    <title>Using the ProxyFactoryBean to create AOP proxies</title>

    <para>If you&#39;re using the Spring IoC container (an ApplicationContext)
    for your business objects--and you should be!--you will want to use one of
    Spring&#39;s AOP FactoryBeans. (Remember that a factory bean introduces a
    layer of indirection, enabling it to create objects of a different type).</para>

    <para>The basic way to create an AOP proxy in Spring is to use the
    <emphasis>org.springframework.aop.framework.ProxyFactoryBean</emphasis>.
    This gives complete control over the pointcuts and advice that will apply,
    and their ordering. However, there are simpler options that are preferable
    if you don&#39;t need such control.</para>

    <sect2 id="aop-pfb-1">
      <title>Basics</title>

      <para>Talk about</para>

      <para></para>
    </sect2>

    <sect2 id="aop-pfb-2">
      <title>JavaBean properties</title>

      <para>Like most FactoryBean implementations provided by Spring,
      ProxyFactoryBean is a JavaBean. Its properties are used to:</para>

      <itemizedlist>
        <listitem>
          <para>specify the target you want to proxy</para>
        </listitem>

        <listitem>
          <para>specify whether to use CGLIB</para>
        </listitem>
      </itemizedlist>

      <para></para>

      <para>**TODO Show UML diagram to show inheritance from ProxyConfig?</para>

      <para></para>
    </sect2>

    <sect2>
      <title>Proxying interfaces</title>

      <para>Let&#39;s look at a simple example of ProxyFactoryBean in action.
      This example involves:</para>

      <itemizedlist>
        <listitem>
          <para>A target bean that will be proxied. This is the
          &#34;personTarget&#34; bean definition in the example below.</para>
        </listitem>

        <listitem>
          <para>An Advisor and an Interceptor used to provide advice.</para>
        </listitem>

        <listitem>
          <para>An AOP proxy bean definition specifying the target object (the
          personTarget bean) and the interfaces to proxy, along with the
          advices to apply. </para>
        </listitem>
      </itemizedlist>

      <para><programlisting>&#60;bean id=&#34;personTarget&#34; class=&#34;com.mycompany.PersonImpl&#34;&#62;
    &#60;property name=&#34;name&#34;&#62;&#60;value&#62;Tony&#60;/value&#62;&#60;/property&#62;
    &#60;property name=&#34;age&#34;&#62;&#60;value&#62;51&#60;/value&#62;&#60;/property&#62;
&#60;/bean&#62;


&#60;bean id=&#34;myAdvisor&#34; class=&#34;com.mycompany.MyAdvisor&#34;&#62;
    &#60;property name=&#34;someProperty&#34;&#62;&#60;value&#62;Custom string property value&#60;/value&#62;&#60;/property&#62;
&#60;/bean&#62;

&#60;bean id=&#34;debugInterceptor&#34; class=&#34;org.springframework.aop.interceptor.NopInterceptor&#34;&#62;
&#60;/bean&#62;

&#60;bean id=&#34;person&#34; 
    class=&#34;org.springframework.aop.framework.ProxyFactoryBean&#34;
&#62;
    &#60;property name=&#34;proxyInterfaces&#34;&#62;&#60;value&#62;com.mycompany.Person&#60;/value&#62;&#60;/property&#62;

    &#60;property name=&#34;target&#34;&#62;&#60;ref local=&#34;personTarget&#34;/&#62;&#60;/property&#62;
    &#60;property name=&#34;interceptorNames&#34;&#62;
        &#60;list&#62;
            &#60;value&#62;myAdvisor&#60;/value&#62;
            &#60;value&#62;debugInterceptor&#60;/value&#62;
        &#60;/list&#62;
    &#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

      <para>Note that the <literal>interceptorNames</literal> property takes a
      list of String: the bean names of the interceptor or advisors in the
      current factory. (Advisors, interceptors, before, after returning and
      throws advice objects can be used.) The ordering of advisors is
      significant.</para>

      <remark>You might be wondering why the list doesn&#39;t hold bean
      references. The reason for this is that if the ProxyFactoryBean&#39;s
      singleton property is set to false, it must be able to return
      independent proxy instances. If any of the advisors is itself a
      prototype, and independent instance would need to be returned, so
      it&#39;s necessary to be able to obtain an instance of the prototype
      from the factory; holding a reference isn&#39;t sufficient.</remark>

      <para>The &#34;person&#34; bean definition above can be used in the
      place of a Person implementation, as follows:</para>

      <programlisting>Person person = (Person) factory.getBean(&#34;person&#34;);</programlisting>

      <para>Other beans in the same IoC context can express a strongly typed
      dependency on it, as with an ordinary Java object:</para>

      <para><programlisting>&#60;bean id=&#34;personUser&#34; class=&#34;com.mycompany.PersonUser&#34;&#62;
    &#60;property name=&#34;person&#34;&#62;&#60;ref local=&#34;person&#34; /&#62;&#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

      <para>The PersonUser class in this example would expose a property of
      type Person. As far as it&#39;s concerned, the AOP proxy can be used
      transparently in place of a &#34;real&#34; person implementation.
      However, its class would be a dynamic proxy class. It would be possible
      to cast it to the <literal>Advised</literal> interface (discussed
      below).</para>
    </sect2>

    <sect2>
      <title>Proxying classes</title>

      <para>What if you need to proxy a class, rather than one or more
      interfaces?</para>

      <para>Imagine that in our example above, there was no Person interface:
      we needed to advise a class called Person that didn&#39;t implement any
      business interface. In this case, you can configure Spring to use CGLIB
      proxying, rather than dynamic proxies. Simply set the
      <literal>proxyTargetClass</literal> property on the ProxyFactoryBean
      above to true.</para>

      <para>If you want to you can force the use of CGLIB in any case, even if
      you have interfaces.</para>

      <para>CGLIB proxying works by generating a subclass of the target class
      at runtime. Spring configures this generated subclass to delegate method
      calls to the original target: the subclass is used to implement the
      <emphasis>Decorator</emphasis> pattern, weaving in the advice.</para>

      <para>CGLIB proxying should generally be transparent to users. However,
      there are some issues to consider:</para>

      <itemizedlist>
        <listitem>
          <para><literal>Final</literal> methods can&#39;t be advised, as they
          can&#39;t be overridden.</para>
        </listitem>

        <listitem>
          <para>You&#39;ll need the CGLIB 2 binaries on your classpath;
          dynamic proxies are available with the JDK</para>
        </listitem>
      </itemizedlist>

      <para>There&#39;s little performance difference between CGLIB proxying
      and dynamic proxies. As of Spring 1.0, dynamic proxies are slightly
      faster.</para>
    </sect2>

    <sect2>
      <title>Special flags</title>

      <para>The ProxyConfig class</para>

      <para>expose proxy</para>
    </sect2>
  </sect1>

  <sect1 id="aop-tfb">
    <title>Convenient proxy creation</title>

    <para>Often we don&#39;t need the full power of the ProxyFactoryBean,
    because we&#39;re only interested in one aspect.</para>

    <para>There are a number of convenience classes.</para>

    <para>These are discussed in other chapters.</para>

    <sect2>
      <title>TransactionProxyFactoryBean</title>

      <para>The JPetStore sample application shipped with Spring shows the use
      of the TransactionProxyFactoryBean.</para>

      <para>The TransactionProxyFactoryBean also extends ProxyConfig, so the</para>

      <para>More discussion in next chapter</para>

      <para>The TransactionProxyFactoryBean is a subclass of ProxyConfig, so
      basic configuration is shared with ProxyFactoryBean.</para>
    </sect2>

    <sect2>
      <title>EJB proxies</title>

      <para>NOT DESCENDED FROM PFB</para>

      <para>More dicsussion in next chapter</para>

      <para>Hibernate etc?</para>
    </sect2>
  </sect1>

  <sect1 id="aop-prog">
    <title>Creating AOP proxies programmatically with the ProxyFactory</title>

    <para>It&#39;s easy to create AOP proxies programmatically using Spring.
    This enables you to use Spring AOP without dependency on Spring IoC.</para>

    <para>The following listing shows creation of a proxy for a target object,
    with one interceptor and one advisor. The interfaces implemented by the
    target object will automatically be proxied:</para>

    <para><programlisting>ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addInterceptor(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</programlisting></para>

    <para>The first step is to contruct a object of type <literal>org.springframework.aop.framework.ProxyFactory</literal>.
    You can create this with a target object, as in the above example, or
    specify the interfaces to be proxied in an alternate constructor.</para>

    <para>You can add interceptors or advisors, and manipulate them for the
    life of the ProxyFactory. If you add an
    IntroductionInterceptionAroundAdvisor you can cause the proxy to implement
    additional interfaces.</para>

    <para>There are also convenience methods on ProxyFactory (inherited from
    AdvisedSupport) allowing you to add other advice types such as before and
    throws advice. AdvisedSupport is the superclass of both ProxyFactory and
    ProxyFactoryBean.</para>

    <remark>Integrating AOP proxy creation with the IoC framework is best
    practice in most applications. We recommend that you externalize
    configuration from Java code with AOP as in general.</remark>
  </sect1>

  <sect1>
    <title>Manipulating advised objects</title>

    <para>However you create AOP proxies, you can manipulate them using the
    <literal>org.springframework.aop.framework.Advised</literal> interface.
    Any AOP proxy can be cast to this interface, whatever other interfaces it
    implements. This interface includes the following methods:</para>

    <programlisting>Advisor[] getAdvisors();

Class[] getProxiedInterfaces();

boolean isInterfaceProxied(Class intf);

void addInterceptor(Interceptor interceptor);

void addInterceptor(int pos, Interceptor interceptor);

void addAdvisor(Advisor advisor);

void addAdvisor(int pos, Advisor advisor);

boolean removeInterceptor(Interceptor interceptor);

boolean getProxyTargetClass();</programlisting>

    <para>The <literal>getAdvisors()</literal> method will return an Advisor
    for every advisor, interceptor or other advice type that has been added to
    the factory. If you added an Advisor, the returned advisor at this index
    will be the object that you added. If you added an interceptor or other
    advice type, Spring will have wrapped this in an advisor with a pointcut
    that always returns true. Thus if you added a MethodInterceptor, the
    advisor returned for this index will be an InterceptionAroundAdvisor
    returning your MethodInterceptor and a pointcut that matches all classes
    and methods.</para>

    <para>The <literal>addAdvisor()</literal> methods can be used to add any
    Advisor. Often this will be of type <literal>InterceptionAroundAdvisor</literal>,
    but it can be generic.</para>

    <para>It&#39;s possible to add or remove advisors or interceptors once a
    proxy has been created. The only restriction is that it&#39;s impossible
    to add or remove an introduction advisor, as existing proxies from the
    factory will not show the interface change. (You can obtain a new proxy
    from the factory to avoid this problem.)</para>
  </sect1>

  <sect1 id="aop-autoproxy">
    <title>Using the &#34;autoproxy&#34; facility</title>

    <para>So far we&#39;ve considered explicit creation of AOP proxies using a
    ProxyFactoryBean or similar factory bean.</para>

    <para>Spring also allows us to use &#34;autoproxy&#34; bean definitions,
    which can automatically proxy selected bean definitions. This is built on
    Spring bean postProcessor infrastructure.</para>

    <para>In this model, you set up some special bean definitions in your XML
    bean definition file configuring the auto proxy infrastructure. This
    allows you just to declare the targets eligible for autoproxying: you
    don&#39;t need to use ProxyFactoryBean.</para>

    <para>There are two ways to do this:</para>

    <itemizedlist>
      <listitem>
        <para>Using an autoproxy creator that refers to specific beans in the
        current context</para>
      </listitem>

      <listitem>
        <para>A special case of autoproxy creation that deserves to be
        considered separately; autoproxy creation driven by source-level
        metadata attributes</para>
      </listitem>
    </itemizedlist>

    <sect2 id="aop-autoproxy-choices">
      <title>Autoproxy bean definitions</title>

      <para>The <literal>org.springframework.aop.framework.autoproxy</literal>
      package provides the following standard autoproxy creators.</para>

      <sect3>
        <title>BeanNameAutoProxyCreator</title>

        <para>er</para>

        <para><programlisting>&#60;bean id=&#34;jdkBeanNameProxyCreator&#34; 
    class=&#34;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&#34;&#62;
    &#60;property name=&#34;beanNames&#34;&#62;&#60;value&#62;jdk*,onlyJdk&#60;/value&#62;&#60;/property&#62;
    &#60;property name=&#34;interceptorNames&#34;&#62;
        &#60;list&#62;
            &#60;value&#62;myInterceptor&#60;/value&#62;
        &#60;/list&#62;
    &#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

        <para>As with ProxyFactoryBean, there is an interceptorNames property
        rather than a list of interceptor, to allow correct behaviour for
        prototype advisors.</para>

        <para>Named &#34;interceptors&#34; can be advisors or any advice type.</para>
      </sect3>

      <sect3>
        <title>AdvisorAutoProxyCreator</title>

        <para>A more general</para>
      </sect3>

      <sect3>
        <title>AbstractAdvisorAutoProxyCreator</title>

        <para>This is the superclass of AdvisorAutoProxyCreator. You can
        create your own autoproxy creators by subclassing this class. </para>

        <para>WHAT DO YOU NEED TO DO?</para>
      </sect3>
    </sect2>

    <sect2 id="aop-autoproxy-metadata">
      <title>Using metadata-driven autoproxying</title>

      <para>A particularly important type of autoproxying is driven by
      metadata. This produces a similar programming model to .NET
      ServicedComponents. Instead of using XML deployment descriptors as in
      EJB, configuration for transaction management and other enterprise
      services is held in source-level attributes.</para>

      <para>In this case, you use the AdvisorAutoProxyCreator, in combination
      with Advisors that understand metadata attributes. The metadata
      specifics are held in the pointcut part of the candidate advisors,
      rather than in the autoproxy creation class itself.</para>

      <para>The <literal>/attributes</literal> directory of the JPetStore
      sample application shows the use of attribute-driven autoproxying. In
      this case, there&#39;s no need to use the TransactionProxyFactoryBean.
      Simply defining transactional attributes on business objects is
      sufficient, because of the use of metadata-aware pointcuts. The bean
      definitions include the following code, in
      /WEB-INF/declarativeServices.xml. Note that this is generic, and can be
      used outside the JPetStore:</para>

      <para><programlisting>&#60;bean id=&#34;autoproxy&#34; 
    class=&#34;org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreator&#34;&#62;	
&#60;/bean&#62;

&#60;bean id=&#34;transactionAttributeSource&#34;
    class=&#34;org.springframework.transaction.interceptor.AttributesTransactionAttributeSource&#34;
    autowire=&#34;constructor&#34;&#62;
&#60;/bean&#62;

&#60;bean id=&#34;transactionInterceptor&#34;
    class=&#34;org.springframework.transaction.interceptor.TransactionInterceptor&#34;
    autowire=&#34;byType&#34;&#62;
&#60;/bean&#62;

&#60;bean id=&#34;transactionAdvisor&#34;
    class=&#34;org.springframework.transaction.interceptor.TransactionAttributeSourceTransactionAroundAdvisor&#34;
    autowire=&#34;constructor&#34; &#62;
&#60;/bean&#62;

&#60;bean id=&#34;attributes&#34;
    class=&#34;org.springframework.metadata.commons.CommonsAttributes&#34;
/&#62;</programlisting></para>

      <para>The AdvisorAutoProxyCreator bean definition--called
      &#34;advisor&#34; in this case, but the name is not significant--will
      pick up all eligible pointcuts in the current application context. In
      this case, the &#34;transactionAdvisor&#34; bean definition, of type
      TransactionAttributeSourceTransactionAroundAdvisor, will apply to
      classes or methods carrying a transaction attribute. The
      TransactionAttributeSourceTransactionAroundAdvisor depends on a
      TransactionInterceptor, via constructor dependency. The example resolves
      this via autowiring. The AttributesTransactionAttributeSource depends on
      an implementation of the <literal>org.springframework.metadata.Attributes</literal>
      interface. In this fragement, the &#34;attributes&#34; bean satisfies
      this, using the Jakarta Commons Attributes API to obtain attribute
      information. (The application code must have been compiled using the
      Commons Attributes compilation task.)</para>

      <para>The TransactionInterceptor defined here depends on a
      <literal>PlatformTransactionManager</literal> definition, which is not
      included in this generic file (although it could be) because it will be
      specific to the application&#39;s transaction requirements (typically
      JTA, as in this example, or Hibernate, JDO or JDBC):</para>

      <programlisting>&#60;bean id=&#34;transactionManager&#34; 
    class=&#34;org.springframework.transaction.jta.JtaTransactionManager&#34;/&#62;</programlisting>

      <remark>If you require only declarative transaction management, using
      these generic XML definitions will result in Spring automatically
      proxying all classes or methods with transaction attributes. You
      won&#39;t need to work directly with AOP, and the programming model is
      similar to that of .NET ServicedComponents.</remark>

      <para>This mechanism is extensible. It&#39;s possible to do autoproxying
      based on custom attributes. You need to:</para>

      <itemizedlist>
        <listitem>
          <para>Define your custom attribute.</para>
        </listitem>

        <listitem>
          <para>Implement an Advisor with the necessary advice, including a
          pointcut that is triggered by the presence of the custom attribute
          on a class or method.</para>
        </listitem>
      </itemizedlist>

      <para>It&#39;s possible for such advisors to be unique to each advised
      class: they simply need to be defined as prototypes, rather than
      singletons, bean definitions.</para>
    </sect2>
  </sect1>

  <sect1 id="aop-targetsource">
    <title>Using TargetSources</title>

    <para>Spring offers the concept of a TargetSource, expressed in the
    <literal>org.springframework.aop.TargetSource</literal> interface. This
    interface is responsible for returning the &#34;target object&#34;
    implementing the joinpoint.</para>

    <para>Developers using Spring AOP don&#39;t normally need to work directly
    with TargetSources, but this provides a powerful means of supporting
    pooling, hot swappable and other sophisticated targets. For example, a
    pooling TargetSource can return a different target instance for each
    invocation, using a pool to manage instances.</para>

    <para>If you do not specify a TargetSource, a default implementation is
    used that wraps a local object.</para>

    <para>Let&#39;s look at the standard target sources provided with Spring,
    and how you can use them.</para>

    <remark>When using a custom target source, your target will usually need
    to be a prototype rather than a singleton bean definition. This allows
    Spring to create a new target instance when required.</remark>

    <sect2 id="aop-ts-swap">
      <title>Hot swappable target sources</title>

      <para>The <literal>org.springframework.aop.target.HotSwappableTargetSource</literal>
      exists to allow the target of an AOP proxy to be switched while allowing
      callers to keep their references to it.</para>

      <para>Changing the target source&#39;s target takes effect immediately.
      The <literal>HotSwappableTargetSource</literal> is threadsafe.</para>

      <para>CODE EXAMPLE</para>
    </sect2>

    <sect2 id="aop-ts-pool">
      <title>Pooling target sources</title>

      <para>Using a pooling target source provides a similar programming model
      to stateless session EJBs, in which a pool of identical instances is
      maintained, with method invocations going to free objects in the pool.</para>

      <para>A crucial difference between Spring pooling and SLSB pooling is
      that Spring pooling can be applied to any POJO. As with Spring in
      general, this service can be applied in a non-invasive way.</para>

      <para>Spring provides out-of-the-box support for Jakarta Commons Pool
      1.1, which provides a reasonably efficient pooling implementation.
      You&#39;ll need the commons-pool Jar on your application&#39;s classpath
      to use this feature. It&#39;s also possible to subclass
      <literal>org.springframework.aop.target.AbstractPoolingTargetSource</literal>
      to support any other pooling API.</para>

      <para>Config example</para>

      <para><programlisting>&#60;bean id=&#34;businessObjectTarget&#34; class=&#34;com.mycompany.MyBusinessObject&#34; 
    singleton=&#34;false&#34;&#62;
    ... properties omitted
&#60;/bean&#62;

&#60;bean id=&#34;poolTargetSource&#34; 
    class=&#34;org.springframework.aop.target.CommonsPoolTargetSource&#34;&#62;	
    &#60;property name=&#34;targetBeanName&#34;&#62;&#60;value&#62;businessObject&#60;/value&#62;&#60;/property&#62;
    &#60;property name=&#34;maxSize&#34;&#62;&#60;value&#62;25&#60;/value&#62;&#60;/property&#62;
&#60;/bean&#62;

&#60;bean id=&#34;businessObject&#34; 
    class=&#34;org.springframework.aop.framework.ProxyFactoryBean&#34;
&#62;
    &#60;property name=&#34;targetSource&#34;&#62;&#60;ref local=&#34;poolTargetSource&#34;/&#62;&#60;/property&#62;
    &#60;property name=&#34;interceptorNames&#34;&#62;&#60;value&#62;myInterceptor&#60;/value&#62;&#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

      <para>Note that the target object--&#34;businessObjectTarget&#34; in the
      example--must be a prototype. This allows the PoolingTargetSource
      implementation to create new instances of the target to grow the pool as
      necessary. See the Jvadoc for AbstractPoolingTargetSource and the
      concrete subclass you wish to use for information about it&#39;s
      properties: maxSize is the most basic, and always guaranteed to be
      present.</para>

      <para>In this case, &#34;myInterceptor&#34; is the name of an
      interceptor that would need to be defined in the same IoC context.
      However, it isn&#39;t necessary to specify interceptors to use pooling.
      If you want only pooling, and no other advice, don&#39;t set the
      interceptorNames property at all.</para>

      <para>It&#39;s possible to configure Spring so as to be able to cast any
      pooled object to the org.springframework.aop.target.PoolingConfig
      interface, which exposes information about the configuration and current
      size of the pool through an introduction. You&#39;ll need to define an
      advisor like this:</para>

      <para><programlisting>&#60;bean id=&#34;poolConfigAdvisor&#34; 
    class=&#34;org.springframework.beans.factory.config.MethodInvokingFactoryBean&#34;&#62;
    &#60;property name=&#34;target&#34;&#62;&#60;ref local=&#34;poolTargetSource&#34; /&#62;&#60;/property&#62;
    &#60;property name=&#34;targetMethod&#34;&#62;&#60;value&#62;getPoolingConfigMixin&#60;/value&#62;&#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

      <para>This advisor is obtained by calling a convenience method on the
      AbstractPoolingTargetSource class, hence the use of
      MethodInvokingFactoryBean. This advisor&#39;s name
      (&#34;poolConfigAdvisor&#34; here) must be in the list of interceptors
      names in the ProxyFactoryBean exposing the pooled object.</para>

      <para>The cast will look as follows:</para>

      <para><programlisting>PoolingConfig conf = (PoolingConfig) beanFactory.getBean(&#34;businessObject&#34;);
System.out.println(&#34;Max pool size is &#34; + conf.getMaxSize());</programlisting></para>

      <remark>Pooling stateless service objects is not usually necessary. We
      don&#39;t believe it should be the default choice, as most stateless
      objects are naturally threadsafe, and instance pooling is problematic if
      resources are cached.</remark>

      <para>Simpler pooling is available using autoproxying. It&#39;s possible
      to set the TargetSources used by any autoproxy creator.</para>
    </sect2>

    <sect2 id="aop-ts-prototype">
      <title>Prototype&#34; target sources</title>

      <para>erer</para>
    </sect2>
  </sect1>

  <sect1 id="aop-extensibility">
    <title>Defining new advice and advisor types</title>

    <para>Spring AOP is designed to be extensible. While the interception
    implementation strategy is presently used internally, it is possible to
    support arbitrary advice types in addition to interception around advice,
    before, throws advice and after returning advice, which are supported out
    of the box.</para>

    <para>The <literal>org.springframework.aop.framework.adapter</literal>
    package is an SPI package allowing support for new custom advice types to
    be added without changing the core framework.</para>

    <para>Please refer to this package&#39;s Javadocs for further information.</para>
  </sect1>

  <sect1>
    <title>Further reading and resources</title>

    <para>I recommend <emphasis>AspectJ in Action</emphasis> by Ramnivas
    Laddad (Manning, 2003) for an introduction to AOP.</para>

    <para>Please refer to the Spring sample applications for further examples
    of Spring AOP:</para>

    <itemizedlist>
      <listitem>
        <para>The JPetStore&#39;s default configuration illustrates the use of
        the TransactionProxyFactoryBean for declarative transaction management</para>
      </listitem>

      <listitem>
        <para>The <literal>/attributes</literal> directory of the JPetStore
        illustrates the use of attribute-driven declarative transaction
        management</para>
      </listitem>
    </itemizedlist>

    <para>If you are interested in more advanced capabilities of Spring AOP,
    take a look at the test suite. The test coverage is over 90%, and this
    illustrates advanced features not discussed in this document.</para>

    <para></para>
  </sect1>
</chapter>