<?xml version="1.0" encoding="UTF-8"?>
<chapter id="aop">
  <title>Spring AOP: Aspect Oriented Programming with Spring</title>

  <sect1 id="aop-introduction">
    <title>Concepts</title>

    <para><emphasis>Aspect-Oriented Programming</emphasis>
    (<emphasis>AOP</emphasis>) complements OOP by providing another way of
    thinking about program structure. While OO decomposes applications into a
    hierarchy of objects, AOP decomposes programs into
    <emphasis>aspects</emphasis> or <emphasis>concerns</emphasis>. This
    enables modularization of concerns such as transaction management that
    would otherwise cut across multiple objects. (Such concerns are often
    termed <emphasis>crosscutting</emphasis> concerns.)</para>

    <para>One of the key components of Spring is the <emphasis>AOP
    framework</emphasis>. While the Spring IoC containers (BeanFactory and
    ApplicationContext) do not depend on AOP, meaning you don't need to use
    AOP if you don't want to, AOP complements Spring IoC to provide a very
    capable middleware solution.</para>

    <para>AOP is used in Spring:</para>

    <itemizedlist>
      <listitem>
        <para>To provide declarative enterprise services, especially as a
        replacement for EJB declarative services. The most important such
        service is <emphasis>declarative transaction management</emphasis>,
        which builds on Spring's transaction abstraction.</para>
      </listitem>

      <listitem>
        <para>To allow users to implement custom aspects, complementing their
        use of OOP with AOP.</para>
      </listitem>
    </itemizedlist>

    <para>Thus you can view Spring AOP as either an enabling technology that
    allows Spring to provide declarative transaction management without EJB;
    or use the full power of the Spring AOP framework to implement custom
    aspects.</para>

    <para><emphasis>Spring 2.0 introduces a simpler and more powerful
    way of writing custom aspects using either a schema-based approach
    or the @AspectJ annotation style. For new applications, we recommend
    users use the @AspectJ style for applications written to Java 5, and
    the schema-based style otherwise. Both of these styles offer fully
    typed advice and use of the AspectJ pointcut language, while still using
    Spring AOP for weaving. The Spring 2.0 schema and @AspectJ based AOP support
    is discussed in this chapter. Spring 2.0 remains fully backwards compatible
    with Spring 1.2 and the lower-level AOP support offered by the Spring 1.2
    APIs is discussed in the next chapter. 
    </emphasis></para>
    
    <para>
    This chapter first introduces AOP concepts,
    (section 7.1), which you will want to read whatever style of aspect declaration
    you choose to use. The remainder of the chapter focuses on the Spring 2.0 AOP 
    support, see the following chapter for an overview of the Spring 1.2 style AOP,
    which you may well encounter in books, articles, and existing applications.
    </para>

    <remark>If you are interested only in generic declarative services or
    other pre-packaged declarative middleware services such as pooling, you
    don't need to work directly with Spring AOP, and can skip most of this
    chapter.</remark>

    <sect2 id="aop-introduction-defn">
      <title>AOP concepts</title>

      <para>Let us begin by defining some central AOP concepts. These terms
      are not Spring-specific. Unfortunately, AOP terminology is not
      particularly intuitive. However, it would be even more confusing if
      Spring used its own terminology.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Aspect</emphasis>: A modularization of a concern for
          which the implementation might otherwise cut across multiple
          objects. Transaction management is a good example of a crosscutting
          concern in J2EE applications. Aspects are implemented using regular
          classes (schema-based approach) or regular classes annotated with the
          @Aspect annotation (@AspectJ style).</para>
        </listitem>

        <listitem>
          <para><emphasis>Join point</emphasis>: A point during the execution of
          a program, such as the execution of a method or the handling of 
          an exception. In Spring AOP, a join point always represents a method
          execution. Join point information is available in advice
          bodies by declaring a parameter of type org.aspectj.lang.JoinPoint.
          </para>
        </listitem>

        <listitem>
          <para><emphasis>Advice</emphasis>: Action taken by the AOP framework
          at a particular join point. Different types of advice include
          "around," "before" and "after" advice. Advice types are discussed
          below. Many AOP frameworks, including Spring, model an advice as an
          <emphasis>interceptor</emphasis>, maintaining a chain of
          interceptors "around" the join point.</para>
        </listitem>

        <listitem>
          <para><emphasis>Pointcut</emphasis>: A predicate that matches join points.
          Advice is associated with a pointcut expression and runs at any join
          point matched by the pointcut (for example, the execution of a method with
          a certain name). An AOP framework must allow developers
          to specify pointcuts: Spring uses the AspectJ pointcut language by default.</para>
        </listitem>

        <listitem>
          <para><emphasis>Introduction</emphasis>: (Also known as an 
          inter-type declaration). Declaring additional methods or fields on
          behalf of an advised class. Spring allows you to introduce new interfaces to
          any advised object. For example, you could use an introduction to
          make any object implement an <literal>IsModified</literal>
          interface, to simplify caching.</para>
        </listitem>

        <listitem>
          <para><emphasis>Target object</emphasis>: Object being advised
          by one or more aspects. Also referred to as <emphasis>advised</emphasis> or
          <emphasis>proxied</emphasis> object.</para>
        </listitem>

        <listitem>
          <para><emphasis>AOP proxy</emphasis>: Object created by the AOP
          framework in order to implement the aspect contracts (advise method
          executions and so on). In Spring, an AOP proxy will be a JDK
          dynamic proxy or a CGLIB proxy.</para>
        </listitem>

        <listitem>
          <para><emphasis>Weaving</emphasis>: Linking aspects with other
          application types or objects to create an
          advised object. This can be done at compile time (using the AspectJ
          compiler, for example), load time, or at runtime. Spring, like other pure Java
          AOP frameworks, performs weaving at runtime.</para>
        </listitem>
      </itemizedlist>

      <para>Types of advice:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Before advice</emphasis>: Advice that executes
          before a join point, but which does not have the ability to prevent
          execution flow proceeding to the join point (unless it throws an
          exception).</para>
        </listitem>

        <listitem>
          <para><emphasis>After returning advice</emphasis>: Advice to be
          executed after a join point completes normally: for example, if a
          method returns without throwing an exception.</para>
        </listitem>

        <listitem>
          <para><emphasis>After throwing advice</emphasis>: Advice to be executed if a
          method exits by throwing an exception.</para>
        </listitem>

        <listitem>
          <para><emphasis>After (finally) advice</emphasis>: Advice to be executed regardless
          of the means by which a join point exits (normal or exceptional return).</para>
        </listitem>
		
        <listitem>
          <para><emphasis>Around advice</emphasis>: Advice that surrounds a
          join point such as a method invocation. This is the most powerful
          kind of advice. Around advice can perform custom behavior before
          and after the method invocation. It is also responsible for choosing
          whether to proceed to the join point or to shortcut executing by
          returning its own return value or throwing an exception.</para>
        </listitem>

      </itemizedlist>

      <para>Around advice is the most general kind of advice. Most
      interception-based AOP frameworks, such as Nanning Aspects, provide only
      around advice.</para>

      <para>As Spring, like AspectJ, provides a full range of advice types, we
      recommend that you use the least powerful advice type that can implement
      the required behavior. For example, if you need only to update a cache
      with the return value of a method, you are better off implementing an
      after returning advice than an around advice, although an around advice
      can accomplish the same thing. Using the most specific advice type
      provides a simpler programming model with less potential for errors. For
      example, you don't need to invoke the <literal>proceed()</literal>
      method on the JoinPoint used for around advice, and hence can't
      fail to invoke it.</para>
      
      <para>In Spring 2.0, all advice is fully typed, so that you work with
	  advice parameters of the appropriates types (the type of the return value
	  from a method execution for example) rather than Object arrays.</para>

      <para>The pointcut concept is the key to AOP, distinguishing AOP from
      older technologies offering interception. Pointcuts enable advice to be
      targeted independently of the OO hierarchy. For example, an around
      advice providing declarative transaction management can be applied to a
      set of methods spanning multiple objects (such as all business operations
      in the service layer).</para>
    </sect2>

    <sect2 id="aop-introduction-spring-defn">
      <title>Spring AOP capabilities and goals</title>

      <para>Spring AOP is implemented in pure Java. There is no need for a
      special compilation process. Spring AOP does not need to control the
      class loader hierarchy, and is thus suitable for use in a J2EE web
      container or application server.</para>

      <para>Spring currently supports only method execution join points 
      (advising the execution of methods on Spring beans).
      Field interception is not implemented, although support for field
      interception could be added without breaking the core Spring AOP
      APIs. If you need to advise field
      access and update join points, consider a language such as AspectJ.</para>

      <para>Spring's approach to AOP differs from that of most other AOP
      frameworks. The aim is not to provide the most complete AOP
      implementation (although Spring AOP is quite capable); it is rather to
      provide a close integration between AOP implementation and Spring IoC to
      help solve common problems in enterprise applications.</para>

      <para>Thus, for example, Spring's AOP functionality is normally used in
      conjunction with a Spring IoC container. Aspects are configured using
      normal bean definition syntax (although this allows powerful
      "autoproxying" capabilities): a crucial difference from other AOP
      implementations. There are some things you can't do easily or
      efficiently with Spring AOP, such as advise very fine-grained objects.
      AspectJ is probably the best choice in such cases. However, our
      experience is that Spring AOP provides an excellent solution to most
      problems in J2EE applications that are amenable to AOP.</para>

      <para>Spring AOP will never strive to compete with AspectJ or
      AspectWerkz to provide a comprehensive AOP solution. We believe that
      both proxy-based frameworks like Spring and full-blown frameworks such
      as AspectJ are valuable, and that they are complementary, rather than in
      competition. Spring 2.0 seamlessly
      integrates Spring AOP and IoC with AspectJ, to enable all uses of AOP
      to be catered for within a consistent Spring-based application
      architecture. This integration does not affect the Spring AOP API or the
      AOP Alliance API; Spring AOP remains backward-compatible. See the following
      chapter for a discussion of the Spring AOP APIs.</para>
    </sect2>

    <sect2 id="aop-introduction-proxies">
      <title>AOP Proxies in Spring</title>

      <para>Spring defaults to using J2SE <emphasis>dynamic proxies</emphasis>
      for AOP proxies. This enables any interface or set of interfaces to be
      proxied.</para>

      <para>Spring can also use CGLIB proxies. This is necessary to proxy
      classes, rather than interfaces. CGLIB is used by default if a business
      object doesn't implement an interface. As it's good practice to
      <emphasis>program to interfaces rather than classes</emphasis>, business
      objects normally will implement one or more business interfaces.</para>

      <para>It is possible to force the use of CGLIB: we'll discuss this
      below, and explain why you'd want to do this.</para>

      <remark>Beyond Spring 2.0, Spring may offer additional types of AOP
      proxy, including wholly generated classes. This won't affect the
      programming model.</remark>
    </sect2>
  </sect1>

  <sect1 id="aop-ataspectj">
    <title>@AspectJ support</title>

    <para>xxx</para>

    <sect2>
      <title>Enabling @AspectJ Support</title>

    </sect2>

    <sect2>
      <title>Declaring an aspect</title>

    </sect2>

    <sect2>
      <title>Declaring a pointcut</title>

    </sect2>

    <sect2>
      <title>Declaring advice</title>

	   <sect3>
	   	<title>Advice parameters</title>
	   </sect3>

    </sect2>

    <sect2>
      <title>Introductions</title>

    </sect2>

    <sect2>
      <title>Aspect instantiation models</title>

    </sect2>

  </sect1>

  <sect1 id="aop-schema">
    <title>Schema-based AOP support</title>

    <para>xxx</para>

    <sect2>
      <title>Overview</title>

    </sect2>

    <sect2>
      <title>Declaring an aspect</title>

    </sect2>

    <sect2>
      <title>Declaring a pointcut</title>

    </sect2>

    <sect2>
      <title>Declaring advice</title>

	   <sect3>
	   	<title>Advice parameters</title>
	   </sect3>

    </sect2>

    <sect2>
      <title>Introductions</title>

    </sect2>

    <sect2>
      <title>Aspect instantiation models</title>

    </sect2>

    <sect2>
      <title>Advisors</title>

    </sect2>

    <sect2>
      <title>Forcing use of CGLIB</title>
		<!--  to be edited!!!  -->
		<sect3 id="aop-pfb-proxy-types-spring2">
			<title>JDK- and CGLIB-based proxies : Spring 2.0's <literal>&lt;aop-config/&gt;</literal></title>
			<para>
				Spring 2.0 introduced a new, streamlined style of XML configuration; one of
				the areas where this new style configuration is most visible is in the area
				of defining aspects, pointcuts and the like. All of the old-style configuration
				(as described above) continues to work in <emphasis>exactly</emphasis> the
				same way; this section highlights the differences between the old-style
				configuration and the new Spring 2.0 <literal>&lt;aop-config/&gt;</literal>
				configuration with regard to JDK- and CGLIB-based proxies.
			</para>
			<para>
				For the purpose of having something concrete to illustrate the proxying strategy
				semantics in Spring 2.0, find below a snippet of Spring XML 2.0 AOP configuration.
			</para>			
			<programlisting><![CDATA[<aop:config>
]]><lineannotation>&lt;!-- pointcut that matches beans that have methods starting with 'h' --&gt;</lineannotation><![CDATA[
    <aop:pointcut id="anyMethod" expression="execution(* *.h*(..)))"/>
    <aop:aspect id="the.advice" ref="advice">
        <aop:advice kind="before" method="intercept" pointcut-ref="anyMethod"/>
    </aop:aspect>
</aop:config>

]]><lineannotation>&lt;!-- the advice that is to be applied at picked out join points --&gt;</lineannotation><![CDATA[
<bean id="advice" class="x.y.Advice"/>

]]><lineannotation>&lt;!-- a class that doesn't implement any interfaces --&gt;</lineannotation><![CDATA[
<bean id="plain" class="x.y.PlainClass"/>

]]><lineannotation>&lt;!-- a class that implements exactly one interface --&gt;</lineannotation><![CDATA[
<bean id="one" class="x.y.OneInterface"/>]]></programlisting>
			<para>
				In the case of the above configuration (and assuming that both of the
				<literal>'plain'</literal> and <literal>'one'</literal> beans have methods
				starting with <literal>'h'</literal>), the <literal>'plain'</literal> bean
				will be proxied using CGLIB, whereas the <literal>'one'</literal> bean will
				be proxied using the JDK dynamic proxying mechanism.
			</para>
			<para>
				If one wants to force CGLIB-based proxying, one can specify this explicitly
				on the <literal>&lt;aop-config/&gt;</literal> element; to wit...
			</para>
			<programlisting><![CDATA[<aop:config ]]><emphasis role="bold">proxyTargetClass="true"</emphasis><![CDATA[>
    <aop:pointcut id="anyMethod" expression="execution(* *.h*(..)))"/>
    <aop:aspect id="the.advice" ref="advice">
        <aop:advice kind="before" method="intercept" pointcut-ref="anyMethod"/>
    </aop:aspect>
</aop:config>

]]><lineannotation>&lt;!-- rest of configuration as before --&gt;</lineannotation></programlisting>
			<para>
				Please note that this setting applies on a
				<emphasis>per <literal>&lt;aop-config/&gt;</literal></emphasis> basis; i.e. one
				can have multiple <literal>&lt;aop-config/&gt;</literal> elements,
				with some configured to force CGLIB-based proxying and some not to.
			</para>
		</sect3>

    </sect2>

  </sect1>

  <sect1 id="aop-mixing-styles">
    <title>Mixing Spring AOP aspects and @AspectJ aspects</title>

    <para>xxx</para>
	
  </sect1>

  <sect1 id="aop-using-aspectj">
  	<title>Using AspectJ with Spring applications</title>
  	
  	<sect2 id="aop-atconfigurable">
  		<title>Using AspectJ to dependency inject objects with Spring</title>
  	</sect2>

  	<sect2>
  		<title>Other Spring aspects for AspectJ</title>
  	</sect2>

  	<sect2>
  		<title>Configuring AspectJ aspects using Spring IoC</title>
  	</sect2>

  	<sect2>
  		<title>Using AspectJ Load-time weaving (LTW) with Spring applications</title>
  	</sect2>
  	
  </sect1>
  
  <sect1 id="aop-resources">
  	<title>Further Resources</title>
  	
  	    <para>
		The excellent <emphasis>AspectJ in Action</emphasis> by Ramnivas Laddad (Manning, 2003)
		comes highly recommended as an introduction to AOP; the focus of the book is on
		AspectJ, but a lot of general AOP themes are explored in some depth.
    	</para>
	
  </sect1>

</chapter>