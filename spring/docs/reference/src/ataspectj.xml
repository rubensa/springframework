<?xml version="1.0" encoding="UTF-8"?>
<chapter id="ataspectj">
  <title>AspectJ within Spring AOP</title>

  <sect1>
    <title>Overview: Using the AspectJ pointcut language with Spring
    AOP</title>

    <para>Spring AOP does not define a true pointcut expression language:
    merely convenient pointcuts that work with regular expressions.</para>

    <para>AspectJ provides a powerful, well thought out pointcut expression
    language.</para>

    <para>As of the AspectJ 5, the AspectJ weaver has been split from the
    <code>ajc</code> compiler, making it available to back a generic Spring
    AOP pointcut implementation. This
    implementation--AspectJExpressionPointcut--is added to Spring in Spring
    2.0. This enables Spring AOP to work with AspectJ pointcut
    expressions.</para>

    <para>Weaving is still proxy-based, using Spring AOP. This does impose
    some limitations: notably, only method execution joinpoints are supported.
    (It is impossible for a proxy-based framework to modify the callers of
    methods.) However, a valuable subset of AspectJ pointcut expressions are
    supported, including advanced features such as argument binding, pointcut
    composition and references to named pointcuts.</para>

    <para><remark>The annotation processing functionality described in this
    chapter is only available using AspectJ 5. Processing of the @AspectJ
    annotation-style syntax is only available using Java 5 as well as AspectJ
    5. Externalization of pointcut expression strings into XML does not
    require Java 5.</remark></para>
  </sect1>

  <sect1>
    <title>AspectJExpressionPointcut</title>

    <para>Demonstrate how it works</para>

    <para>Show with ProxyFactory programmatic creation</para>

    <para>Java 5</para>
  </sect1>

  <sect1>
    <title>Using AspectJ pointcut expressions in Spring XML</title>

    <para>TODO</para>
  </sect1>

  <sect1>
    <title>Using the AspectJ 5 @AspectJ annotation-style syntax in Spring
    AOP</title>

    <sect2>
      <title>Overview</title>

      <para>AspectJ 5 introduces a new annotation-style syntax, in addition to
      the traditional AspectJ syntax. With the annotation style syntax,
      aspects can be compiled by Javac.</para>

      <para>This syntax places pointcut expression strings in
      annotations.</para>

      <para><remark>Spring also supports AspectJ semantics, with pointcut
      expressions in Spring XML configuration files. This does not require
      Java 5. It is discussed in the next section. All coverage of actual
      advice, including argument binding, is equally relevant to this style of
      use: the semantics, are identical--only the location of the pointcut
      expression strings differs.</remark></para>
    </sect2>

    <sect2>
      <title>Simple advice types</title>

      <para>In Spring AOP, an advice is an implementation of an interface such
      as MethodInterceptor or MethodBeforeAdvice. A pointcut is an
      implementation of a Java interface that identifies whether given
      joinpoints match. An advice and pointcut--together making up an
      aspect--are held together in an Advisor.</para>

      <para>In @AspectJ, an aspect is a class annotated with an @Aspect
      annotation. It can contain advice methods that are annotated with
      AspectJ annotations such as @Before and @Around. Pointcuts are indicated
      by the value of the expression string (the default value attribute) held
      in these annotations. Classes annotated with @Aspect can also contain
      named pointcuts (methods annotated with the @Pointcut annotation), and
      introductions.</para>
    </sect2>

    <sect2>
      <title>Argument binding</title>

      <para>Major advantage</para>

      <para>Description</para>

      <para>Argument naming challenges: strategies</para>

      <para>Choices, fallbacks</para>
    </sect2>

    <sect2>
      <title>Special types</title>

      <para>AspectJ supports the binding of well-known types, such as the
      current JoinPoint, and returned value and thrown throwable (if
      applicable to the advice method).</para>

      <para>TODO full list</para>

      <para>Two special cases are the this and target values.</para>

      <para>This, when bound or retrieved from JoinPoint.getThis(), returns
      the current Spring AOP proxy. This allows invocation through the advice
      chain, or casting to an introduced interface.</para>

      <para>Target, when bound or retrieved, returns the current target. This
      is a plain POJO, not advised.</para>
    </sect2>

    <sect2>
      <title>Named pointcuts</title>

      <para>It is possible to reference named pointcuts in AspectJ aspects
      available on the class path, even if they were authored with traditional
      AspectJ syntax. This is accomplished using the FQN of the relevant
      pointcut. For example, here is an AspectJ aspect:</para>

      <programlisting>package org.springframework.aop.aspectj.annotation.annotation.support;

public aspect CommonPointcuts {

  public pointcut anyGetter() : execution(!void get*(..));
  
  public pointcut anyIntArg(int x) : args(x);

}</programlisting>

      <para>This aspect can be referenced as follows in @AspectJ
      syntax:</para>

      <programlisting>@Around(value="org.springframework.aop.aspectj.annotation.annotation.support.CommonPointcuts.anyIntArg(x)", argNames="x")
public void doubleArg(ProceedingJoinPoint pjp, int x) throws Throwable {
   pjp.proceed(new Object[]{x*2});
}</programlisting>
    </sect2>

    <sect2>
      <title>Aspect instantiation models</title>

      <para>Spring AOP "natively" supports two asoect instantiation
      models:</para>

      <para>Singleton</para>

      <para>Per-instance</para>

      <para>This correspond to the advisor or/and advice being a singleton or
      non-singleton in Spring IoC configuration.</para>

      <para>AspectJ supports a different, richer, set of instantiation models.
      However, in AspectJ as in Spring, the singleton instantiation (which is
      the default) is by far the most useful.</para>

      <para>The full range of AspectJ instantiation models is:</para>

      <para>singleton</para>

      <para>perthis</para>

      <para>pertarget</para>

      <para>pertypewithin</para>

      <para>percflow</para>

      <para>percflowbelow</para>

      <para>Spring can support the following aspect AspectJ instantiation
      models, and will automatically respect such annotations:</para>

      <para>singleton</para>

      <para>perthis</para>

      <para>pertarget</para>

      <para>pertypewithin</para>

      <para>If you use a binding type that is not supported, Spring will
      through an exception. Thus you cannot get unexpected semantics.</para>

      <para>TODO example of binding models</para>
    </sect2>

    <sect2>
      <title>Introductions</title>

      <para>Spring supports AspectJ-style introductions. These are
      significantly more elegant than the "native" Spring AOP equivalent,
      using DelegatingIntroductionInterceptor.</para>

      <para>For example, consider a simple interface expressing locking
      status:</para>

      <programlisting>public interface Lockable {

    void lock();

    void unlock();

    boolean locked();
}</programlisting>

      <para>Imagine that we wish to introduce this interface to make a number
      of objects Lockable. This means both making those objects implement the
      Lockable interface, and also changing the behaviour of their setter
      methods to throw an exception if they are locked.</para>

      <para>This is achieved using the following @AspectJ aspect. We assume an
      implementation of Lockable called DefaultLockable, although it is a
      common idiom for the aspect itself to declare an implementation in an
      inner class.</para>

      <programlisting>@Aspect
public class MakeLockable {

   @DeclareParents(value = "org.springframework..*",
      defaultImpl=DefaultLockable.class)
   public static Lockable mixin;
 
   @Before(value="execution(* set*(*)) &amp;&amp; this(mixin)", argNames="mixin")
   public void checkNotLocked(Lockable mixin) {
      if (mixin.locked()) {
         throw new IllegalStateException();
      }
   }
}</programlisting>

      <para>The field annotated with the DeclareParents element specifies an
      AspectJ type pattern to which the introduction will be apply. Note that
      this variable must be static. The defaultImpl attribute of the
      DeclareParents attribute is used to specify the class name to use to
      make the introduction.</para>

      <para>In this example, the before advice works in conjuction with the
      Lockable mixin to change the behaviour of setter methods to throw an
      exception if the object is locked. This is achieved through a pointcut
      expression identifying setters, and also binding "this" to an argument
      on the method advice, enabling the locking state to be tested.</para>

      <para>The argNames attribute is required on the before advice, to ensure
      correct argument binding (unless compiling with a debug flag).</para>
    </sect2>

    <sect2>
      <title>Mixing Spring AOP aspects and @AspectJ aspects</title>

      <para>There is no conflict between Spring AOP and @AspectJ aspects. All
      weaving is performed at runtime by Spring AOP, so as far as the core
      Spring AOP runtime is concerned, it is merely working with pointcuts and
      advices.</para>
    </sect2>

    <sect2>
      <title>Auto proxy creation and @AspectJ</title>

      <para>As you would expect, it is possible to use auto proxy creation
      with @AspectJ syntax. This is achieved using
      <literal>org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreator</literal>.
      This is a subclass of <literal>DefaultAdvisorAutoProxyCreator</literal>,
      meaning that it will also apply any Spring AOP advisors found in the
      application context to which it applies.</para>

      <para>Usage is very simple. Just add the following definition to your
      application context:<code></code><programlisting>&lt;bean 
  class="org.springframework.aop.aspectj.autoproxy.AspectJAutoProxyCreator" /&gt;</programlisting></para>

      <para>No configuration is usually required. See the documentation on
      DefaultAutoProxyCreator and superclasses for the regular configuration
      that applies to auto proxy creators.</para>

      <para>The effect will be that any @AspectJ aspects will automatically be
      recognized and applied, in addition to Spring advisors. You can use
      AspectJAutoProxyCreator anywhere you would use
      DefaultAutoProxyCreator.</para>

      <para>@AspectJ aspects can be dependency injected, and will not
      themselves be subjected to auto proxying, to avoid circular
      dependencies.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>AspectJ advice with pointcut expressions in Spring XML</title>

    <para>In this style of use, the semantics are identical to @AspectJ.
    However, pointcut expression strings are expressed in Spring XMl, rather
    than source-level annotations. This is usable without Java 5. It also
    provides the ability to invoke arbitrary methods on POJOs, with no
    requirements on the classes or methods to know anything about Spring or
    AspectJ.</para>

    <para>Advice methods follow AspectJ conventions.</para>

    <para>Use looks as follows:</para>

    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;


   &lt;aop:config&gt;
    &lt;aop:aspect id="beforeAdviceBindingTests" ref="testAspect"&gt;
      &lt;aop:advice 
         kind="after"
         method="oneIntArg"
         pointcut="execution(* setAge(int)) and args(age)"
      /&gt;
      &lt;aop:advice
         kind="after"
         method="oneObjectArg"
         pointcut="execution(* getAge()) and this(bean)"
      /&gt;
      &lt;aop:advice
          kind="afterReturning"
          method="oneObjectArg"
          pointcut="execution(* getDoctor()) and target(bean)"
      /&gt;
     &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;

   &lt;bean id="testAspect" class="org.springframework.aop.aspectj.AdviceBindingTestAspect"/&gt;

   &lt;bean id="testBean" class="org.springframework.beans.TestBean"/&gt;

&lt;/beans&gt;</programlisting>

    <para>Notes:</para>

    <itemizedlist>
      <listitem>
        <para>Import of the Spring 2.0 AOP namespace in the beans
        element</para>
      </listitem>

      <listitem>
        <para>The use of one &lt;aop:config&gt; element to configure a set of
        aspects that will automatically be applied using autoproxying</para>
      </listitem>

      <listitem>
        <para>Use of one or more &lt;aop:aspect&gt; element to specify the
        advice methods in a particular bean. The bean is identified using the
        ref element. In the previous example, for example, we could also
        dependency inject the "testAspect" bean.</para>
      </listitem>

      <listitem>
        <para>The use of one or more &lt;aop:advice&gt; elements beneath each
        &lt;aop:aspect&gt; element to identify the various advices that make
        up an aspect. Note the specification of kind, indicating what kind of
        advice this is. The other required attributes are "pointcut"--an
        AspectJ 5 pointcut expression string--and "method". Method is the name
        of a method. Note that overloaded methods will still work, based on
        the argumnets bound in the pointcut expression.</para>
      </listitem>

      <listitem>
        <para>Argument binding is handled through the pointcut
        expression.</para>
      </listitem>

      <listitem>
        <para>As with @AspectJ, it is possible for the method to take unbound
        arguments of well-known types such as JoinPoint. However, there is no
        requirement for the method to have any dependence on AspectJ.</para>
      </listitem>
    </itemizedlist>

    <para>The valid advice kinds follow AspectJ rules, and are:</para>

    <itemizedlist>
      <listitem>
        <para>before</para>
      </listitem>

      <listitem>
        <para>after</para>
      </listitem>

      <listitem>
        <para>afterReturning</para>
      </listitem>

      <listitem>
        <para>afterThrowing</para>
      </listitem>

      <listitem>
        <para>around</para>
      </listitem>
    </itemizedlist>

    <para>Each of these advice kinds corresponds to an @AspectJ annotation,
    which would include a pointcut expression.</para>

    <para>The following is an example of a class that could be used with the
    above XML:</para>

    <programlisting>public class AdviceBindingTestAspect {

  public void oneIntArg(int age) {
     this.collaborator.oneIntArg(age);
  }

  public void needsJoinPointStaticPart(JoinPoint.StaticPart tjpsp) {
     this.collaborator.needsJoinPointStaticPart(tjpsp.getSignature().getName());
  }
}
</programlisting>

    <para>The following shows an @AspectJ version, equivalent to the XML and
    Java code. The semantics are identical, and both can be used with
    Spring:</para>

    <programlisting>@Aspect
public class AdviceBindingTestAspect {

  @Before("execution(* setAge(int)) and args(age)")
  public void oneIntArg(int age) {
    this.collaborator.oneIntArg(age);
  }

  @After("execution(* getAge())")
  public void needsJoinPointStaticPart(JoinPoint.StaticPart tjpsp) {
    this.collaborator.needsJoinPointStaticPart(tjpsp.getSignature().getName());
  }
}</programlisting>

    <para>TODO show AspectJ style aspect also</para>
  </sect1>

  <sect1>
    <title>References</title>

    <para>AspectJ is very well documented. The <emphasis>AspectJ 5 Developers
    Notebook</emphasis>, included in the AspectJ 5 distribution, is an
    excellent starting point.</para>
  </sect1>
</chapter>