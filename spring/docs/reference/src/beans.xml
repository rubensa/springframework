<chapter id="beans">
	
	<title>Beans and the ApplicationContext</title>
	
	<sect1 id="beans-introduction">
		<title>Introduction</title>
		<para>
			Two of Spring's most elementary and important packages are the
			<literal>org.springframework.beans</literal> and <literal>org.springframework.context</literal>
			package. These packages provide the basis for the Spring Inversion of Control features, or
			Dependency Injection as people more recently call it (see <xref linkend="background-ioc"/> for
			some resources on that). The <literal>BeanFactory</literal> provides an advanced configuration 
			mechanism capable of managing beans of any kind of nature, using - potentially - any kind of 
			storage facility. The <literal>ApplicationContext</literal> builds on top of the 
			BeanFactory and adds other functionality such as integration with Springs AOP features, messaging
			(using <emphasis>i18n</emphasis>), the capability of having contexts inherit from other contexts
			and defining application-layer specific contexts, such as the <literal>WebApplicationContext</literal>.						
		</para>
		<para>
			In short, the <literal>BeanFactory</literal> provides the configuration framework and allows you to
			for example avoid the use of singletons, while the <literal>ApplicationContext</literal> adds
			more enterprise-centric, J2EE functionality to it.
		</para>
		<para>
			In order to get you started using the BeanFactory and the ApplicationContext we'll first introduce
			you to a couple of basic principles that might be handy to know of when using the BeanFactory
			and the ApplicationContext.
		</para>
		<para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						<emphasis>Bean definition</emphasis>: the description of a bean managed by the BeanFactory.
						Each BeanFactory contains bean definitions each describing the nature of a bean, its properties,
						the methods that need to be called upon initialization and destruction, whether or not
						the bean needs to be autowired and more things a like. The <literal>XmlBeanFactory</literal> for
						example is capalbe of reading bean definitions from an XML file, where properties, as well as
						collaborators and lifecycle methods are defined in XML
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Property editors</emphasis>: part of the JavaBeans specification by Sun is the
						concept of <literal>PropertyEditors</literal>. Property editors in Spring are used to
						convert properties of beans to human-readable String and vice versa. As the PropertyEditor
						JavaDOC (<ulink url="http://java.sun.com/j2se/1.4.2/docs/api/"/>) states, the <literal>getAsText()</literal>-method
						should return a human-readable String representing the property the editor is (so-called) editing.
						The <literal>setAsText()</literal>-method should be able to parse the same String and (using
						the <literal>setValue(Object)</literal>-method) set the resulting value of the property.
						PropertyEditors are heavily used in Spring, not only by for example the BeanFactory to transform
						the Strings defined in the XML containing beans to properties of those beans, but also by
						the MVC framework to convert request parameters submitted by a user after filling a form to
						properties of command objects that might be of some completely different type
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>BeanWrapper</emphasis>: an special class of which instances wrap a bean, managed
						BeanWrappers for example have features for setting and getting properties 
						from the beans they're wrapping. It's not likely you'll ever have to touch a BeanWrapper
						yourself, but it might be handy to know about them
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</sect1>
	
	<sect1 id="beans-basics">
		<title>BeanFactory and BeanDefinitions - the basics</title>
	
		<sect2 id="beans-definition">
			<title>The BeanDefinition</title>
			<para>
				As already stated in the introduction, bean definitions describe beans managed by a
				<literal>BeanFactory</literal> or <literal>ApplicationContext</literal>. Bean definitions
				contain the following information:
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							The beanclass, which is the actual implementation of the bean related to the
							bean definition
						</para>
					</listitem>
					<listitem>
						<para>
							Bean behavioral configuration elements, which state how the bean should
							behave in the container (i.e. prototype or singleton, autowiring mode, 
							dependency checking mode, initialization and destruction methods)
						</para>
					</listitem>
					<listitem>
						<para>
							Properties being configuration data for the bean. You could think of the number
							of connections to use in a bean that manages a connection pool
							(either specified as properties or as constructor arguments), or
							the class that should be used to create the connection pool
						</para>
					</listitem>
					<listitem>
						<para>
							Other beans your bean needs to do its work, i.e. <emphasis>collaborators</emphasis>
							(also specified as properties or as constructor arguments)
						</para>    					
					</listitem>
				</itemizedlist>
			</para>
			<para>
				In the list above, we mentioned the use of constructor arguments, as well as setters.
				Spring support two types of IoC, i.e. type 2 and type 3. What that means is that you
				use both constructor arguments to specify your dependencies and properties as well
				as setters and getters.			
			</para>
			<para>				
					The concepts listed above, directly translate to a set of elements the bean definition consists
					of. These elements are listed below, along with a reference to further documentation about each
					of them.
	
					<table frame="all">
						<title>Bean definition explanation</title>
						<tgroup cols="2">
							<colspec colname="c1" colwidth="2*"/>
							<colspec colname="c2" colwidth="4*"/>
							<thead>
								<row>
									<entry>Feature</entry>
									<entry>More info</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>class</entry>
									<entry><xref linkend="beans-factory-class"/></entry>
								</row>
								<row>
									<entry>singleton or prototype</entry>
									<entry><xref linkend="beans-factory-modes"/></entry>
								</row>
								<row>
									<entry>bean properties</entry>
									<entry><xref linkend="beans-factory-collaborators"/></entry>
								</row>
								<row>
									<entry>constructor arguments</entry>
									<entry><xref linkend="beans-factory-collaborators"/></entry>
								</row>
								<row>
									<entry>autowiring mode</entry>
									<entry><xref linkend="beans-factory-autowire"/></entry>
								</row>
								<row>
									<entry>dependency checking mode</entry>
									<entry><xref linkend="beans-factory-dependencies"/></entry>
								</row>
								<row>
									<entry>initialization method</entry>
									<entry><xref linkend="beans-factory-lifecycle"/></entry>
								</row>
								<row>
									<entry>destruction method</entry>
									<entry><xref linkend="beans-factory-lifecycle"/></entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</para>
		</sect2>        
    
		<sect2 id="beans-factory">
			<title>The BeanFactory</title>
			<para>
				The BeanFactory is the actual <emphasis>container</emphasis> (although we don't
				like to use the word container too much, since it kind of sounds quite heavy),
				containing and managing your beans. A BeanFactory loads BeanDefinitions and
				- upon request - instantiate one (or possible more) instances of the bean in 
				question and manages it by calling lifecycle methods.
			</para>
						
			<para>
				All of the features described in <xref linkend="beans-definition"/> will be 
				configurable for each of your beans using one of the out-of-the-box BeanFactory 
				implementations. In the example below we will use the most popular BeanFactory
				to illustrate the behavior, i.e. the <literal>XmlBeanFactory</literal>. More information 
				on the XmlBeanFactory and other implementations can be found further ahead.
			</para>
		</sect2>
		
		<sect2 id="beans-factory-class">
			<title>The bean class</title>
			<para>
				Of course you need to specify the actual class of your bean, that should be obvious.
				There's absolutely no special requirements to your beanclass, it does not have to
				implement a special interface to make it Spring compatible. Just specifying the bean class
				should be enough. However, dependending on what type of IoC you're going to use for that specific
				bean, you should have a default constructor.
			</para>
			<para>
				The BeanFactory cannot only manage beans, but is able to manage 
				virtually <emphasis>any</emphasis> class you want it to manage. Most people using Spring
				prefer to have actual beans (having just a default constructor and appropriate setters
				and getters modelled after the properties) in the BeanFactory, but it it's also possible
				to have more exotic non-bean-style classes in your BeanFactory. If for example you're having
				a legacy connection pool that absolutely does not adhere to the bean specification, no worries,
				Spring can manage it as well.
			</para>
			<para>
				Using the XmlBeanFactory you can specify your bean class as follows:
				<programlisting><![CDATA[
<bean id="exampleBean" class="examples.ExampleBean"/>
<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
				]]></programlisting>
			</para>
		</sect2>
		
		<sect2 id="beans-beanname">
			<title>The bean identifiers (<literal>id</literal> and <literal>name</literal>)</title>
			<para>
				Somehow of course you need to identifiy your beans. This can be done by a name
				or an id. The <literal>id</literal> is to be uniquely defined across all beans
				in a BeanFactory.
			</para>
		</sect2>
    	
    	<sect2 id="beans-factory-modes">
    		<title>To singleton or not to singleton</title>
    		<para>
    			Beans exist in two types, singletons and prototypes. When a bean is a singleton,
    			only one <emphasis>shared</emphasis> instance of the bean will be managed and all
    			requests for instances of that specific instances of bean will result in that one 
    			specific bean instance being returned.
    		</para>
    		<para>
    			The prototype mode of a bean results in <emphasis>creation of a new bean instance</emphasis>
    			every time a request for that specific bean is being done. This is ideal for situation
    			where for example each user needs an independent user object or something similar.
    		</para>
    		<para>
    			Beans exist in singleton mode by default, unless you specify otherwise. Keep in mind that by changing
    			the type to prototype, each request for a bean will result in a newly created bean and this
    			might not be what you actually want. So only change the mode to prototype when absolutely
    			necessary.
    		</para>
    		<para>
    			In the example below, two beans are declared of which one is defined as a singleton,
    			and the other one as a prototype. <literal>exampleBean</literal> is created each
    			and every time a client asks the BeanFactory for this bean, while <literal>yetAnotherExample</literal>
    			is only created one, a reference is returned each time a request for this bean is done.
				<programlisting><![CDATA[
<bean id="exampleBean" class="examples.ExampleBean" singleton="false"/>
<bean name="yetAnotherExample" class="examples.ExampleBeanTwo" singleton="true"/>
				]]></programlisting>
    		</para>
		</sect2>
	</sect1>
	
	<sect1 id="beans-dependencies">		
		<title>Properties, dependencies and autowiring</title>
		
		<sect2 id="beans-factory-collaborators">
			<title>Setting beans properties and collaborators</title>
			<para>
				Inversion of Control is already referred to as <emphasis>Dependency Injection</emphasis>.
				The basic principle is that beans themselves do not define who or what they're depending
				on, but instead, let the container do that for them. Also, the container <emphasis>injects</emphasis>
				the actual dependencies, as opposed to the Service Locator pattern, where the beans themselves
				do a lookup to resolve those dependencies. While not elaborating too much on the advantages
				of Dependency Injection, it might be obvious that code gets much cleaner and reacher a higher 
				grade of decoupling is much easier when beans themselves first of all do not lookup their
				dependencies themselves, but also do not even know where the actual dependencies are located
				and of what actual instance they are.
			</para>
			<para>
				The BeanFactory is capable of <emphasis>injecting</emphasis> dependencies into
				beans its manages. It does so using the <literal>BeanDefinition</literal> and the 
				<literal>PropertyEditors</literal> that
				are defined in the Spring Framework. We'll explain that further along using some
				examples of beans defined in the XML format. For now it might be handy to know that
				a BeanDefinition, collaborators and properties are specified using 
				<literal>PropertyValue</literal>-objects.
			</para>
			<para>
				The resolving of the dependencies is a little too complex to go get into it in depth here,
				the basic procedure is as follows:
				<orderedlist spacing="compact">
					<listitem>
						<para>Checking what the type of the property is (this can be a primitive-like type - 
							like int or String, a Collection - i.e. Map or List,
							a Class or any other type Spring supports by default. It can also be a collaborator). 
							Collaborators are other beans the BeanFactory must capable of resolving, in order
							words, other beans, also defined in the same BeanFactory (or, in case you're using the
							ApplicationContext, possibly in another application context)
						</para>
					</listitem>
					<listitem>
						<para>In case the bean isn't a collaborator that can be resolved from the BeanFactory,
							Spring uses its built-in (or manually added) PropertyEditors to transform the
							property to the type that was required (when using the XML format to define a bean
							that contains a setter with a <literal>Class</literal>-parameter, Spring uses the
							<literal>ClassEditor</literal> (more about PropertyEditors and how to manually
							add custom ones, can be found further ahead, TODODODODODODO reference!)
						</para>
					</listitem>
					<listitem>
						<para>In case of a collaborator, Sprign constructs a reference to the bean
							that is used later on when the bean is actually instantiated. You can trust
							Spring here that is sets the actual collaborator at the right moment
						</para>
					</listitem>
				</orderedlist>
			</para>
			<para>
				Dependency Injection (or Inversion of Control) exists in two major variants, both of 
				which Spring supports.
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							<emphasis>setter-based</emphasis> dependency injection is realized by calling
							setters on your beans after invoking an argumentless constructor to instantiate
							your bean. Beans defined in the BeanFactory that use setter-based dependency 
							injection are <emphasis>true JavaBeans</emphasis>, and not only for the sake
							of adhering a standard, Spring advocated to use setter-based dependency injection
							as much as possible
						</para>						
					</listitem>
					<listitem>
						<para>
							<emphasis>constructor-based</emphasis> dependency injection is realized by
							invoking a constructor with a number of arguments, each representing a collaborator
							or property. Though Spring advices to use setter-based dependency injection
							as much as possible, there might be beans around that just have constructors and that
							you want to use as well. Therefore we provided the constructor-based approach as well
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				Some examples:
			</para>
			<para>
				First, an example of using the BeanFactory for setter-based dependency injection. Below, there's a small part 
				of an XML file specifying bean definition. Also, you can find the actual bean itself, 
				having the appropriate setters declared.
				<programlisting><![CDATA[
<bean id="exampleBean" class="examples.ExampleBean">
	<property name="beanOne"><ref bean="anotherExampleBean"/></property>
	<property name="beanTwo"><ref bean="yetAnotherBean"/></property>
	<property name="integerProperty">1</property>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
				]]></programlisting>
				
				<programlisting><![CDATA[
public class ExampleBean {
	
	private AnotherBean beanOne;
	private YetAnotherBean beanTwo;
	private int i;
	
	public void setBeanOne(AnotherBean beanOne) {
		this.beanOne = beanOne;
	}
	
	public void setBeanTwo(YetAnotherBean beanTwo) {
		this.beanTwo = beanTwo;
	}
	
	public void setIntegerProperty(int i) {
		this.i = i;
	}	
}
				]]></programlisting>
				
				As you can see, setters have been declared to match against the properties specified in the XML file. (The properties
				from the XML file, directly relate to the <literal>PropertyValues</literal> object from the <literal>RootBeanDefinition</literal>)				
			</para>
			<para>
				Then, an example of using the BeanFactory for IoC type 3 (using constructors). Below you can find a snippet from
				an XML configuration file that specifies constructor arguments and the actual bean, specifying the constructor
				<programlisting><![CDATA[	
<bean id="exampleBean" class="examples.ExampleBean">
	<constructor-arg><ref bean="anotherExampleBean"/></constructor-arg>
	<constructor-arg><ref bean="yetAnotherBean"/></constructor-arg>
	<constructor-arg>1</constructor-arg>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
				]]></programlisting>
				
				<programlisting><![CDATA[
public class ExampleBean {

	private AnotherBean beanOne;
	private YetAnotherBean beanTwo;
	private int i;
	
	public ExampleBean(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
		this.beanOne = anotherBean;
		this.beanTwo = yetAnotherBean;
		this.i = i;
	}
}
				]]></programlisting>
				
				As you can see, the constructor arguments specified in the bean definition will be used to pass in as
				arguments to the constructor of the <literal>ExampleBean</literal>.	
			</para>
			
		</sect2>
		
		<sect2 id="beans-factory-autowire">	
			<title>Autowiring collaborators</title>
			<para>
				Spring has autowire capabilities, which means it's possible to automatically let Spring
				resolve collaborators (other beans) for you bean by inspecting the BeanFactory. The autowiring
				functionality has four modes. Autowiring is specified <emphasis>per</emphasis> bean and 
				can thus be enabled for a couple of beans, while other beans won't be autowired.
				When using autowiring, there might be no need for specifying properties or constructor 
				arguments<footnote>
					<para>See <xref linkend="beans-factory-collaborators"/></para>
				</footnote>
				
				<table frame="all">
		            <title>Autowiring modes</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="1*"/>
		                <colspec colname="c2" colwidth="5*"/>
		                <thead>
		                    <row>
		                        <entry>Mode</entry>
		                        <entry>Explanation</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry>no</entry>
				            	<entry>No autowiring at all. This is the default value and
				            		it's discouraged to change this for large applications,
				            		since specifying your collaborators yourself gives you a feeling
				            		of what you're actually doing and is a great way of
				            		somewhat documenting the structure of your system</entry>
				            </row>
				            <row>
								<entry>byName</entry>
								<entry>This option will inspect the BeanFactory and look for a bean
									named exactly the same as the property which needs to be autowired.
									So in case you have a collaborator on a BeanDefinition Cat which is called
									dog (so you have a setDog(Dog) method), Spring will look for a BeanDefinition
									named <literal>dog</literal> and use this as the collaborator
								</entry>
				            </row>
				            <row>
				            	<entry>byType</entry>
				            	<entry>This option can be found in some other IoC containers as well and gives
					            	you the ability to resolve collaborators by type instead of by name. Suppose
					            	you have a BeanDefinition with a collaborator typed <literal>DataSource</literal>,
					            	Spring will search the entire bean factory for a bean definition of type
					            	DataSource and use it as the collaborator. <emphasis>If 0 (zero) or more than
					            	1 (one) bean definitions of the desired exist in the BeanFactory, a failure
					            	will be reported and you won't be able to use autowiring for that specific bean</emphasis>
				            	</entry>
				            </row>
				        </tbody>
			        </tgroup>
		        </table>
		        <emphasis>Note: like already mentioned, for larger application it's discourage to use
		        autowiring beacuse it removes the transparency and the structure from your collaborating
		        classes.</emphasis>
			</para>
		</sect2>
		
		<sect2 id="beans-factory-dependencies">
			<title>Checking for dependencies</title>
			<para>
				Spring also offers the capability for checking required dependencies of your beans.
				This feature might come in handy when certain properties really need to be set and
				when you can't provide default values (which is an often used approach). Dependency
				checking can be done in three different ways. Dependency checking can also be
				enabled and disabled per bean, just as the autowiring functionality. The default is
				to <emphasis>not</emphasis> check dependencies.
				<table frame="all">
		            <title>Dependency checking modes</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="1*"/>
		                <colspec colname="c2" colwidth="5*"/>
		                <thead>
		                    <row>
		                        <entry>Mode</entry>
		                        <entry>Explanation</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry>simple</entry>
				            	<entry>Dependency checking is done for primitive types and 
					            	collections (this means everything except collaborators)
					            </entry>
					        </row>
				            <row>
								<entry>object</entry>
								<entry>Dependency checking is done for collaborators</entry>
							</row>
				            <row>
				            	<entry>all</entry>
				            	<entry>Dependecny checking is done for both collaborators and
				            		primitive types and collections
				            	</entry>
				            </row>
				        </tbody>
			        </tgroup>
		        </table>
			</para>
		</sect2>
	</sect1>
		
	<sect1 id="beans-factory-nature">
	   	<title>Customizing the nature of a bean</title>
	   	
	   	<sect2 id="beans-factory-lifecycle">
	   		<title>Lifecycle interfaces</title>
	   		
			<para>
				Spring provides a couple of marker interfaces to change the behavior of your
				bean in the BeanFactory. They include <literal>InitializingBean</literal> and
				for example <literal>DisposableBean</literal>. Implementing those will for instance
				result in the BeanFactory calling <literal>afterPropertiesSet()</literal> for the former and
				<literal>destroy()</literal> for the latter to allow you to do things upon initialization and destruction.	    		
			</para>
			<para>
				Internally, Spring uses <literal>BeanPostProcessors</literal> to process any marker
				interfaces it can find and call the appropriate methods. If you need custom features
				or other lifecycle behavior Spring doesn't offer out-of-the-box, you can implement
				a <literal>BeanFactoryPostProcessor</literal> yourself. More information about this
				can be found in <xref linkend="beans-factory-postprocessor"/>.
			</para>
			<para>
				All the different lifecycle marker interfaces are described below. In one of the
				appendices, you can find diagram as to how Spring manages beans and how those
				lifecycle features change the nature of your beans and how they are managed.
			</para>
	   	
			<sect3 id="beans-factory-lifecycle-initializingbean">
					<title>InitializingBean / <literal>init-method</literal></title>
					<para>
						The <literal>org.springframework.beans.factory.InitializingBean</literal> gives
						you the ability the do initialization work after all necessary properties on a
						bean are set by the BeanFactory. The InitializingBean interface specifies exactly
						one method:
						<itemizedlist spacing="compact">
							<listitem>
								<para>
									<literal>void afterPropertiesSet()</literal>: called after all
									properties have been set by the beanfactory. This method enables you
									to do checking if all necessary properties have been set correctly, or
									to perform initialization work. You can throw <emphasis>any</emphasis>
									exception to indicate misconfiguration, initialization failures, etcetera
								</para>
							</listitem>
						</itemizedlist>
					</para>
					
					<para>
						<emphasis>Note: generally, the use of the <literal>InitializingBean</literal> can
						be avoided (and by some people is discouraged). The beans package provides support
						for a generic init-method, given to the beandefinition in the beanconfiguration store
						(may it be XML, properties-files or a database).</emphasis>
						
					</para>
					<para>
					<programlisting><![CDATA[
<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init()"/>

public class ExampleBean {
	public void init() {
		// do some initialization work
	}
}
					]]></programlisting>
					
					Is exactly the same as:
					
					<programlisting><![CDATA[
<bean id="exampleInitBean class="examples.AnotherExampleBean"/>

public class AnotherExampleBean implements InitializingBean {
	public void afterPropertiesSet() {
		// do some initialization work
	}
}
					]]></programlisting>
					</para>
				</sect3>
			
			
			
				<sect3 id="beans-factory-lifecycle-disposablebean">
					<title>DisposableBean / <literal>destroy-method</literal></title>
					<para>
						The <literal>org.springframework.beans.factory.DisposableBean</literal> interface
						provides you with the ability to get a callback when a beanfactor is destroyed.
						The DisposableBean interface specifies one method:
						<itemizedlist spacing="compact">
							<listitem>
								<para>
									<literal>void destroy()</literal>: called on destruction of
									the beanfactory. This allows you to release any resources you are
									keeping in this bean (like database connections). You can throw
									an exception here, however, it will not stop the destruction of the bean
									factory. It will get logged though.
								</para>
							</listitem>
						</itemizedlist>
					</para>
					<para>
						<emphasis>Note: generally, the use of the <literal>DisposableBean</literal> can
						be avoided (and by some people is discouraged). The beans package provides support
						for a generic destroy-method, given to the beandefinition in the beanconfiguration store
						(may it be XML, properties-files or a database). For more information about this
						feature, see the next section)</emphasis>
					</para>
					<para>
					<programlisting><![CDATA[
<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="init()"/>

public class ExampleBean {
	public void destroy() {
		// do some destruction work (like closing connection)
	}
}
					]]></programlisting>
					
					Is exactly the same as:
					
					<programlisting><![CDATA[
<bean id="exampleInitBean class="examples.AnotherExampleBean"/>

public class AnotherExampleBean implements DisposableBean {
	public void destroy() {
		// do some destruction work
	}
}
					]]></programlisting>
					</para>
				</sect3>
			</sect2>		
			
			<sect2 id="beans-factory-aware">
				<title>Knowing who you are</title>				
			
				<sect3 id="beans-factory-aware-beanfactoryaware">
					<title>BeanFactoryAware</title>
					<para>
						The <literal>org.springframework.beans.factory.BeanFactoryAware</literal> interface
						gives you the ability to get a reference to the BeanFactory that manages the bean
						that implements the BeanFactoryAware interface. This feature allows for implementing
						beans to look up their collaborators in the beanfactory. The interface specifies one
						method:
						<itemizedlist spacing="compact">
							<listitem>
								<para>
									<literal>void setBeanFactory(BeanFactory)</literal>: method that will
									be called <emphasis>after the initialization methods</emphasis>
									(<literal>afterPropertiesSet</literal> and the init-method).
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect3>
				
				<sect3 id="beans-factory-aware-beannameaware">
					<title>BeanNameAware</title>
					<para>
						The <literal>org.springframework.beans.factory.BeanNameAware</literal>
						interface gives you the ability to let the BeanFactory set the name
						of the bean on the bean itself. In case you need to know what your name is,
						implement this interface
						<itemizedlist spacing="compact">
							<listitem>
								<para>
									<literal>void setBeanName(String)</literal>: method which
									will be called to let the bean know what its name is
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</sect3>
			</sect2>
			
			<sect2 id="beans-factory-lifecycle-factorybean">
	    		<title>FactoryBean</title>
		    	<para>
		    		The <literal>org.springframework.beans.factory.FactoryBean</literal> is to be implemented
		    		objects that <emphasis>are themselves factories</emphasis>. The BeanFactory interface
		    		provides three method:
					<itemizedlist spacing="compact">
						<listitem>
							<para>
								<literal>Object getObject()</literal>: has to return an instance of
								the object this factory creates. The instance can possibly be shared
								(depending on this factory providing singleton or prototypes).
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>boolean isSingleton()</literal>: has to return <literal>true</literal>
								if this FactoryBean returns singletons, <literal>false</literal> otherwise
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>Class getObjectType()</literal>: has to return either
								the object type returned by the <literal>getObject()</literal> method or
								<literal>null</literal> if the type isn't known in advance
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</sect2>
			
		</sect1>
		
		<sect1 id="beans-factory-customizing">
			<title>Customizing the BeanFactory (advanced stuff)</title>	
			<para>
				When in need for special behavior for the BeanFactory you need to consult the
				<literal>org.springframework.beans.factory.config</literal>-package, which
				should provide you all the things you need in such a case. Using the config
				package you can for instance define a properties file of which the property-entries
				are used as replacements values in the BeanFactory. Also, you can implement custom
				behavior (like adding custom editors) using the BeanFactoryPostProcessor. Each of the
				features the config-package offers is described below:
			</para>
			<sect2 id="beans-factory-postprocessor">
				<title>The <literal>BeanFactoryPostProcessor</literal></title>
				<para>
					The BeanFactoryPostProcessor is a special bean you can define in your
					BeanFactory. The BeanFactory - while initializing - checks if any
					BeanFactoryPostProcessors are present and if so, it give them a change to
					override any values, beans, bean definitions or other bean factory specific
					stuff. The BeanFactoryPostProcessor can for instance be used to add custom editors
					(as also mentioned in <xref linkend="beans-beans-conversion"/>). Some
					out-of-the-box post processors are available, like the <literal>PropertyResourceConfigurer</literal>
					and the <literal>PropertyPlaceHolderConfigurer</literal>, both described below.
				</para>
			</sect2>
			<sect2 id="beans-factory-placeholderconfigurer">
				<title>The <literal>PropertyPlaceHolderConfigurer</literal></title>
				<para>
					The <literal>PropertyPlaceHolderConfigurer</literal> is an excellent solution
					when you want to externalize a few properties from a file containing bean definitions.
					Say you want to let a guy responsible for deploying applications just fill in
					database URLs and usernames and passwords. You could of course let him change the
					XML file containing bean definitions, but that would be risky. Instead, use the
					<literal>PropertyPlaceHolderConfigurer</literal> to - at runtime - replace those
					properties by values from a properties file.
				</para>
				<para>
					In the example below, a datasource is defined, next to a <literal>PropertyPlaceHolderConfigurer</literal>.
					At runtime, the BeanFactory will encounter this post processor and let it
					override any values from the beans defined in the XML file. This specific
					post processor will inspect the jdbc.properties file and replace all values
					it can find in the BeanFactory with the values from the properties file:
				</para>
				<programlisting><![CDATA[
<bean id="propertyConfigurer" class="org.sf.beans.config.PropertyPlaceholderConfigurer">
	<property name="location"><value>/WEB-INF/jdbc.properties</value></property>
</bean>

<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
	<property name="driverClassName"><value>${jdbc.driverClassName}</value></property>
	<property name="url"><value>${jdbc.url}</value></property>
	<property name="username"><value>${jdbc.username}</value></property>
	<property name="password"><value>${jdbc.password}</value></property>
</bean>
				]]></programlisting>
				<programlisting><![CDATA[
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
				]]></programlisting>
								
			</sect2>
		
		<sect2 id="beans-factory-client">
			<title>Clients interacting with the factory</title>
			<para>
				The client-side view of the BeanFactory is surprisingly simple. The 
				<literal>BeanFactory</literal> interface four methods for clients to interact with
				it:
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							<literal>Object getBean(String)</literal>: returns an instance of the
							bean registered under the given name. Depending on how the bean was
							configured by the beanfactory configuration, a singleton and thus shared
							instance will be returned, or a newly created bean. A 
							<literal>BeansException</literal> will be thrown when either the
							bean could not be found (in which it'll be a <literal>NoSuchBeanDefinitionException</literal>),
							or an exception occured while instantiated and preparing the bean
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>Object getBean(String,Class)</literal>: returns a
							bean, registered under the given name. The bean returned will be cast
							to the given Class. If the bean could not be cast, corresponding exceptions
							will be thrown (<literal>BeanNotOfRequiredTypeException</literal>). Furthermore,
							all rules of the getBean(String) method apply (see above)
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>boolean isSingleton(String)</literal>: determines whether or not
							the beandefinition registered under the given name is a singleton or
							a prototype. If the beandefinition could corresponding the given name
							could not ben found, and exception will be thrown 
							(<literal>NoSuchBeanDefinitionException</literal>)							
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>String[] getAliases(String)</literal>: returns
							the aliases configured for this bean (TODO: WHAT IS THIS :)							
						</para>
					</listitem>					
				</itemizedlist>
			</para>
		</sect2>
		
		<sect2 id="beans-factory-diagrams">
			<title>Lifecycle of a bean in the BeanFactory</title>
			<para>
				This section describes the lifecycle of a bean in the BeanFactory, 
				some of the basic characteristics of events happening in the BeanFactory as well
				as the different types of beans.
			</para>
			
			<sect3 id="beans-factory-diagrams-lifecycle">
				<title>The basic lifecycle of a bean</title>
				<para>
					The lifecycle of a bean begins with a bean definition, for instance defined
					in XML or a properties file. The first step is the calling of the default constructor:
					
					<orderedlist spacing="compact">
						<listitem>
							<para>
								default constructor
							</para>
						</listitem>
					</orderedlist>

				</para>
				<para>
					The second step is the initialization process in which you can prepare your bean
					for use.
					<orderedlist spacing="compact" continuation="continues">
						<listitem>
							<para>
								the autowiring process in which any possible collaborators that can
								be automatically resolved, will be set (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								checking of dependencies, which means that if dependencies are satisfied
								(i.e. they are <literal>null</literal>), an <literal>UnsatisfiedDependencyException</literal>
								will be thrown. (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								property setting, which means that all properties defined with the bean definition
								in for instance an XML file, will be set on the bean
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>afterPropertiesSet()</literal> is called. This method is specified by the
								<literal>InitializingBean</literal>, and thus will only be called if your bean 
								implements this interface (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								the extra initialization method will be called that might have been
								specified with the bean definition (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								if your bean a <literal>BeanFactoryAware</literal> the 
								<literal>setBeanFactory()</literal> method will now be called enabling
								the bean to have access to the BeanFactory (TODO: reference)
							</para>
						</listitem>
					</orderedlist>
				</para>
				<para>
					Right now, your bean is ready for use. Calls to <literal>BeanFactory.getBean()</literal>
					with the name of the bean, will result in an instance of that bean being returned.
					Depending on whether or not this bean is a singleton, a shared instance will be returned.
					More information on consequences for singletons can be found below.
				</para>
				<para>
			        When the <literal>BeanFactory</literal> gets destroyed (for instance when the
			        application server shuts down, the destruction process of the BeanFactory
			        will try to destroy all beans that it still knows. The destruction process 
			        <emphasis>only comprises singletons beans</emphasis>.
			        
			        <orderedlist spacing="compact" continuation="continues">
			        	<listitem>
			        		<para>
			        			If your bean implements <literal>DisposableBean</literal> the
			        			BeanFactory will call <literal>destroy()</literal>
			        		</para>
			        	</listitem>
			        	<listitem>
			        		<para>
			        			If you bean definition includes a destroy method declaration,
			        			this method will be called as well
			        		</para>
			        	</listitem>
			        </orderedlist>
			    </para>
			    <para>
			    	A diagram illustrating the lifecycle of a bean:
			    </para>
				<mediaobject>
					<imageobject role="fo">
    		        	<imagedata fileref="images/bean-lifecycle-overview.gif" format="GIF" align="center"/>
		        	</imageobject>
		        </mediaobject>
			</sect3>
			
		</sect2>
				
	</sect1>
	
	<sect1 id="beans-factoryimpl">
		<title>BeanFactory implementations</title>
		<para>
			A couple of implementations of the BeanFactory come out-of-the-box. The
			<literal>XmlBeanFactory</literal> supports a bean definitions to be specified
			in XML files and the <literal>ListableBeanFactory</literal> supports bean definitions
			in the form of properties files. Most people use the XmlBeanFactory. However, implementing
			your own BeanFactory that supports bean definition in a database should not be to big an
			issue. Let's first discuss the XmlBeanFactory and the ListableBeanFactory and their features.
		</para>
		<para>
			Basically the two BeanFactory implementations Spring comes with provide all the
			features described above, like specifying the lifecycle methods, specifying whether or
			not to do autowiring, etcetera. The only way they differ is the way the configuration
			data (the bean definitions) are stored.
		</para>
		
		<sect2 id="beans-factoryimpl-xml">
			<title>Bean definitions specified in XML (<literal>XmlBeanFactory</literal>)</title>
			<para>
				One of the implementations of the BeanFactory is the 
				<literal>XmlBeanFactory</literal> (located in the package
				<literal>org.springframework.beans.factory.xml</literal>) which
				offers you the ability to specify bean definition in XML files as the name
				might have already told you. Spring comes with a DTD to do validation of the
				XML you're writing to specify beans in order to make things a bit more easy.
				The DTD is quite well documented so you should find everything you need in there
				as well. Here we will discuss the format shortly and provide some examples.
			</para>
			
			<para>
				The root of a Spring XML bean definition document 
				is a <literal>&lt;beans&gt;</literal> element. The <literal>&lt;beans&gt;</literal> element 
				contains one or more <literal>&lt;bean&gt;</literal> definitions. We normally specify 
				the class and properties of each bean definition. We must also specify the id, 
				which will be the name that we'll use this bean with in our code (see a previous section about 
				<link linkend="beans-factory-client">clients interacting</link> with the BeanFactory
				for more information. An initialization method as described earlier as well the destruction
				method can be specified as attributes of the <literal>&lt;bean&gt;</literal> element.
				The autowiring functionality as well as the de dependency checking can also be specified
				using attributes of the same element. Furthermore properties and collaborators can be 
				specified using	nested <literal>&lt;property&gt;</literal> elements. 
				In the following example, we use a BasicDataSource from the Jakarta Commons DBCP 
				project. This class (like many other existing classes) can easily be used in a 
				Spring bean factory, as it offers JavaBean-style configuration. 
				The close method that needs to be called on shutdown can be registered via 
				Spring's <quote>destroy-method</quote> attribute, to avoid the need for 
				BasicDataSource to implement any Spring interface (in this case that would
				be <literal>DisposableBean</literal> mentioned earlier in the section about
				lifecycle features).
				
				<programlisting><![CDATA[
<beans>
	<bean id="myDataSource"
		class="org.apache.commons.dbcp.BasicDataSource"
		destroy-method="close">
		<!-- results in a setDriverClassName(String) call -->
		<property name="driverClassName">
			<value>com.mysql.jdbc.Driver</value>
		</property>
		<property name="url">
			<value>jdbc:mysql://localhost:3306/mydb</value>
		</property>
		<property name="username">
			<value>root</value>
		</property>
	</bean>
</beans>
				]]></programlisting>
				Just as an destruction method is specified using the <literal>destroy-method</literal>
				attribute, we could specify a initialization method using the
				<literal>init-method</literal> attribute.				
			</para>
			
			<para>
				To specify properties and collaborators in XML files you have to use nested
				&lt;property&gt; elements. You have already seen the setting of 'primitive'
				properties in the example about, the setting of collaborators is done using
				the nested <literal>&lt;ref&gt;</literal> element.
				<programlisting><![CDATA[
<beans>
...
	<bean id="exampleDataAccessObject"
		class="example.ExampleDataAccessObject">
		<!-- results in a setDataSource(BasicDataSource) call -->
		<property name="dataSource">
			<ref bean="myDataSource"/>
		</property>
	</bean>
</beans>
				]]></programlisting>
				As you can see below, we're using the Commons DBCP datasource from the previous
				example here as a collaborator and we're specifying if using a &lt;ref bean&gt;
				element. References exist in three types that specify whether or not to search the
				collaborator in the same XML file or in some other XML file (multiple XML files is
				covered further along):
				<itemizedlist spacing="compact">
					<listitem>
						<para><literal>bean</literal>: tries to find the collaborator in either
							the same XML file or in some other XML file that has also been specified
						</para>
					</listitem>
					<listitem>
						<para><literal>local</literal>: tries to find the collaborator in the current
							XML file. This attribute is an <literal>XML IDREF</literal> so it 
							<emphasis>has</emphasis> to exist, otherwise validation will fail
						</para>
					</listitem>
					<listitem>
						<para><literal>external</literal>: explicitly states to find the bean
							 in another XML file and does not search in the current XML file
						</para>
					</listitem>
				</itemizedlist>
			</para>
			
			<para>
				There's a couple of possibilities for specifying more complex properties
				such as lists, properties object and maps. The following examples show this
				behavior:
				<programlisting><![CDATA[
<beans>
...
	<bean id="moreComplexObject"
		class="example.ComplexObject">
		<!-- results in a setPeople(java.util.Properties) call -->
		<property name="people">
			<props>
				<prop key="HaaryPotter">The magic property</prop>
				<prop key="JerrySeinfeld">The funny property</prop>
			</props>
		</property>
		<!-- results in a setSomeList(java.util.List) call -->
		<property name="someList">
			<list>
				<value>a list element followed by a reference</value>
				<ref bean="myDataSource"/>
			</list>
		</property>
		<!-- results in a setSomeMap(java.util.Map) call -->
		<property name="someMap">
			<map>
				<entry key="yup an entry">
					<value>just some string</value>
				</entry>
				<entry key="yup a ref">
					<ref bean="myDataSource</ref>
				</entry>
			</map>
		</property>
	</bean>	
</beans>
				]]></programlisting>
			</para>
			<para>
				<emphasis>Note that the value of a Map entry can also again be a list or another
				map.</emphasis>
			</para>
			
		</sect2>
    </sect1>
    
    
    <sect1 id="beans-beans">
    	<title>Bean manipulation and the <literal>BeanWrapper</literal></title>
    	<para>
    		The <literal>org.springframework.beans</literal> package adheres to the JavaBeans standard
    		provided by Sun. A JavaBean is simply a class with a default no-argument constructor, which
    		follows a naming conventions where a property named <literal>prop</literal> has a setter
    		<literal>setProp(...)</literal> and a getter <literal>getProp()</literal>. For more
    		information about JavaBeans and the specification, please refer to Sun website
    		(<ulink url="http://java.sun.com/products/javabeans/">java.sun.com/products/javabeans</ulink>).
    	</para>
    	<para>
    		One quite important concept of the beans package is the <literal>BeanWrapper</literal>
    		interface and its corresponding implementation (<literal>BeanWrapperImpl</literal>).
    		As quoted from the JavaDoc,  the BeanWrapper offers functionality to set and get property 
    		values (individually or in bulk), get property descriptors and query the readability and
    		writability of properties. Also, the BeanWrapper offers support for
    		nested properties, enabling the setting of properties on subproperties to an unlimited
    		depth. Then, the BeanWrapper support the ability to add standard
    		JavaBeans <literal>PropertyChangeListeners</literal> and <literal>VetoableChangeListeners</literal>,
    		without the need for supporting code in the target class. Last but not least, the
    		BeanWrapper provides support for the setting of indexed properties.	The BeanWrapper 
    		usually isn't used by application code directly, but by the <literal>DataBinder</literal> 
    		and the <literal>BeanFactory</literal>.
    	</para>
    	<para>
    		The way the BeanWrapper works is partly indicated by its name: 
    		<emphasis>it wraps a bean</emphasis> to perform action on that bean, like setting
    		and retrieving properties.
    	</para>
    	
    	<sect2 id="beans-beans-conventions">
    		<title>Setting and getting basic and nested properties</title>
    		<para>
    			Setting and getting properties is done using the <literal>setPropertyValue(s)</literal>
    			<literal>getPropertyValue(s)</literal> methods that both come with a couple of
    			overloaded variants. They're all described in more detail in the JavaDoc Spring
    			comes with. What's important to know that there's a couple of conventions for 
    			indicating properties of an object. A couple of examples:
				<table frame="all">
		            <title>Examples of properties</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="1*"/>
		                <colspec colname="c2" colwidth="5*"/>
		                <thead>
		                    <row>
		                        <entry>Expression</entry>
		                        <entry>Explanation</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry><literal>name</literal></entry>
				            	<entry>Indicates the property <literal>name</literal> corresponding to the
				            		methods <literal>getName()</literal> or <literal>isName()</literal> and
				            		<literal>setName()</literal>
				            	</entry>
				            </row>
				            <row>
				            	<entry><literal>account.name</literal></entry>
				            	<entry>Indicates the nested property <literal>name</literal> of the property
					            	<literal>account</literal> corresponding e.g. to the methods
					            	<literal>getAccount().setName()</literal> or <literal>getAccount().getName()</literal>
					            </entry>
				            </row>
				            <row>
				            	<entry><literal>account[2]</literal></entry>
				            	<entry>Indicates the <emphasis>third</emphasis> element of the indexed property
					            	<literal>account</literal>. Indexed properties can be of type <literal>array</literal>,
					            	<literal>list</literal> or other <emphasis>natural ordered</emphasis> collection
					            </entry>
				            </row>
				        </tbody>
			        </tgroup>
		        </table>
    		</para>
    		
			<para>
				Below you'll find some examples of working with the BeanWrapper to get
				and set properties.
			</para>
    		<para><emphasis>Note: this part is not important to you if you're not planning to
    			work with the BeanWrapper directly. If you're just using the 
    			<literal>DataBinder</literal> and the <literal>BeanFactory</literal> and their
    			out-of-the-box implementation, don't mind reading this and go on with
    			reading about <literal>PropertyEditors</literal>.</emphasis>
    		</para>
       		<para>    
       			Consider the following two classes:			
				<programlisting><![CDATA[
public class Company {
	private String name;
	private Employee managingDirector;
	
	public String getName()	{ 
		return this.name; 
	}
	public void setName(String name) { 
		this.name = name; 
	} 
	public Employee getManagingDirector() { 
		return this.managingDirector; 
	}
	public void setManagingDirector(Employee managingDirector) {
		this.managingDirector = managingDirector;							
	}
}
				]]></programlisting>
				<programlisting><![CDATA[
public class Employee {
	private float salary;
	
	public float getSalary() {
		return salary;
	}						
	public void setSalary(float salary) {
		this.salary = salary;
	}
}					
				]]></programlisting>
			</para>
			<para>
				The following code snippets show some examples of how to retrieve and
				manipulate some of the properties of instantiated:
				<literal>Companies</literal> and <literal>Employees</literal>
				<programlisting><![CDATA[
Company c = new Company();
BeanWrapper bwComp = BeanWrapperImpl(c);
// setting the company name...
bwComp.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue v = new PropertyValue("name", "Some Company Inc.");
bwComp.setPropertyValue(v);

// ok, let's create the director and tie it to the company:
Employee jim = new Employee();
BeanWrapper bwJim = BeanWrapperImpl(jim);
bwJim.setPropertyValue("name", "Jim Stravinsky");					
bwComp.setPropertyValue("managingDirector", jim);

// retrieving the salary of the managingDirector through the company
Float salary = (Float)bwComp.getPropertyValue("managingDirector.salary");
				]]></programlisting>				
			</para>
    	</sect2>
    	
    	<sect2 id="beans-beans-conversion">
    		<title>Built-in <literal>PropertyEditors</literal>, converting types</title>
    		<para>
    			Spring heavily uses the concept of <literal>PropertyEditors</literal>.
    			Sometimes it might be handy to be able to represent properties in a different
    			way than the object itself. For example, a date can be represented in a human
    			readable way, while we're still able to convert the human readable form back to
    			the original date (or even better: convert any date entered in a human readable form,
    			back to Date objects). This behavior can be achieved by <emphasis>registering
    			custom editors</emphasis>, of type <literal>java.beans.PropertyEditor</literal>.
    			Registering custom editors to a BeanWrapper gives it the knowledge of how to convert
    			properties to the desired type. Read more about PropertyEditors in the JavaDoc of the
    			<literal>java.beans</literal> package provided by Sun.
    		</para>
    		<para>
    			A couple of examples where property editing are used in Spring
    			<itemizedlist spacing="compact">
    				<listitem>
    					<para><emphasis>setting properties on beans</emphasis> is done using
    						PropertyEditors. When mentioning <literal>java.lang.String</literal>
    						as the value of a property of some bean you're declaring in XML file,
    						Spring will (if the setter of the corresponding property has a 
    						Class-parameter) use the <literal>ClassEditor</literal> to try
    						to resolve the parameter to a Class object</para>
    				</listitem>
    				<listitem>
    					<para><emphasis>parsing HTTP request parameters</emphasis> is Spring's
    						MVC framework is done using all kinds of PropertyEditors that you
    						can manually bind in all subclasses of the <literal>CommandController</literal></para>
    				</listitem>
    			</itemizedlist>
    		</para>
			<para>
				Spring has a number of built-in PropertyEditors to make life easy. Each of those is listed below and
				they are all located in the <literal>org.springframework.beans.propertyeditors</literal> package:
				<table frame="all">
		            <title>Built-in PropertyEditors</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="1*"/>
		                <colspec colname="c2" colwidth="5*"/>
		                <thead>
		                    <row>
		                        <entry>Class</entry>
		                        <entry>Explanation</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry><literal>ClassEditor</literal></entry>
				            	<entry>
				            		Parses Strings representing classes to actual classes and
				            		the other way around. When a class is not found,
				            		an IllegalArgumentException is thrown
				            	</entry>
				            </row>
				            <row>
				            	<entry><literal>FileEditor</literal></entry>
				            	<entry>
				            		Capable of resolving String to <literal>File</literal>-objects
				            	</entry>
				            </row>
				            <row>
				            	<entry><literal>LocaleEditor</literal></entry>
				            	<entry>
				            		Capable of resolving Strings to <literal>Locale</literal>-objects
				            		and vice versa (the String format is [language]_[country]_[variant],
				            		which is the same thing the toString() method of Locale provides
				            	</entry>
				            </row>
				            <row>
				            	<entry><literal>PropertiesEditor</literal></entry>
				            	<entry>
				            		Capable of converting Strings (formatted using the 
				            		format as defined in the JavaDOC for the java.lang.Properties class)
				            		to <literal>Properties</literal>-objects
				            	</entry>
				            </row>
				            <row>
				            	<entry><literal>StringArrayPropertyEditor</literal></entry>
				            	<entry>
				            		Capable of resolving a comma-delimited list of String to
				            		a String-array and vice versa
				            	</entry>
				            </row>
				            <row>
				            	<entry><literal>URLEditor</literal></entry>
				            	<entry>
				            		Capable of resolving a String representation of a URL
				            		to an actual <literal>URL</literal>-object
				            	</entry>
				            </row>				            				            
				        </tbody>
			        </tgroup>
		        </table>
			</para>
			<para>
				Spring uses the <literal>java.beans.PropertyEditorManager</literal> to
				set the search-path for property editors that might be needed. The search-path
				also includes <literal>sun.bean.editors</literal>, which includes
				PropertyEditors for for example Font, Color and all the primitive types.
			</para>
			<para>
				When in need for a custom editor in your BeanFactory (i.e. you have some
				exotic type that you need express as a property in for instance an XML
				file containing beans), you can use the <literal>BeanFactoryPostProcessor</literal>
				infrastructure to do this. TODOOOODOOD reference provides more info on how to use
				the <literal>BeanFactoryPostProcessor</literal>. The following piece of code
				show the actual processor that registered a custom editor for use with the
				BeanFactory:
				<programlisting><![CDATA[
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
	    beanFactory.registerCustomEditor(Date.class, CustomDateEditor.class);
	}
}
				]]></programlisting>

			</para>
		</sect2>  
		
		<sect2 id="beans-beans-other">
			<title>Other features worth mentioning</title>
			<para>
				Besides the features you've seen in the previous sections there a couple of
				features that might be intereseted to you, though not worth an entire section.
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							<emphasis>determining readability and writability</emphasis>: using
							the <literal>isReadable()</literal> and <literal>isWritable()</literal>
							methods, you can determine whether or not a property is readable or
							writable
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>retrieving propertydescriptors</emphasis>: using
							<literal>getPropertyDescriptor(String)</literal> and
							<literal>getPropertyDescriptors()</literal> you can retrieve
							objects of type <literal>java.beans.PropertyDescriptor</literal>,
							that might come in handy sometimes
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>			  		

    </sect1>

    
        	
</chapter>


