<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="beans">
    <title>The IoC container</title>
    <section id="beans-introduction">
        <title>Introduction</title>
        <para>
			This chapter is devoted to covering (in detail) the Spring Framework's
			Inversion of Control (IoC)
			<footnote><para>See <xref linkend="background-ioc" /></para></footnote>
			technology. Spring's IoC technology underpins a lot of the surrounding
			functionality that is provided by the Spring Framework a whole, and so
			a thorough treatment of this rich, yet conceptually very simple,
			technology is in order. 
        </para>
        <sidebar>
			<title>Which interface?</title>
            <para>
                Users are sometimes unsure whether a <interfacename>BeanFactory</interfacename>
                or an <interfacename>ApplicationContext</interfacename> is best suited for use
                in a particular situation. Normally when building most applications in a
                J2EE-environment, <emphasis>the best option is to use the</emphasis>
                <interfacename>ApplicationContext</interfacename>, since it offers
                all the features of the <interfacename>BeanFactory</interfacename>, while also
                allowing a more declarative approach to the use of some functionality, which is
                generally desirable.
            </para>
            <para>
				The main usage scenario when one might prefer to use the
                <interfacename>BeanFactory</interfacename> is when memory usage is the greatest
                concern (such as in an applet where every last kilobyte counts), and one doesn't
                need all the features of the <interfacename>ApplicationContext</interfacename>.
            </para>
        </sidebar>
		<para>
			The <literal>org.springframework.beans</literal> and
            <literal>org.springframework.context</literal> packages provide the basis
            for the Spring Framework's IoC container. The
            <interfacename><ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</ulink></interfacename>
			interface provides an advanced configuration mechanism capable of managing
			objects of any nature. The
            <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html">ApplicationContext</ulink></literal>
            interface builds on top of the <interfacename>BeanFactory</interfacename>
            (it is a sub-interface) and adds other functionality such as easier integration
            with Spring's AOP features, message resource handling (for use in
            internationalization), event propagation, declarative mechanisms to create
            the <interfacename>ApplicationContext</interfacename> and  optional parent
            contexts, and application-layer specific contexts such as the
            <interfacename>WebApplicationContext</interfacename>.
		</para>
		<para>
			In short, the <interfacename>BeanFactory</interfacename> provides the
			configuration framework and basic functionality, while the
			<interfacename>ApplicationContext</interfacename> adds more enterprise-centric
			functionality to it. In general, the
			<interfacename>ApplicationContext</interfacename> is a complete superset of the
			<interfacename>BeanFactory</interfacename>, and any description of
			<interfacename>BeanFactory</interfacename> capabilities and behavior should be
			considered to apply to the <interfacename>ApplicationContext</interfacename> as
			well.
		</para>
		<para>
			This chapter is divided into two parts, with the
			<link linkend="beans-factory">first part</link> covering
			the basic principles that apply to both the
			<interfacename>BeanFactory</interfacename> and
			<interfacename>ApplicationContext</interfacename>, and with the
			<link linkend="context-introduction">second part</link>
			covering those features that apply only to the
			<interfacename>ApplicationContext</interfacename> interface.
		</para>
    </section>
    <section id="beans-basics">
        <title>The basics</title>
		<para>
			In Spring, those objects that form the backbone of your application and that
			are managed by the Spring IoC container are referred to as
			<emphasis>beans</emphasis>. A bean is simply an object that is instantiated
			(typically), assembled and otherwise managed by the Spring IoC container...
			other than that, there is nothing special about a bean (it's an object
			in your application).
		</para>
		<sidebar>
			<title>Why... beans?</title>
			<para>
				The motivation for using the name <emphasis>'bean'</emphasis>,
				as opposed to <emphasis>'component'</emphasis> or <emphasis>'object'</emphasis>
				is rooted in the origins of the Spring Framework itself (it arose
				partly as a response to the complexity of Enterprise
				Java<emphasis>Beans</emphasis>).
			</para>
		</sidebar>
		<para>
			These beans typically collaborate with one another,
			and thus are said to have <emphasis>dependencies</emphasis> between themselves;
			these dependencies are reflected in the configuration data
			used by the <interfacename>BeanFactory</interfacename> (although some
			dependencies may not be visible as configuration data, but rather be a
			function of programmatic interactions between beans at runtime).
		</para>
        <section id="beans-factory">
            <title>The <interfacename>BeanFactory</interfacename></title>
            <para>
                The
                <classname><ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</ulink></classname>
				is the actual <emphasis>container</emphasis> which contains and manages the
				aforementioned beans.
			</para>
            <para>
				The <interfacename>org.springframework.beans.factory.BeanFactory</interfacename>
				interface is the central IoC container interface in Spring. Its
				responsibilities include instantiating or sourcing application objects,
				configuring said objects, and assembling the dependencies between
				objects.
			</para>
			<para>
				There are a number of implementations of the <interfacename>BeanFactory</interfacename>
				interface that come supplied straight out-of-the-box with Spring. The most
				commonly used <interfacename>BeanFactory</interfacename> implementation is the
				<classname><ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/xml/XmlBeanFactory.html">XmlBeanFactory</ulink></classname>
				class.
			</para>
			<para>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/container-magic.png" format="PNG" align="center" />
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/container-magic.png" format="PNG" align="center" />
					</imageobject>
					<caption>
						<para>The Spring IoC container</para>
					</caption>
				</mediaobject>
			</para>
			<section>
				<title>Configuration metadata</title>
				<para>
					As can be seen in the above image, the Spring IoC container consumes some form of
					<emphasis>configuration metadata</emphasis>; this configuration metadata is nothing
					more than how you (as an application developer) inform the Spring container as to
					how to <quote>instantiate, configure, and assemble [the objects in your
					application]</quote>. This configuration metadata is typically supplied in a
					simple and intuitive XML format. In the XML-based configuration metadata, you
					simply write <emphasis>definitions</emphasis> for each bean that you want the
					Spring IoC container to manage, and then let said container do its stuff.
				</para>
				<note>
					<para>
						XML-based metadata is by far the most commonly used form of this so-called
						configuration metadata. It is <emphasis>not</emphasis> however the only form
						of configuration metadata that is allowed. The Spring IoC container itself
						is <emphasis>totally</emphasis> decoupled from the format in which this
						configuration metadata is actually written.
					</para>
					<para>
						At the time of writing, one can supply this configuration metadata
						using either XML, the Java properties format, or programmatically (using
						Spring's public API). The XML-based configuration metadata format really is
						simple though, and so the remainder of this chapter will use the XML format
						to convey key concepts and features of the Spring IoC container.
					</para>
				</note>
			</section>
			<section>
				<title>Instantiating a Spring IoC container</title>
				<para>
					Although for most scenarios, almost all user code managed by the
					<interfacename>BeanFactory</interfacename> does not have to be aware of the
					<interfacename>BeanFactory</interfacename>, the
					<interfacename>BeanFactory</interfacename> does have to be instantiated somehow. This can happen via
					explicit user code such as:
				</para>
				<programlisting><![CDATA[Resource res = new FileSystemResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(res);]]></programlisting>
				<para>
					or
				</para>
				<programlisting><![CDATA[ClassPathResource res = new ClassPathResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(res);]]></programlisting>
				<para>
					or
				</para>
				<programlisting><![CDATA[ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(
        new String[] {"applicationContext.xml", "applicationContext-part2.xml"});
]]><lineannotation>// of course, an <interfacename>ApplicationContext</interfacename> is just a <interfacename>BeanFactory</interfacename></lineannotation><![CDATA[
BeanFactory factory = (BeanFactory) ctx;]]></programlisting>
				<sidebar>
					<title>Resources</title>
					<para>
						Once you have learned the basics of the IoC container (this chapter),
						it will also be useful to learn about Spring's
						<interfacename>Resource</interfacename> abstraction, as described in
						<xref linkend="resources" />.
					</para>
					<para>
						The location path or paths supplied to
						an <interfacename>ApplicationContext</interfacename> constructor are
						actually resource strings that allow the container to load
						configuration metadata from a variety of external resources such
						as the local file system, from the Java <literal>CLASSPATH</literal>, etc.
					</para>
				</sidebar>
				<para>
					Please be advised that in the vast majority of application scenarios,
					explicit user code is not required to instantiate one or more instances
					of a Spring IoC container. For example, in a web application scenario, a simple
					eight (or so) lines of absolutely boilerpate J2EE web descriptor XML in the
					attendant <literal>web.xml</literal> file of the application will typically
					suffice (see <xref linkend="context-create" />).
				</para>
			</section>
            <para>
				A <interfacename>BeanFactory</interfacename> configuration consists of,
				at its most basic level, definitions of at least one (but typically more)
				beans that the <interfacename>BeanFactory</interfacename> must manage. In an
				<classname>XmlBeanFactory</classname>, these are configured as one or
				more <literal>&lt;bean/&gt;</literal> elements inside a top-level
				<literal>&lt;beans/&gt;</literal> element.
			</para>
			<para>
				These bean definitions correspond to the actual objects that makeup your
				application (or applications).
				Typically one will have bean definitions for one's service layer objects,
				one's data access objects (DAOs), presentation objects such as
				Struts <interfacename>Action</interfacename> instances, infrastructure
				objects such as Hibernate <interfacename>SessionFactory</interfacename>
				instances, etc. (the possibilities are of course endless and are limited
				only by the scope and complexity of your application).
			</para>
			<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
    "http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
  <bean id="..." class="...">
    ]]><lineannotation>&lt;!-- collaborators and configuration for this bean go here --&gt;</lineannotation><![CDATA[
  </bean>
  <bean id="..." class="...">
    ]]><lineannotation>&lt;!-- collaborators and configuration for this bean go here --&gt;</lineannotation><![CDATA[
  </bean>
  ]]><lineannotation>&lt;!-- more bean definitions go here... --&gt;</lineannotation><![CDATA[
</beans>]]></programlisting>
        </section>
        <section id="beans-definition">
            <title>The <interfacename>BeanDefinition</interfacename></title>
            <para>
				Bean definitions inside a <classname>DefaultListableBeanFactory</classname>
				implementation (such as the <classname>XmlBeanFactory</classname> class) are
				represented as <interfacename>BeanDefinition</interfacename> objects, which
				contain (among other information) the following details:
			</para>
			<itemizedlist>
                    <listitem>
                        <para>
							<emphasis>a package-qualified class name:</emphasis> this is
							normally the actual implementation class of the bean being
							defined. However, if the bean is to be constructed by calling
							a <literal>static</literal> <emphasis>factory</emphasis>
							method instead of using a normal constructor, this will
							actually be the class name of the factory class.
						</para>
                    </listitem>
                    <listitem>
                        <para>
							bean behavioral configuration elements, which state how the
							bean should behave in the container (i.e. prototype or singleton,
							autowiring mode, dependency checking mode, initialization and
							destruction methods)
						</para>
                    </listitem>
                    <listitem>
                        <para>
							constructor arguments and property values to set in the
							newly created bean. An example would be the number of connections
							to use in a bean that manages a connection pool (either specified
							as a property or as a constructor argument), or the pool size
							limit.
						</para>
                    </listitem>
                    <listitem>
                        <para>
							other beans a bean needs to do its work, i.e.
							<emphasis>collaborators</emphasis> (dependencies).
						</para>
                    </listitem>
                </itemizedlist>
            <para>
				The concepts listed above directly translate to a set of elements
				the bean definition consists of. Some of these element groups are listed
				below, along with a link to further documentation about each of them.
			</para>
			<table frame="all">
                <title>Bean definition explanation</title>
                <tgroup cols="2">
                    <colspec colname="c1" colwidth="2*" />
                    <colspec colname="c2" colwidth="4*" />
                    <thead>
                        <row>
                            <entry>Feature</entry>
                            <entry>More info</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>class</entry>
                            <entry>
                                <xref linkend="beans-factory-class" />
                            </entry>
                        </row>
                        <row>
                            <entry>id and name</entry>
                            <entry>
                                <xref linkend="beans-beanname" />
                            </entry>
                        </row>
                        <row>
                            <entry>singleton or prototype</entry>
                            <entry>
                                <xref linkend="beans-factory-scopes" />
                            </entry>
                        </row>
                        <row>
                            <entry>constructor arguments</entry>
                            <entry>
                                <xref linkend="beans-factory-collaborators" />
                            </entry>
                        </row>
                        <row>
                            <entry>bean properties</entry>
                            <entry>
                                <xref linkend="beans-factory-collaborators" />
                            </entry>
                        </row>
                        <row>
                            <entry>autowiring mode</entry>
                            <entry>
                                <xref linkend="beans-factory-autowire" />
                            </entry>
                        </row>
                        <row>
                            <entry>dependency checking mode</entry>
                            <entry>
                                <xref linkend="beans-factory-dependencies" />
                            </entry>
                        </row>
                        <row>
                            <entry>lazy-initialization mode</entry>
                            <entry>
                                <xref linkend="beans-factory-lazy-init" />
                            </entry>
                        </row>
                        <row>
                            <entry>initialization method</entry>
                            <entry>
                                <xref linkend="beans-factory-lifecycle" />
                            </entry>
                        </row>
                        <row>
                            <entry>destruction method</entry>
                            <entry>
                                <xref linkend="beans-factory-lifecycle" />
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
			<para>
				A bean definition is represented internally by the
				<interfacename>org.springframework.beans.factory.config.BeanDefinition</interfacename>
				interface, and its various implementations. However, it is rare that
				user code works directly with <interfacename>BeanDefinition</interfacename> objects:
				usually, bean definitions will be expressed in a metadata format (such
				as XML), which will be loaded on startup. The internal representation of
				such bean definitions are <interfacename>BeanDefinition</interfacename> objects
				in the container.
			</para>
			<para>
				Besides bean definitions which contain information on how to
				create a specific bean, certain <interfacename>BeanFactory</interfacename>
				implementations also permit the registration of existing objects that have
				been created outside the factory (by custom code). The
				<classname>DefaultListableBeanFactory</classname> class supports this
				through the <literal>registerSingleton(..)</literal> method, as defined by the
				<interfacename>org.springframework.beans.factory.config.ConfigurableBeanFactory</interfacename>
				interface. Typical applications solely work with beans defined through
				metadata bean definitions, though.
			</para>
        </section>
        <section id="beans-factory-class">
            <title>The bean class</title>
            <para>
				The <literal>'class'</literal> property is normally mandatory (see
				<xref linkend="beans-instance-factory-method" /> and <xref linkend="beans-child-bean-definitions" /> for the two exceptions) and is
				used for one of two purposes. In the much more common case where the
				<interfacename>BeanFactory</interfacename> itself directly creates the bean by calling its constructor
				(equivalent to Java code using the <emphasis>'new'</emphasis> operator), the class
				attribute specifies the class of the bean to be constructed. In the less
				common case where the <interfacename>BeanFactory</interfacename> calls a
				<literal>static</literal>, so-called <emphasis>factory</emphasis> method
				on a class to create the bean, the class attribute specifies the actual
				class containing the <literal>static</literal> factory method (the type
				of the returned bean from the <literal>static</literal> factory method
				may be the same class or another class entirely, it doesn't	matter).
			</para>
            <section>
                <title>Bean creation via constructor</title>
                <para>
					When creating a bean using the constructor approach, all normal
					classes are usable by and compatible with Spring. That is, the
					class being created does not need to implement any specific interfaces
					or be coded in a specific fashion. Just specifying the bean class
					should be enough. However, depending on what type of IoC you are going
					to use for that specific bean, you may need a default (empty)
					constructor.
				</para>
                <para>
					Additionally, the <interfacename>BeanFactory</interfacename> isn't
					limited to just managing true JavaBeans, it is also able to manage virtually
					<emphasis>any</emphasis> class you want it to manage. Most people
					using Spring prefer to have actual JavaBeans (having just a default
					(no-argument) constructor and appropriate setters and getters modeled
					after the properties) in the <interfacename>BeanFactory</interfacename>,
					but it is also possible to have more exotic non-bean-style classes in
					your <interfacename>BeanFactory</interfacename>. If, for example, you
					need to use a legacy connection pool that absolutely does not adhere
					to the JavaBean specification, Spring can manage it as well.
				</para>
                <para>
					Using the <classname>XmlBeanFactory</classname> you can specify your
					bean class as follows:
				</para>
				<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>]]></programlisting>
                <para>
					The mechanism for supplying (optional) arguments to the
					constructor, or setting properties of the object instance after it has
					been constructed, will be described shortly.
				</para>
            </section>
            <section>
                <title>Bean creation via a <literal>static</literal> factory method</title>
                <para>
					When defining a bean which is to be created using a static
					factory method, along with the <literal>class</literal> attribute
					which specifies the class containing the <literal>static</literal> factory method,
					another attribute named <literal>factory-method</literal> is needed to
					specify the name of the factory method itself. Spring expects to be
					able to call this method (with an optional list of arguments as
					described later) and get back a live object, which from that point on
					is treated as if it had been created normally via a constructor. One
					use for such a bean definition is to call <literal>static</literal>
					factories in legacy code.
				</para>
                <para>
					The following example shows a bean definition which specifies
					that the bean is to be created by calling a factory-method. Note that
					the definition does not specify the type (class) of the returned
					object, only the class containing the factory method. In this example,
					the <literal>createInstance()</literal> method must be a
					<emphasis>static</emphasis> method.
				</para>
				<programlisting><![CDATA[<bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/>]]></programlisting>
                <para>
					The mechanism for supplying (optional) arguments to the factory
					method, or setting properties of the object instance after it has been
					returned from the factory, will be described shortly.
				</para>
            </section>
            <section id="beans-instance-factory-method">
                <title>Bean creation via an instance factory method</title>
                <para>
					Quite similar to using a <literal>static</literal> factory method to create a bean,
					is the use of an instance (non-static) factory method, where a factory
					method of an existing bean from the container is called to create the
					new bean.
				</para>
                <para>
					To use this mechanism, the <literal>class</literal> attribute
					must be left empty, and the <literal>factory-bean</literal> attribute
					must specify the name of a bean in the current or an ancestor bean
					factory which contains the factory method. The factory method itself
					should still be set via the <literal>factory-method</literal>
					attribute (as seen in the example below).
				</para>
                <programlisting><![CDATA[<!-- The factory bean, which contains a method called <literal>createInstance()</literal> -->
<bean id="myFactoryBean" class="...">
  ...
</bean>
<!-- The bean to be created via the factory bean -->
<bean id="exampleBean"
      factory-bean="myFactoryBean"
      factory-method="createInstance"/>]]></programlisting>
                <para>Alhough the mechanisms for setting bean properties are still to
				be discussed, one implication of this approach is that the factory
				bean itself can be managed and configured via DI.
				</para>
            </section>
        </section>
        <section id="beans-beanname">
            <title>The bean identifiers (<literal>id</literal> and <literal>name</literal>)</title>
            <para>
				Every bean has one or more ids (also called identifiers, or names;
				these terms refer to the same thing). These ids must be unique within
				the container the bean is hosted in. A bean will almost always have only one
				id, but if a bean has more than one id, the extra ones can essentially be
				considered aliases.
			</para>
            <para>
				In an <classname>XmlBeanFactory</classname> , you use the <literal>id</literal>
				or <literal>name</literal> attributes to specify the bean id(s). The
				<literal>id</literal> attribute allows you to specify one id, and as
				it is a real XML element ID attribute, the XML parser is able to do
				some extra validation when other elements point back to this one. As
				such, it is the preferred way to specify a bean id. However, the XML
				specification does limit the characters which are legal in XML IDs.
				This is usually not a constraint, but if you have a need to use one of
				these characters, or want to introduce other aliases to the bean, you
				may also or instead specify one or more bean ids, separated by a comma
				(<literal>,</literal>), semicolon (<literal>;</literal>), or whitespace
				via the <literal>name</literal> attribute.
			</para>
            <para>
				Please note that you are not required to supply a name for a bean. If
				no name is supplied explicitly, the container will generate a (unique) name
				for that bean. The motivations for not supplying a name for a bean will be
				discussed later (one use case is
				<link linkend="beans-inner-beans">inner beans</link>).
			</para>
            <para>
				Finally, please do take some care to be consistent when naming beans.
				The convention (at least amongst the Spring development team) is to use
				the standard Java convention for instance field names when naming beans.
				That is, bean names start with a lowercase letter, and are camel-cased
				from then on. Examples of such names would be (without quotes)
				<literal>'accountManager'</literal>, <literal>'accountService'</literal>,
				<literal>'userDao'</literal>, <literal>'loginController'</literal>etc.
				Adopting a standard way of naming your beans will go a long way towards
				making your configuration easy to read and understand; adopting such
				naming standards is not hard to do, and if you are using SpringAOP it can
				pay off handsomely when it comes to applying advice to a set of beans
				related by name.
			</para>
        </section>
        <section id="beans-factory-scopes">
            <title>Bean scopes</title>
            <para>
				Beans are defined to be deployed in one of two scopes: singleton or
				non-singleton. (The latter is also called a prototype, although the term
				is used loosely as it doesn't quite fit). When a bean is a singleton,
				only one <emphasis>shared</emphasis> instance of the bean will be
				managed and all requests for beans with an id or ids matching that bean
				definition will result in that one specific bean instance being
				returned.
			</para>
            <para>
				The non-singleton, prototype scope of bean deployment results in
				the <emphasis>creation of a new bean instance</emphasis> every time a
				request for that specific bean is made. This is ideal for situations
				where for example each user needs an independent user object or
				something similar.
			</para>
            <para>
				Beans are deployed in singleton scope by default, unless you
				specify otherwise. Keep in mind that by changing the type to
				non-singleton (prototype), each request for a bean will result in a
				newly created bean and this might not be what you actually want. So only
				change the scope to prototype when absolutely necessary.
			</para>
            <para>
				In the example below, two beans are declared of which one is
				defined as a singleton, and the other one is a non-singleton
				(prototype). <literal>exampleBean</literal> is created each and every
				time a client asks the <interfacename>BeanFactory</interfacename> for this bean, while
				<literal>yetAnotherExample</literal> is only created once; a reference
				to the exact same instance is returned on each request for this
				bean.
			</para>
			<programlisting><![CDATA[<bean id="exampleBean"
      class="examples.ExampleBean" singleton="false"/>
<bean name="yetAnotherExample"
      class="examples.ExampleBeanTwo" singleton="true"/>]]></programlisting>
            <note>
				<para>
					When deploying a bean in the prototype scope, the lifecycle
					of the bean changes slightly. Spring cannot manage the complete lifecycle of a
					prototype bean, since after it is created, it is given to the client and the
					container does not keep track of it at all any longer. You can think of Spring's
					role when talking about a prototype bean as a replacement for the 'new'
					operator. Any lifecycle aspects past that point have to be handled by
					the client. The lifecycle of a bean in the <interfacename>BeanFactory</interfacename> is further
					described in <xref linkend="beans-factory-lifecycle" />.
				</para>
			</note>
        </section>
    </section>
    <section id="beans-dependencies">
        <title>Properties, collaborators, autowiring and dependency checking</title>
        <section id="beans-factory-collaborators">
            <title>Setting bean properties and collaborators</title>
            <para>
				IoC has already been referred to as
				<emphasis>Dependency Injection</emphasis> (DI). The basic principle behind
				DI is that beans define their dependencies (i.e. the other objects they work with)
				only through constructor arguments, arguments to a factory method, or
				properties which are set on the object instance after it has been
				constructed or returned from a factory method. Then, it is the job of
				the container to actually <emphasis>inject</emphasis> those dependencies
				when it creates the bean. This is fundamentally the inverse (hence the
				name Inversion of Control) of the bean instantiating or locating its
				dependencies on its own using direct construction of classes, or
				something like the <emphasis>Service Locator</emphasis> pattern.
			</para>
			<para>
				It becomes evident upon usage that code gets much cleaner, and
				reaching a higher grade of decoupling is much easier when beans do not
				look up their dependencies, but are provided with them, and additionally
				do not even know where the dependencies are located and of what actual
				type they are.
			</para>
            <para>
				As touched on in the previous paragraph, DI exists in two major variants,
				namely <link linkend="beans-setter-injection">Setter Injection</link>, and
				<link linkend="beans-constructor-injection">Constructor Injection</link>.
			</para>
			<section id="beans-setter-injection">
				<title>Setter Injection</title>
                <para>
					<emphasis>setter-based</emphasis> DI is realized by calling setter methods
					on your beans after invoking a no-argument constructor or no-argument
					<literal>static</literal> factory method to instantiate your bean. Beans
					defined in a container that use only setter-based DI are
					<emphasis>true JavaBeans</emphasis>.
				</para>
				<para>
					Find below an example of a class that could only be dependency injected
					using pure setter injection. Note that there is nothing <emphasis>special</emphasis>
					about this class... it's plain Java really.
				</para>
				<programlisting><![CDATA[public class SimpleMovieLister {

    ]]><lineannotation>// the <classname>SimpleMovieLister</classname> has a dependency on the <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    private MovieFinder movieFinder;

    ]]><lineannotation>// a setter method so that the Spring container can 'inject' a <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    public void setMoveFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    ]]><lineannotation>// business logic that actually 'uses' the injected <interfacename>MovieFinder</interfacename> is omitted...</lineannotation><![CDATA[
}]]></programlisting>
			</section>
			<section id="beans-constructor-injection">
				<title>Constructor Injection</title>
                <para>
					<emphasis>constructor-based</emphasis> DI
					is realized by invoking a constructor with a number of arguments,
					each representing a collaborator. Additionally,
					calling a <literal>static</literal> factory method with specific arguments, to
					construct the bean, can be considered almost equivalent, and the
					rest of this text will consider arguments to a constructor and
					arguments to a <literal>static</literal> factory method similarly.
				</para>
				<para>
					Find below an example of a class that could only be dependency injected
					using constructor injection. Again, note that there is nothing <emphasis>special</emphasis>
					about this class.
				</para>
				<programlisting><![CDATA[public class SimpleMovieLister {

    ]]><lineannotation>// the <classname>SimpleMovieLister</classname> has a dependency on the <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    private MovieFinder movieFinder;

    ]]><lineannotation>// a constructor so that the Spring container can 'inject' a  <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    ]]><lineannotation>// business logic that actually 'uses' the injected <interfacename>MovieFinder</interfacename> is omitted...</lineannotation><![CDATA[
}]]></programlisting>
			</section>
			<sidebar>
				<title>Constructor- or Setter-based DI?</title>
				<para>
					The Spring team generally advocates the usage of setter injection,
					since a large number of constructor arguments can get unwieldy,
					especially when some properties are optional. The presence of
					setter methods also makes objects of that class amenable to being
					re-configured (or re-injected) at some later time (
					<link linkend="jmx">JMX MBeans</link> is a particularly compelling use case).
				</para>
				<para>
					Constructor-injection is favoured by some purists though (and with
					good reason)... supplying all of an object's dependencies means that
					that object is never returned to client (calling) code in a less than
					totally intialized state. The flipside is that the object becomes
					less amenable to re-configuration (or re-injection).
				</para>
				<para>
					There is no hard and fast rule here... use whatever type of DI makes
					the most sense for a particular class; sometimes, when dealing with
					third party classes to which one does not have the source, the choice
					will already have been made for you - a legacy class may not expose
					any setter methods, and so constructor injection will be the only type
					of DI available to you.
				</para>
			</sidebar>
            <para>
				The <classname>BeanFactory</classname> supports both of these
				variants for injecting dependencies into beans it manages. (It in fact
				also supports injecting setter-based dependencies after some
				dependencies have already been supplied via the constructor approach.)
				The configuration for the dependencies comes in the form of a
				<interfacename>BeanDefinition</interfacename>, which is used together with
				<interfacename>PropertyEditor</interfacename> instances to know how to convert properties
				from one format to another. The actual values being passed around are
				done in the form of <classname>PropertyValue</classname> objects. However,
				most users of Spring will not be dealing with these classes directly
				(i.e. programmatically), but rather with an XML definition file which
				will be converted internally into instances of these classes, and used
				to load an entire Spring IoC container instance.
			</para>
            <para>
				Bean dependency resolution generally happens as follows:
			</para>
			<orderedlist>
                <listitem>
                    <para>
						The <interfacename>BeanFactory</interfacename> is created and initialized with a
						configuration which describes all the beans. (Most Spring users use
						a <interfacename>BeanFactory</interfacename> or
						<interfacename>ApplicationContext</interfacename> variant which supports XML
						format configuration files.)
					</para>
                </listitem>
                <listitem>
                    <para>
						Each bean has dependencies expressed in the form of
						properties, constructor arguments, or arguments to the
						static-factory method when that is used instead of a normal
						constructor. These dependencies will be provided to the bean,
						<emphasis>when the bean is actually created</emphasis>.
					</para>
                </listitem>
                <listitem>
                    <para>
						Each property or constructor-arg is either an actual
						definition of the value to set, or a reference to another bean in
						the container. In the case of the <interfacename>ApplicationContext</interfacename>, the
						reference can be to a bean in a parent <interfacename>ApplicationContext</interfacename>.
					</para>
                </listitem>
                <listitem>
                    <para>
						<anchor id="beans-factory-collaborators-propertyeditor" />
						Each property or
						constructor argument which is a value must be able to be converted
						from whatever format it was specified in, to the actual type of
						that property or constructor argument. By default Spring can
						convert a value supplied in string format to all built-in types,
						such as <literal>int</literal>, <literal>long</literal>,
						<literal>String</literal>, <literal>boolean</literal>, etc.
					</para>
                </listitem>
                <listitem>
                    <para>
						It is important to realize that Spring validates the
						configuration of each bean in a container as and when the container
						is created, including the validation that properties which are
						bean references are actually referring to valid beans (i.e. the
						beans being referred to are also defined in the <interfacename>BeanFactory</interfacename>, or in
						the case of <interfacename>ApplicationContext</interfacename>, a parent context). However, the
						bean properties themselves are not set until the bean <emphasis>is
						actually created</emphasis>. For beans which are singleton-scoped and set
						to be pre-instantiated (such as singleton beans in an
						<interfacename>ApplicationContext</interfacename>), creation happens at the time that the
						<interfacename>BeanFactory</interfacename> is created, but otherwise this is only when the bean
						is requested. When a bean actually has to be created, this will
						potentially cause a graph of other beans to be created, as its
						dependencies and its dependencies' dependencies (and so on) are
						created and assigned.
					</para>
                </listitem>
            </orderedlist>
            <para>
				You can generally trust Spring to do the right thing. It
				will pick up configuration issues, including references to
				non-existent beans and circular dependencies, at
				<interfacename>BeanFactory</interfacename>
				load-time. It will actually set properties and resolve
				dependencies (i.e. create those dependencies if needed) as late as
				possible, which is when the bean is actually created. This does
				mean that a Spring container which has loaded correctly, can later
				generate an exception when you request a bean, if there is a
				problem creating that bean or one of its dependencies. This could
				happen if the bean throws an exception as a result of a missing or
				invalid property, for example. This potentially delayed visibility
				of some configuration issues is why
				<interfacename>ApplicationContext</interfacename> implementations by default
				pre-instantiate singleton beans. At the cost of some upfront time
				and memory to create these beans before they are actually needed,
				you find out about configuration issues when the
				<interfacename>ApplicationContext</interfacename> is created, not later.
				If you wish, you can still override this default behavior and set any of these
				singleton beans to lazy-initialize (i.e. not be pre-instantiated).
			</para>
            <para>
				Finally, if it is not immediately apparent, it is worth mentioning that when
				one or more collaborating beans are being injected into a dependent bean, each
				collaborating bean is <emphasis>totally</emphasis> configured prior to being
				passed (via one of the DI flavours) to the dependent bean.
				This means that if bean A has a dependency on bean B, the Spring IoC container
				will <emphasis>totally</emphasis> configure bean B prior to invoking (for example)
				the attendant setter method on bean A; you can read '<emphasis>totally configure</emphasis>'
				to mean that the bean will be instantiated (if not a pre-instantiated singleton),
				all of its dependencies will be set, and the relevant lifecycle methods (such as
				a <link linkend="beans-factory-lifecycle-initializingbean">configured init method</link>
				or the
				<link linkend="beans-factory-lifecycle-initializingbean">IntializingBean callback method</link>
				will all be invoked.
			</para>
		<section id="beans-some-examples">
			<title>Some examples</title>
            <para>
				First, an example of using the <interfacename>BeanFactory</interfacename> for setter-based
				DI. Below is a small part of an
				<classname>XmlBeanFactory</classname> configuration file specifying some
				bean definitions. Following is the code for the actual main bean itself,
				showing the appropriate setters declared.
			</para>
			<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">
  <property name="beanOne"><ref bean="anotherExampleBean"/></property>
  <property name="beanTwo"><ref bean="yetAnotherBean"/></property>
  <property name="integerProperty"><value>1</value></property>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>]]></programlisting>
			<programlisting><![CDATA[public class ExampleBean {
    
    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }
    
    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }
    
    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}]]></programlisting>
			<para>
				As you can see, setters have been declared to match against
				the properties specified in the XML file.
			</para>
            <para>
				Now, an example of using the <interfacename>BeanFactory</interfacename> for
				constructor-based DI. Below is a snippet from an XML
				configuration that specifies constructor arguments and the actual bean
				code, showing the constructor:
			</para>
			<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">
  <constructor-arg><ref bean="anotherExampleBean"/></constructor-arg>
  <constructor-arg><ref bean="yetAnotherBean"/></constructor-arg>
  <constructor-arg type="int"><value>1</value></constructor-arg>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>]]></programlisting>
			<programlisting><![CDATA[public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}]]></programlisting>
			<para>
				As you can see, the constructor arguments specified in the
				bean definition will be used to pass in as arguments to the constructor
				of the <classname>ExampleBean</classname>.
			</para>
            <para>
				Now consider a variant of this where instead of using a
				constructor, Spring is told to call a <literal>static</literal> factory
				method to return an instance of the object:
			</para>
			<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance">
  <constructor-arg><ref bean="anotherExampleBean"/></constructor-arg>
  <constructor-arg><ref bean="yetAnotherBean"/></constructor-arg>
  <constructor-arg><value>1</value></constructor-arg>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>]]></programlisting>
			<programlisting><![CDATA[public class ExampleBean {

    ]]><lineannotation>// a private constructor</lineannotation><![CDATA[
    private ExampleBean(...) {
      ...
    }
    
    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        ExampleBean eb = new ExampleBean (...);
        // some other operations
        ...
        return eb;
    }
}]]></programlisting>
            <para>
				Note that arguments to the <literal>static</literal> factory method are supplied via
				<literal>constructor-arg</literal> elements, exactly the same as if a
				constructor had actually been used. These arguments are optional. Also,
				it is important to realize that the type of the class being returned by
				the factory method does not have to be of the same type as the class
				which contains the <literal>static</literal> factory method, although in this example it
				is. An instance (non-static) factory method, mentioned previously, would
				be used in an essentially identical fashion (aside from the use of the
				<literal>factory-bean</literal> attribute instead of the
				<literal>class</literal> attribute), so will not be detailed here.
			</para>
        </section>
		</section>
        <section>
            <title>Constructor Argument Resolution</title>
            <para>
				Constructor argument resolution matching occurs using the
				argument's type. If there is no potential for ambiguity in
				the constructor arguments of a bean definition, then the order
				in which the constructor arguments are defined in a bean definition
				is the order in which those arguments will be supplied to the
				appropriate constuctor when it is being instantiated. Consider the
				following class...
			</para>
			<programlisting><![CDATA[package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }
}]]></programlisting>
			<para>
				There is no potential for ambiguity here (assuming of course that <classname>Bar</classname>
				and <classname>Baz</classname> classes are not related in an inheritance hierarchy).
				Thus the folowing configuration will work just fine, and one does not need to
				specify the constructor argument indexes and / or types explicitly... it just plain
				works as one would expect it to.
			</para>
			<programlisting><![CDATA[<beans>
    <bean name="foo" class="x.y.Foo">
        <constructor-arg>
            <bean class="x.y.Bar"/>
        </constructor-arg>
        <constructor-arg>
            <bean class="x.y.Baz"/>
        </constructor-arg>
    </bean>
</beans>]]></programlisting>
			<para>
				When another bean is referenced, the type is known, and
				matching can occur (as was the case with the preceding example).
				When a simple type is used, such as
				<literal>&lt;value&gt;true&lt;value&gt;</literal>, Spring cannot
				determine the type of the value, and so cannot match by type without
				help. Consider the following class, which is used for the following two
				sections:
			</para>
			<programlisting><![CDATA[package examples;

public class ExampleBean {

    ]]><lineannotation>// No. of years to the calculate the Ultimate Answer</lineannotation><![CDATA[
    private int years;
    
    ]]><lineannotation>// The Answer to Life, the Universe, and Everything</lineannotation><![CDATA[
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}]]></programlisting>
            <section>
                <title>Constructor Argument Type Matching</title>
                <para>
					The above scenario <emphasis>can</emphasis> use type matching
					with simple types by explicitly specifying the type of the constructor
					argument using the <literal>type</literal> attribute. For example:
				</para>
				<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">
  <constructor-arg type="int"><value>7500000</value></constructor-arg>
  <constructor-arg type="java.lang.String"><value>42</value></constructor-arg>
</bean>]]></programlisting>
            </section>
            <section>
                <title>Constructor Argument Index</title>
                <para>
					Constructor arguments can have their index specified explicitly
					by use of the <literal>index</literal> attribute. For example:
				</para>
				<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">
  <constructor-arg index="0"><value>7500000</value></constructor-arg>
  <constructor-arg index="1"><value>42</value></constructor-arg>
</bean>]]></programlisting>
				<para>
					As well as solving the ambiguity problem of
					multiple simple values, specifying an index also solves the problem of
					ambiguity where a constructor may have two arguments of the same type.
					Note that the <emphasis>index is 0 based</emphasis>.
				</para>
                <para>
					Specifying a constructor argument index is the preferred way of
					performing constructor IoC.
				</para>
            </section>
        </section>
        <section id="beans-factory-properties-detailed">
            <title>Bean properties and constructor arguments detailed</title>
            <para>As mentioned in the previous section, bean properties and
      constructor arguments can be defined as either references to other
      managed beans (collaborators), or values defined inline. The
      <literal>XmlBeanFactory</literal> supports a number of sub-element types
      within its <literal>property</literal> and
      <literal>constructor-arg</literal> elements for this purpose.</para>
            <section id="beans-value-element">
                <title>The <literal>value</literal> element</title>
                <para>
					The <literal>value</literal> element specifies a property or
					constructor argument as a human-readable string representation. As
					mentioned in detail <link linkend="beans-factory-collaborators-propertyeditor">previously</link>,
					JavaBeans PropertyEditors are used to convert these string values from
					a <literal>java.lang.String</literal> to the actual property or
					argument type.
			</para>
			<programlisting><![CDATA[<bean id="myDataSource" destroy-method="close"
    class="org.apache.commons.dbcp.BasicDataSource">
  <!-- results in a setDriverClassName(String) call -->
  <property name="driverClassName">
    <value>com.mysql.jdbc.Driver</value>
  </property>
  <property name="url">
    <value>jdbc:mysql://localhost:3306/mydb</value>
  </property>
  <property name="username">
    <value>root</value>
  </property>
</bean>]]></programlisting>
            </section>
            <section id="beans-null-element">
                <title>The <literal>&lt;null/&gt;</literal> element</title>
                <para>The <literal>&lt;null/&gt;</literal> element is used to handle <literal>null</literal>
        values. Spring treats empty arguments for properties and the like as
        empty Strings. The following <classname>XmlBeanFactory</classname> configuration:
        <programlisting>&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;        </programlisting>results in the email property being set
        to "", equivalent to the Java code:
        <literal>exampleBean.setEmail("")</literal>. The special
        <literal>&lt;null&gt;</literal> element may be used to indicate a <literal>null</literal>
        value, so that: <programlisting>&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;        </programlisting>is equivalent to the java code:
        <literal>exampleBean.setEmail(null)</literal>.
				</para>
            </section>
            <section id="beans-inner-beans">
                <title>Inner bean definitions via nested bean elements</title>
                <para>A <literal>bean</literal> element inside the
        <literal>property</literal> element is used to define a bean value
        inline, instead of referring to a bean defined elsewhere in the
        BeanFactory. The inline bean definition does not need to have any id
        defined. <programlisting>&lt;bean id="outer" class="..."&gt;
  &lt;!-- Instead of using a reference to target, just use an inner bean --&gt;
  &lt;property name="target"&gt;
    &lt;bean class="com.mycompany.PersonImpl"&gt;
      &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
      &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
                <para>Note that the <literal>singleton</literal> flag and any
        <literal>id</literal> attribute are effectively ignored. Inner beans
        are anonymous prototypes.</para>
            </section>
            <section id="beans-collection-elements">
                <title>The collection elements</title>
                <para>The <literal>list</literal>, <literal>set</literal>,
        <literal>map</literal>, and <literal>props</literal> elements allow
        properties and arguments of Java type <interfacename>List</interfacename>,
        <interfacename>Set</interfacename>, <interfacename>Map</interfacename>, and
        <interfacename>Properties</interfacename>, respectively, to be defined and
        set.</para>
                <programlisting><![CDATA[<bean id="moreComplexObject" class="example.ComplexObject">
  <!-- results in a setAdminEmails(java.util.Properties) call -->
  <property name="adminEmails">
    <props>
        <prop key="administrator">administrator@somecompany.org</prop>
        <prop key="support">support@somecompany.org</prop>
        <prop key="development">development@somecompany.org</prop>
    </props>
</property>
  <!-- results in a setSomeList(java.util.List) call -->
  <property name="someList">
    <list>
        <value>a list element followed by a reference</value>
        <ref bean="myDataSource" />
    </list>
  </property>
  <!-- results in a setSomeMap(java.util.Map) call -->
  <property name="someMap">
    <map>
        <entry>
            <key>
                <value>yup an entry</value>
            </key>
            <value>just some string</value>
        </entry>
        <entry>
            <key>
                <value>yup a ref</value>
            </key>
            <ref bean="myDataSource" />
        </entry>
    </map>
  </property>
  <!-- results in a setSomeSet(java.util.Set) call -->
  <property name="someSet">
    <set>
        <value>just some string</value>
        <ref bean="myDataSource" />
    </set>
  </property>
</bean>]]></programlisting>
                <para>
                    <emphasis>Note that the value of a map key or value, or a set value, can also
            again be any of the following elements:</emphasis>
                </para>
                <programlisting><![CDATA[bean | ref | idref | list | set | map | props | value | null]]></programlisting>
                <section id="beans-collection-elements-merging">
                    <title>Collection merging</title>
                    <para>
                As of Spring 2.0, the container also supports the <emphasis>merging</emphasis> of collections. This allows
                an application developer to define a parent-style <literal>list</literal>, <literal>map</literal>,
                <literal>set</literal> or <literal>props</literal> element, and have child-style
                <literal>list</literal>, <literal>map</literal>, <literal>set</literal> or <literal>props</literal> elements
                inherit and override values from the parent collection; i.e. the child collection's values will be the
                result obtained from the merging of the elements of the parent and child collections, with the child's
                collection elements overriding values specified in the parent collection.
            </para>
            <para>
                <emphasis>Please note that this section on merging makes use of the parent-child
				bean mechanism. This concept has not yet been introduced, so readers unfamiliar with the
				concept of parent and child bean definitions may wish to read the corresponding section
				before continuing (see <xref linkend="beans-child-bean-definitions" />).</emphasis>
            </para>
            <para>
                An example would perhaps serve best to illustrate this feature...
            </para>
            <programlisting><![CDATA[<beans>
<bean id="parent" abstract="true" class="example.ComplexObject">
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@somecompany.com</prop>
            <prop key="support">support@somecompany.com</prop>
        </props>
    </property>
</bean>
<bean id="child" parent="parent">
    <property name="adminEmails">
        ]]><lineannotation>&lt;!-- the merge is specified on the *child* collection definition --&gt;</lineannotation><![CDATA[
        <props merge="true">
            <prop key="sales">sales@somecompany.com</prop>
            <prop key="support">support@somecompany.co.uk</prop>
        </props>
    </property>
</bean>
<beans>]]></programlisting>
            <para>
                Notice the use of the <literal>merge=true</literal> attribute on the <literal><![CDATA[<props/>]]></literal> element
                of the <literal>adminEmails</literal> property of the <literal>child</literal> bean definition.
                When the <literal>child</literal> bean is actually resolved and instantiated by the
                container, the resulting instance will have an <literal>adminEmails</literal>
                <classname>Properties</classname> collection that contains the result of the merging of the
                child's <literal>adminEmails</literal> collection with the parent's <literal>adminEmails</literal>
                collection.
            </para>
            <programlisting><![CDATA[administrator=administrator@somecompany.com
sales=sales@somecompany.com
support=support@somecompany.co.uk]]></programlisting>
            <para>
                Notice how the child <classname>Properties</classname> collection's value set will have inherited
                all the property elements from the parent <literal><![CDATA[<props/>]]></literal>. Notice also
                how the child's value for the <literal>support</literal> value overrides the attendant
                value in the parent collection.
            </para>
            <para>
                This merging behaviour applies similarly to the <literal>list</literal>, <literal>map</literal>,
                and <literal>set</literal> collection types. In the specific case of the <literal>list</literal>
                element, the semantics associated with the <classname>List</classname> collection type, i.e.
                the notion of an <literal>ordered</literal> collection of values, is maintained... the 
                parent's values will precede all of the child list's values. In the case of the <literal>map</literal>,
                <literal>set</literal>, and <literal>props</literal> collection types, there is no notion of ordering
                and hence no ordering semantics are in effect for the collection types that underly the associated
                <classname>Map</classname>, <classname>Set</classname> and <classname>Properties</classname>
                implementation types used internally by the container.
            </para>
            <para>
                Finally, some minor notes about the merging support are in order; one cannot merge different
                collection types (e.g. a <literal>map</literal> and a <literal>list</literal>), and if one does
                attempt to do so an appropriate <classname>Exception</classname> will be thrown; and in case it
                is not immediately obvious, the <literal>merge</literal> attribute must be specified on the
                lower level, inherited, child definition... specifying the <literal>merge</literal> attribute on
                a parent collection definition is redundant and will not result in the desired merging; and
                (lastly), please note that this merging feature is only available in Spring 2.0 (and later versions).
            </para>
            </section>
            <section>
                <title>Strongly-typed collection (Java5+ only)</title>
                <para>If you are one of the lucky few to be using Java5 (Tiger), you will be aware
                that it is possible (and I daresay recommended) to have strongly typed collections.
                That is, it is possible to declare a <interfacename>Collection</interfacename> type
                such that it can only contain <classname>String</classname> elements (for example).</para>
                <para>If you are using Spring to dependency inject a strongly-typed
                <interfacename>Collection</interfacename> into a bean, you can take advantage
                of Spring's type-conversion support such that the elements of your strongly-typed
                <interfacename>Collection</interfacename> instances will be converted to the
                appropriate type prior to being added to the <interfacename>Collection</interfacename>.</para>
                <para>An example will make this clear; consider the following class definition, and
                it's attendant (XML) configuration...</para>
                <programlisting><![CDATA[public class Foo {
                
    private Map<String, Float> accounts;
    
    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }

}]]></programlisting>
                <programlisting><![CDATA[<beans>
    
    <bean id="foo" class="x.y.Foo">
        
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>

    </bean>

</beans>]]></programlisting>
                <para>When the <literal>'accounts'</literal> property of the <literal>'foo'</literal>
                bean is being prepared for injection, the generics information about the element
                type of the strongly-typed <classname>Map&lt;String, Float&gt;</classname> is
                actually available via reflection, and so Spring's type conversion infrastructure
                will actually recognize the various value elements as being of type <classname>Float</classname>
                and so the string values <literal>'9.99', '2.75'</literal>, and <literal>'3.99'</literal>
                will be converted into an actual <classname>Float</classname> type.</para>
            </section>
            </section>
            <section id="beans-idref-element">
                <title>The <literal>idref</literal> element</title>
                <para>
            The <literal>idref</literal> element is simply an error-proof way to
            pass the <emphasis>id</emphasis> of another bean in the container (to
            a &lt;constructor-arg&gt; or &lt;property&gt; element).
        </para>
        <programlisting><![CDATA[<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean" />
    </property>
</bean>]]></programlisting>
        <para>
            The above bean definition snippet is <emphasis>exactly</emphasis> equivalent
            (at runtime) to the following snippet:
        </para>
        <programlisting><![CDATA[<bean id="theTargetBean" class="..."/>

<bean id="client" class="...">
        <property name="targetName">
            <value>theTargetBean</value>
        </property>
    </bean>]]></programlisting>
		<para>
            The main reason the first form is preferable to
            the second is that using the <literal>idref</literal> tag allows the
            container to validate <emphasis>at deployment time</emphasis> that the
            referenced, named bean actually exists. In the second variation,
            no validation is performed on the value that is passed to the
            <literal>'targetName'</literal> property of the <literal>'client'</literal>
            bean. Any typo will only be discovered (with most likely fatal results)
            when the <literal>'client'</literal> bean is actually instantiated...
            if the <literal>'client'</literal> bean is a
            <link linkend="beans-factory-scopes">prototype</link> bean, this typo
            (and the resulting exception) may only be discovered long after the
            container is actually deployed.
        </para>
        <para>
            Additionally, if the bean being referred to is in the same XML unit, and
            the bean name is the bean <emphasis>id</emphasis>, the
            <literal>local</literal> attribute may be used, which allows the XML
            parser itself to validate the bean name even earlier, at XML document
            parse time.
        </para>
        <programlisting><![CDATA[<property name="targetName">
   ]]><lineannotation>&lt;!--
a bean with an id of 'target' must exist, else an XML exception will be thrown
   --&gt;</lineannotation><![CDATA[
   <idref local="theTargetBean"/>
</property>]]></programlisting>
        <para>
            By way of an example, one common place (at least in pre-Spring 2.0
            configuration) where the &lt;idref/&gt; element brings value is in the
            configuration of <link linkend="aop-pfb-1">AOP interceptors</link> in a
            <classname>ProxyFactoryBean</classname> bean definition. If one uses
            &lt;idref/&gt; elements when specifying the interceptor names, there is
            no chance of inadvertently misspelling an interceptor id.
        </para>
            </section>
            <section id="beans-ref-element">
                <title>The <literal>ref</literal> element</title>
                <para>
            The <literal>ref</literal> element is the final element allowed
            inside a <literal>&lt;constructor-arg/&gt;</literal> or
            <literal>&lt;property/&gt;</literal> definition element. It is used to
            set the value of the specified property to be a reference to another
            bean managed by the container (a collaborator). As
            mentioned in a previous section, the referred-to bean is considered to
            be a dependency of the bean who's property is being set, and will be
            initialized on demand as needed (if it is a singleton bean it may have
            already been initialized by the container) before the property is set.
            All references are ultimately just a reference to another object, but
            there are 3 variations on how the id/name of the other object may be
            specified, which determines how scoping and validation is handled.
        </para>
                <para>
            Specifying the target bean by using the <literal>bean</literal>
            attribute of the <literal>ref</literal> tag is the most general form,
            and will allow creating a reference to any bean in the same
            container (whether or not in the same XML file), or parent container.
            The value of the <literal>'bean'</literal> attribute may be the same as either the
            <literal>'id'</literal> attribute of the target bean, or one of the
            values in the <literal>'name'</literal> attribute of the target bean.
        </para>
                <programlisting><![CDATA[<ref bean="someBean"/>]]></programlisting>
                <para>
            Specifying the target bean by using the <literal>local</literal>
            attribute leverages the ability of the XML parser to validate XML id
            references within the same file. The value of the
            <literal>local</literal> attribute must be the same as the
            <literal>id</literal> attribute of the target bean. The XML parser
            will issue an error if no matching element is found in the same file.
            As such, using the local variant is the best choice (in order to know
            about errors are early as possible) if the target bean is in the same
            XML file.
        </para>
                <programlisting><![CDATA[<ref local="someBean"/>]]></programlisting>
                <para>
            Specifying the target bean by using the <literal>'parent'</literal>
            attribute allows a reference to be created to a bean which is in a
            parent container of the current container. The value of the
            <literal>'parent'</literal> attribute may be the same as either the
            <literal>'id'</literal> attribute of the target bean, or one of the
            values in the <literal>'name'</literal> attribute of the target bean,
            and the target bean must be in a parent container to the current one.
            The main use of this bean reference variant is when there is a need
            to wrap an existing bean in a parent context with some sort of proxy
            (which may have the same name as the parent), and needs the original
            object so it may wrap it.
        </para>
                <programlisting><![CDATA[<ref parent="someBean"/>]]></programlisting>
            </section>
            <section>
                <title id="beans-value-ref-shortcuts"><literal>&lt;value/&gt;</literal> and <literal>&lt;ref/&gt;</literal> shortcut forms</title>
                <para>
            It is so common to need to configure a value or a bean
            reference, that there exist some shortcut forms which are less verbose
            than using the full <literal>&lt;value/&gt;</literal> and
            <literal>&lt;ref/&gt;</literal> elements. The <literal>&lt;property/&gt;</literal>,
            <literal>&lt;constructor-arg/&gt;</literal>, and <literal>&lt;entry/&gt;</literal>
            elements all support a <literal>'value'</literal> attribute which may be
            used instead of embedding a full <literal>&lt;value/&gt;</literal> element.
            Therefore, the following:
        </para>
                <programlisting><![CDATA[<property name="myProperty">
  <value>hello</value>
</property>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg>
  <value>hello</value>
</constructor-arg>]]></programlisting>
                <programlisting><![CDATA[<entry key="myKey">
  <value>hello</value>
</entry>]]></programlisting>
                <para>are equivalent to:</para>
                <programlisting><![CDATA[<property name="myProperty" value="hello"/>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg value="hello"/>]]></programlisting>
                <programlisting><![CDATA[<entry key="myKey" value="hello"/>]]></programlisting>
                <para>
            In general, when typing definitions by hand, you will probably prefer to
            use the less verbose shortcut form (the Spring team certainly do).
        </para>
                <para>
            The <literal>&lt;property/&gt;</literal> and
            <literal>&lt;constructor-arg/&gt;</literal> elements support a similar
            shortcut <literal>'ref'</literal> attribute which may be used instead
            of a full nested <literal>&lt;ref/&gt;</literal> element. Therefore,
            the following:
        </para>
                <programlisting><![CDATA[<property name="myProperty">
  <ref bean="myBean">
</property>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg>
  <ref bean="myBean">
</constructor-arg>]]></programlisting>
                <para>are equivalent to:</para>
                <programlisting><![CDATA[<property name="myProperty" ref="myBean"/>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg ref="myBean"/>]]></programlisting>
                <para>
            Note however that the shortcut form is equivalent to a
            <literal>&lt;ref bean="xxx"&gt;</literal> element; there is no
            shortcut for <literal>&lt;ref local="xxx"</literal>&gt;. To enforce a
            strict local reference, you must use the long form.
        </para>
                <para>
            Finally, the entry element allows a shortcut form to specify the
            key and/or value of the map, in the form of the <literal>'key'</literal>
            / <literal>'key-ref'</literal> and <literal>'value'</literal> /
            <literal>'value-ref'</literal> attributes. Therefore, the
            following:
        </para>
                <programlisting><![CDATA[<entry>
  <key>
    <ref bean="myKeyBean" />
  </key>
  <ref bean="myValueBean" />
</entry>]]></programlisting>
                <para>is equivalent to:</para>
                <programlisting><![CDATA[<entry key-ref="myKeyBean" value-ref="myValueBean"/>]]></programlisting>
                <para>
            Again, the shortcut form is equivalent to a <literal>&lt;ref
            bean="xxx"&gt;</literal> element; there is no shortcut for
            <literal>&lt;ref local="xxx"</literal>&gt;.
        </para>
            </section>
            <section>
                <title id="beans-compound-property-names">Compound property names</title>
                <para>
            Note that compound or nested property names are perfectly legal
            when setting bean properties, as long as all components of the path
            except the final property name are non-null. For example, in this bean
            definition:
        </para>
                <programlisting><![CDATA[<bean id="foo" class="foo.Bar">
  <property name="fred.bob.sammy" value="123" />
</bean>]]></programlisting>
                <para>
            The foo bean has a <literal>fred</literal> property which has a
            <literal>bob</literal> property, which has a <literal>sammy</literal>
            property, and that final <literal>sammy</literal> property is being
            set to a scalar value of 123. In order for this to work, the
            <literal>fred</literal> property of <literal>foo</literal>, and the
            <literal>bob</literal> property of <literal>fred</literal> must both
            be non-null after the bean is constructed, or a
            <classname>NullPointerException</classname> will be thrown.
        </para>
            </section>
        </section>
        <section id="beans-factory-method-injection">
            <title>Method Injection</title>
            <para>For most users, the majority of the beans in the container will be
      singletons. When a singleton bean needs to collaborate with (use)
      another singleton bean, or a non-singleton bean needs to collaborate
      with another non-singleton bean, the typical and common approach of
      handling this dependency by defining one bean to be a property of the
      other, is quite adequate. There is however a problem when the bean
      lifecycles are different. Consider a singleton bean A which needs to use
      a non-singleton (prototype) bean B, perhaps on each method invocation on
      A. The container will only create the singleton bean A once, and thus
      only get the opportunity to set its properties once. There is no
      opportunity for the container to provide bean A with a new instance of
      bean B every time one is needed.</para>
            <para>One solution to this problem is to forgo some inversion of
      control. Bean A can be aware of the container (as described <link linkend="beans-factory-aware-beanfactoryaware">here</link>) by
      implementing<literal> BeanFactoryAware</literal>, and use programmatic
      means (as described <link linkend="beans-factory-client">here</link>) to
      ask the container via a <literal>getBean("B")</literal> call for (a new)
      bean B every time it needs it. This is generally not a desirable
      solution since the bean code is then aware of and coupled to
      Spring.</para>
            <para>Method Injection, an advanced feature of the <interfacename>BeanFactory</interfacename>, allows
      this use case to be handled in a clean fashion, along with some other
      scenarios.</para>
            <section>
                <title>Lookup method Injection</title>
                <para>Lookup method injection refers to the ability of the container
        to override abstract or concrete methods on managed beans in the
        container, to return the result of looking up another named bean in
        the container. The lookup will typically be of a non-singleton bean as
        per the scenario described above (although it can also be a
        singleton). Spring implements this through a dynamically generated
        subclass overriding the method, using bytecode generation via the
        CGLIB library.</para>
                <para>In the client class containing the method to be injected, the
        method definition must be an abstract (or concrete) definition in this
        form:</para>
                <para>
                    <programlisting>protected abstract SingleShotHelper createSingleShotHelper();</programlisting>
                </para>
                <para>If the method is not abstract, Spring will simply override the
        existing implementation. In the XmlBeanFactory case, you instruct
        Spring to inject/override this method to return a particular bean from
        the container, by using the <literal>lookup-method</literal> element
        inside the bean definition. For example:<programlisting>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id="singleShotHelper" class="..." singleton="false"&gt;
&lt;/bean&gt;

&lt;!-- myBean uses singleShotHelper --&gt;
&lt;bean id="myBean" class="..."&gt;
  &lt;lookup-method name="createSingleShotHelper" bean="singleShotHelper"/&gt;
  &lt;property&gt;
    ...
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
                <para>The bean identified as <emphasis>myBean</emphasis> will call its
        own method <literal>createSingleShotHelper</literal> whenever it needs
        a new instance of the <emphasis>singleShotHelper</emphasis> bean. It
        is important to note that the person deploying the beans must be
        careful to deploy <emphasis>singleShotHelper</emphasis> as a
        non-singleton (if that is actually what is needed). If it is deployed
        as a singleton (either explicitly, or relying on the default
        <emphasis>true</emphasis> setting for this flag), the same instance of
        singleShotHelper will be returned each time!</para>
                <para>Note that lookup method injection can be combined with
        Constructor Injection (supplying optional constructor arguments to the
        bean being constructed), and also with Setter Injection (settings
        properties on the bean being constructed).</para>
            </section>
            <section>
                <title>Arbitrary method replacement</title>
                <para>A less commonly useful form of method injection than Lookup
        Method Injection is the ability to replace arbitrary methods in a
        managed bean with another method implementation. Users may safely skip
        the rest of this section (which describes this somewhat advanced
        feature), until this functionality is actually needed.</para>
                <para>In an XmlBeanFactory, the <literal>replaced-method</literal>
        element may be used to replace an existing method implementation with
        another, for a deployed bean. Consider the following class, with a
        method computeValue, which we want to override:<programlisting>...
public class MyValueCalculator {
  public String computeValue(String input) {
    ... some real code
  }

  ... some other methods
}</programlisting></para>
                <para>A class implementing the
        <literal>org.springframework.beans.factory.support.MethodReplacer</literal>
        interface is needed to provide the new method
        definition.<programlisting>/** meant to be used to override the existing computeValue
    implementation in MyValueCalculator */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ... 
        return ...;
}</programlisting></para>
                <para>The <interfacename>BeanFactory</interfacename> deployment definition to deploy the original
        class and specify the method override would look like:<programlisting>&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
  &lt;!-- arbitrary method replacement --&gt;
  &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
    &lt;arg-type&gt;String&lt;/arg-type&gt;
  &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplaceMentComputeValue"/&gt;
</programlisting>One or more contained <literal>arg-type</literal> elements
        within the <literal>replaced-method</literal> element may be used to
        indicate the method signature of the method being overridden. Note
        that the signature for the arguments is actually only needed in the
        case that the method is actually overloaded and there are multiple
        variants within the class. For convenience, the type string for an
        argument may be a substring of the fully qualified type name. For
        example, all the following would match
        <emphasis>java.lang.String</emphasis>.<programlisting>    java.lang.String
    String
    Str</programlisting>Since the number of arguments is often enough to
        distinguish between each possible choice, this shortcut can save a lot
        of typing, by just using the shortest string which will match an
        argument.</para>
            </section>
        </section>
        <section id="beans-factory-dependson">
            <title>Using <literal>depends-on</literal></title>
            <para>
        For most situations, the fact that a bean is a dependency of
        another is expressed simply by the fact that one bean is set as a
        property of another. This is typically done with the
        <literal>ref</literal> element in the XmlBeanFactory. In a variation of
        this, sometimes a bean which is aware of the container is simply given
        the id of its dependency (using a string value or alternately the
        <literal>idref</literal> element, which evaluates the same as a string
        value). The first bean then programmatically asks the container for its
        dependency. In either case, the dependency is properly initialized
        before the dependent bean.
      </para>
            <para>For the relatively infrequent situations where dependencies
			between beans are less direct (for example, when a static initializer in
			a class needs to be triggered, such as database driver registration),
			the <literal>depends-on</literal> element may be used to explicitly
			force one or more beans to be initialized before the bean using this
			element is initialized.</para>
            <para>Find below an example of using <literal>depends-on</literal> to
            express a dependency on a single bean.</para>
            <programlisting><![CDATA[<bean id="beanOne" class="ExampleBean" depends-on="manager">
  <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />]]></programlisting>
            <para>If you need to express a dependency on multiple beans, you can supply a delimited list
            of beans names as the value of the <literal>depends-on</literal> attribute, with commas, whitespace
            and semi-colons all valid delimiters. Find below an example of using <literal>depends-on</literal> to
            express a dependency on a number of beans.</para>
            <programlisting><![CDATA[<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
  <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />]]></programlisting>
        </section>
        <section id="beans-factory-lazy-init">
            <title>Using <literal>lazy-init</literal></title>
            <para>
        When using an <interfacename>ApplicationContext</interfacename> implementation, be aware that
        the contract of the <interfacename>ApplicationContext</interfacename> requires that
        <emphasis>
                    <literal>singleton</literal>
                </emphasis> beans be <emphasis>pre-instantiated</emphasis>
        at startup. Pre-instantiated means that an <interfacename>ApplicationContext</interfacename>
        implementation instance will eagerly create and configure all of it's singleton beans
        as part of its initialization process. This is generally <emphasis>a good thing</emphasis>,
        because it means that any errors in the configuration or in the attendant environment
        will be discovered immediately (as opposed to possibly hours or even days down the line).
      </para>
            <para>
        However, there are times when this behaviour is <emphasis>not</emphasis> what is wanted.
        If you do not want a singleton bean to be pre-instantiated when using
        an <interfacename>ApplicationContext</interfacename> implementation, you can (on
        a bean-definition by bean-definition basis) selectively control this by marking a bean-definition
        as lazy-initialized. A lazily-initialized beans indicates to the IoC container whether or not
        a bean instance should be created at startup or when it is first requested.
      </para>
            <para>
        When one is configuring beans via XML, this lazy loading is controlled by the
        <literal>'lazy-init'</literal> attribute on the <literal>&lt;bean/&gt;</literal>
        element; to wit...
      </para>
            <programlisting><![CDATA[<bean id="lazy" class="com.foo.ExpensiveToCreateBean" lazy-init="true">
    ]]><lineannotation>&lt;!-- various properties here... --&gt;</lineannotation><![CDATA[
</bean>

<bean name="not.lazy" class="com.foo.AnotherBean">
    ]]><lineannotation>&lt;!-- various properties here... --&gt;</lineannotation><![CDATA[
</bean>]]></programlisting>
            <para>
        When the above configuration is consumed by an <interfacename>ApplicationContext</interfacename>
        implementation, the <literal>'lazy'</literal> bean will <emphasis>not</emphasis>
        be eagerly pre-instantiated when the <interfacename>ApplicationContext</interfacename>
        is starting up, whereas the <literal>'not.lazy'</literal> bean will be eagerly pre-instantiated.
      </para>
            <para>
        One thing to understand about lazy-initialization is that even though a bean definition
        may be marked up as being lazy-initialized, if the lazy-initialized bean is the dependency
        of a singleton bean that is not lazy-initialized, when the
        <interfacename>ApplicationContext</interfacename> is eagerly pre-instantiating the singleton,
        it will (of course) have to satisfy all of said singletons's dependencies, one of
        which will be the lazy-initialized bean! So don't be confused if the IoC container
        creates one of the beans that you have explicitly configured as lazy-initialized
        at startup; all that means is that the lazy-initialized bean probably is being injected
        into a non-lazy-initialized singleton bean elsewhere in your configuration.
      </para>
            <para>
        It is also possible to control lazy-initialization at the <interfacename>ApplicationContext</interfacename>
        level by using the <literal>'default-lazy-init'</literal> attribute on the <literal>&lt;beans/&gt;</literal>
        element; to wit...
      </para>
            <programlisting><![CDATA[<beans default-lazy-init="true">
    ]]><lineannotation>&lt;!-- no beans will be eagerly pre-instantiated... --&gt;</lineannotation><![CDATA[
</beans>]]></programlisting>
            <para></para>
        </section>
        <section id="beans-factory-autowire">
            <title>Autowiring collaborators</title>
            <para>
        A <interfacename>BeanFactory</interfacename> is able to <emphasis>autowire</emphasis>
      relationships between collaborating beans. This means that it is possible to
      automatically let Spring resolve collaborators (other beans) for your
      bean by inspecting the contents of the <interfacename>BeanFactory</interfacename>. The autowiring
      functionality has five modes. Autowiring is specified
      <emphasis>per</emphasis> bean and can thus be enabled for some beans,
      while other beans won't be autowired. Using autowiring, it is possible
      to reduce or eliminate the need to specify properties or constructor
      arguments, saving a significant amount of typing.<footnote>
                    <para>See <xref linkend="beans-factory-collaborators" /></para>
                </footnote>In an <classname>XmlBeanFactory</classname>, the autowire mode for a bean
      definition is specified by using the <literal>autowire</literal>
      attribute of the bean element. The following values are allowed.
      <table frame="all">
                    <title>Autowiring modes</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colwidth="1*" />
                        <colspec colname="c2" colwidth="5*" />
                        <thead>
                            <row>
                                <entry>Mode</entry>
                                <entry>Explanation</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>no</entry>
                                <entry>No autowiring at all. Bean references must be defined
                via a <literal>ref</literal> element. This is the default, and
                changing this is discouraged for larger deployments, since
                explicitly specifying collaborators gives greater control and
                clarity. To some extent, it is a form of documentation about
                the structure of a system.</entry>
                            </row>
                            <row>
                                <entry>byName</entry>
                                <entry>Autowiring by property name. This option will inspect
                the <interfacename>BeanFactory</interfacename> and look for a bean named exactly the same as
                the property which needs to be autowired. For example, if you
                have a bean definition which is set to autowire by name, and
                it contains a <emphasis>master</emphasis> property (that is,
                it has a <emphasis>setMaster</emphasis>(...) method), Spring
                will look for a bean definition named <literal>master</literal>, and use it to
                set the property.</entry>
                            </row>
                            <row>
                                <entry>byType</entry>
                                <entry>Allows a property to be autowired if there is exactly
                one bean of the property type in the <interfacename>BeanFactory</interfacename>. If there is
                more than one, a fatal exception is thrown, and this indicates
                that you may not use <emphasis>byType</emphasis> autowiring
                for that bean. If there are no matching beans, nothing
                happens; the property is not set. If this is not desirable,
                setting the <literal>dependency-check="objects"</literal>
                attribute value specifies that an error should be thrown in
                this case.</entry>
                            </row>
                            <row>
                                <entry>constructor</entry>
                                <entry>This is analogous to <emphasis>byType</emphasis>, but
                applies to constructor arguments. If there isn't exactly one
                bean of the constructor argument type in the bean factory, a
                fatal error is raised.</entry>
                            </row>
                            <row>
                                <entry>autodetect</entry>
                                <entry>Chooses <emphasis>constructor</emphasis> or
                <emphasis>byType</emphasis> through introspection of the bean
                class. If a default constructor is found, byType gets
                applied.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table></para>
            <para>
        Note that explicit dependencies in <literal>property</literal> and
        <literal>constructor-arg</literal> settings <interfacename>always</interfacename>
        override autowiring. Please also note that it is not currently possible to autowire
        so-called <emphasis>simple</emphasis> properties such as primitives,
        <classname>Strings</classname>, and <classname>Classes</classname> (and arrays of such
        simple properties).(This is by-design and should be considered a <emphasis>feature</emphasis>.)
        Autowire behavior can be combined with dependency checking, which will
        be performed after all autowiring has been completed.
      </para>
            <para>
        It is important to understand the pros and cons of autowiring. Some advantages of autowiring
        include:
      </para>
            <itemizedlist>
                <listitem>
                    <para>
          Autowiring can significantly reduce the volume of configuration
          required. However, mechanisms such as the use of a configuration
          "template"
          (<link linkend="beans-child-bean-definitions">discussed elsewhere in this chapter</link>)
          are also valuable in this regard.
          </para>
                </listitem>
                <listitem>
                    <para>
            Autowiring can cause configuration to keep itself up to date as your
            objects evolve. For example, if you need to add an additional
            dependency to a class, that dependency can be satisfied
            automatically without the need to modify configuration. Thus there
            may be a strong case for autowiring during development, without
            ruling out the option of switching to explicit wiring when the code
            base becomes more stable.
          </para>
                </listitem>
            </itemizedlist>
            <para>Some disadvantages of autowiring:</para>
            <itemizedlist>
                <listitem>
                    <para>
            Autowiring is more magical than explicit wiring. Although, as noted in
            the above table, Spring is careful to avoid guessing in case of
            ambiguity which might have unexpected results, the relationships
            between your Spring-managed objects is no longer explicitly
            documented.
          </para>
                </listitem>
                <listitem>
                    <para>
            Wiring information may not be available to tools that may
            generate documentation from a Spring container.
          </para>
                </listitem>
                <listitem>
                    <para>Autowiring by type will only work when there is a single bean
          definition of the type specified by the setter method or constructor
          argument. You need to use explicit wiring if there is any potential
          ambiguity.</para>
                </listitem>
            </itemizedlist>
            <para>
        There is no "wrong" or "right" answer in all cases. A degree of
        consistency across a project is best though; for example, if autowiring is
        not used in general, it might be confusing to developers to use it just
        to wire one or two bean definitions.
      </para>
            <section id="beans-factory-autowire-candidate">
                <title>Excluding a bean from being available for autowiring</title>
                <para>
                One can also (on a per bean basis) totally exclude a bean from being an
                autowire candidate. When configuring beans using Spring's XML format, the
                <literal>'autowire-candidate'</literal> attribute of the
                <literal>&lt;bean/&gt;</literal> element can be set to
                <literal>'false'</literal>; this has the effect of making the container
                totally exclude that specific bean definition from being available
                to the autowiring infrastructure.
            </para>
                <para>
                This can be useful when one has a bean that one absolutely never ever
                wants to have injected into other beans via autowiring. It does not
                mean that the excluded bean cannot itself be configured using autowiring...
                it can, it is rather that it itself will not be considered as a candidate
                for autowiring other beans.
            </para>
            </section>
        </section>
        <section id="beans-factory-dependencies">
            <title>Checking for dependencies</title>
            <para>
				Spring has the ability to try to check for the existence of
				unresolved dependencies of a bean deployed into the BeanFactory. These
				are JavaBeans properties of the bean, which do not have actual values
				set for them in the bean definition, or alternately provided
				automatically by the autowiring feature.
			</para>
            <para>
				This feature is sometimes useful when you want to ensure that all
				properties (or all properties of a certain type) are set on a bean. Of
				course, in many cases a bean class will have default values for many
				properties, or some properties do not apply to all usage scenarios, so
				this feature is of limited use. Dependency checking can also be enabled
				and disabled per bean, just as with the autowiring functionality. The
				default is to <emphasis>not</emphasis> check dependencies. Dependency
				checking can be handled in several different modes. In an
				<classname>XmlBeanFactory</classname>, this is specified via the
				<literal>dependency-check</literal> attribute in a bean definition,
				which may have the following values.
			</para>
			<table frame="all">
                <title>Dependency checking modes</title>
                <tgroup cols="2">
                    <colspec colname="c1" colwidth="1*" />
                    <colspec colname="c2" colwidth="5*" />
                    <thead>
                        <row>
                            <entry>Mode</entry>
                            <entry>Explanation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>none</entry>
                            <entry>No dependency checking. Properties of the bean which
            have no value specified for them are simply not set.</entry>
                        </row>
                        <row>
                            <entry>simple</entry>
                            <entry>Dependency checking is performed for primitive types
            and collections (everything except collaborators, i.e. other
            beans)</entry>
                        </row>
                        <row>
                            <entry>object</entry>
                            <entry>Dependency checking is performed for
            collaborators</entry>
                        </row>
                        <row>
                            <entry>all</entry>
                            <entry>Dependency checking is done for collaborators,
            primitive types and collections</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
				If you are using Java5 (and thus have access to source level annotations),
				you may find the section entitled <xref linkend="metadata-annotations-required"/>
				(in the chapter entitled <xref linkend="metadata"/>) to be of interest.
            </para>
        </section>
    </section>
    <section id="beans-factory-nature">
        <title>Customizing the nature of a bean</title>
        <section id="beans-factory-lifecycle">
            <title>Lifecycle interfaces</title>
            <para>Spring provides several marker interfaces to change the behavior
      of your bean in the container. They include
      <interfacename>InitializingBean</interfacename> and
      <interfacename>DisposableBean</interfacename>. Implementing these interfaces will
      result in the container calling
      <literal>afterPropertiesSet()</literal> for the former and
      <literal>destroy()</literal> for the latter to allow the bean to perform
      certain actions upon initialization and destruction.</para>
            <para>Internally, Spring uses <interfacename>BeanPostProcessor</interfacename> implementations to
      process any marker interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <interfacename>BeanPostProcessor</interfacename> yourself. More information about
      this can be found in <xref linkend="beans-factory-customizing" />.</para>
            <para>All the different lifecycle marker interfaces are described below.
      In one of the appendices, you can find diagram that show how Spring
      manages beans and how those lifecycle features change the nature of your
      beans and how they are managed.</para>
            <section id="beans-factory-lifecycle-initializingbean">
                <title>InitializingBean / <literal>init-method</literal></title>
                <para>Implementing the
        <literal>org.springframework.beans.factory.InitializingBean</literal>
        allows a bean to perform initialization work after all necessary
        properties on the bean are set by the container. The
        <interfacename>InitializingBean</interfacename> interface specifies exactly one
        method:
        </para>
        <programlisting><![CDATA[void afterPropertiesSet() throws Exception;]]></programlisting>
                <para>
                    <emphasis>Note: generally, the use of the
        <interfacename>InitializingBean</interfacename> marker interface can be avoided
        (and is discouraged since it unnecessarily couples the code to
        Spring). A bean definition provides support for a generic
        initialization method to be specified. In the case of the
        <classname>XmlBeanFactory</classname>, this is done via the <literal>init-method</literal>
        attribute. For example, the following definition:</emphasis>
                </para>
                <programlisting>&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;

public class ExampleBean {
    public void init() {
        // do some initialization work
    }
}</programlisting>
		<para>Is exactly the same as:</para>
		<programlisting><![CDATA[<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>

public class AnotherExampleBean implements InitializingBean {
    public void afterPropertiesSet() {
        // do some initialization work
    }
}]]></programlisting>
				<para>but does not couple the code to Spring.</para>
            </section>
            <section id="beans-factory-lifecycle-disposablebean">
                <title><interfacename>DisposableBean</interfacename> / <literal>destroy-method</literal></title>
                <para>Implementing the
        <interfacename>org.springframework.beans.factory.DisposableBean</interfacename>
        interface allows a bean to get a callback when the container
        containing it is destroyed. The <interfacename>DisposableBean</interfacename> interface specifies one
        method:
        </para>
        <programlisting><![CDATA[void destroy() throws Exception;]]></programlisting>
                <para>
                    <emphasis>Note: generally, the use of the
        <interfacename>DisposableBean</interfacename> marker interface can be avoided (and
        is discouraged since it unnecessarily couples the code to Spring). A
        bean definition provides support for a generic destroy method to be
        specified. In the case of the <classname>XmlBeanFactory</classname>, this is done via the
        <literal>destroy-method</literal> attribute. For example, the
        following definition: </emphasis>
                </para>
                <programlisting><![CDATA[<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>

public class ExampleBean {
    public void cleanup() {
        // do some destruction work (like closing connection)
    }
}]]></programlisting>
                <para>Is exactly the same as:</para>
			<programlisting><![CDATA[<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>

public class AnotherExampleBean implements DisposableBean {
    public void destroy() {
        // do some destruction work
    }
}]]></programlisting>
			<para>but does not couple the code to Spring.</para>
                <section id="beans-factory-lifecycle-default-init-destroy-methods">
                    <title>Default initialization &amp; destroy methods</title>
                    <para>
                        When one is writing initialization and destroy method callbacks that do not
                        use the Spring-specific <interfacename>InitializingBean</interfacename>
                        and <interfacename>DisposableBean</interfacename> callback interfaces,
                        one (in the experience of this author) typically finds oneself writing
                        methods with names such as <literal>init()</literal>,
                        <literal>initialize()</literal>, <literal>dispose()</literal>,
                        <literal>destroy()</literal>, etc. The names of such lifecycle callback
                        methods are (hopefully!) standardized across a project so that developers
                        on a team all use the same method names and thus ensure some level of
                        consistency.
                    </para>
                    <para>
                        The Spring container can now be configured to <literal>'look'</literal>
                        for named initialization and destroy callback method names on
                        <emphasis>every</emphasis> bean. This means that you as an application developer
                        can simply write your application classes, use a convention of having an
                        initialization callback called <literal>init()</literal>, and then
                        (without having to configure each and every bean with, in the case of XML-based
                        configuration, an <literal>'init-method="init"'</literal> attribute)
                        be safe in the knowledge that the Spring IoC container <emphasis>will</emphasis>
                        call that method when the bean is being created (and in accordance with the
                        standard lifecyle callback contract described previously).
                    </para>
                    <para>
                        Let's look at an example to make the use of this feature completely clear.
                        For the sake of the example, let us say that one of the coding conventions on a
                        project is that all initialization callback methods are to be named
                        <literal>init()</literal> and that destroy callback methods are to be called
                        <literal>destroy()</literal>. This leads to classes like so...
                    </para>
                    <programlisting><![CDATA[public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    ]]><lineannotation>// this is (unsurprisingly) the initialization callback method</lineannotation><![CDATA[
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}]]></programlisting>
            <para>
                The attendant XML configuration for the above class, and making use of the
                by-convention initialization callback method configuration, would look like
                so:
            </para>
            <programlisting><![CDATA[<beans ]]><emphasis role="bold">default-init-method="init"</emphasis><![CDATA[>

    <bean id="blogService" class="com.foo.DefaultBlogService">
        <property name="blogDao" ref="blogDao" />
    </bean>

</beans>]]></programlisting>
                    <para>
                        Notice the use of the <literal>'default-init-method'</literal> attribute on the
                        top-level <literal>&lt;beans/&gt;</literal> element. The presence of this
                        attribute means that the Spring IoC container will recognize a method called
                        <literal>'init'</literal> on beans as being the initialization method callback,
                        and when a bean is being created and assembled, if the bean's class has such
                        a method, it will be invoked at the appropriate time.
                    </para>
                    <para>
                        Destroy method callbacks are configured similarly (in XML that is) using the
                        <literal>'default-destroy-method'</literal> attribute on the top-level
                        <literal>&lt;beans/&gt;</literal> element.
                    </para>
                    <para>
                        The use of this feature can save one the (small) housekeping chore of specifying
                        an initialization and destroy method callback on each and every bean, and it is
                        great for enforcing a consistent naming convention for initialization and destroy
                        method callbacks (and consistency is something that should always be aimed for).
                    </para>
                    <para>
                        One final word... let's say you want to use this feature, but you have some
                        existing beans where the underlying classes already have for example initialization
                        callback methods that are named at variance with the convention. You can
                        <emphasis>always</emphasis> override the default by specifying (in XML that is)
                        the method name using the <literal>'init-method'</literal> and
                        <literal>'destroy-method'</literal> attributes on the <literal>&lt;bean/&gt;</literal>
                        element itself.
                    </para>
                </section>
                <section>
                    <title>Shutting down the Spring IoC container gracefully in non-web applications</title>
                    <note>
                        <para>This next section does not apply to web applications (in case the title of this section
                        did not make that abundantly clear). Spring's web-based <interfacename>ApplicationContext</interfacename>
                        implementations already have code in place to handle shutting down the Spring
                        IoC container gracefully when the relevant web application is being shutdown.</para>
                    </note>
                    <para>If you are using Spring's IoC container in a non-web application environment, for
                    example in a rich client desktop environment, and you want the container to shutdown
                    gracefully and call the relevant destroy callbacks on your singleton beans, you will
                    need to register a shutdown hook with the JVM. This is quite easy to do (see below), and will
                    ensure that your Spring IoC container shuts down gracefully and that all resources
                    held by your singletons are released (of course it is still up to you to both
                    configure the destroy callbacks for your singletons and implement such
                    destroy callbacks correctly).</para>
                    <para>So to register a shutdown hook that enables the graceful shutdown of the relevant Spring
                    IoC container, you simply need to call the <literal>registerShutdownHook()</literal> method
                    that is declared on the <classname>AbstractApplicationContext</classname> class. To wit...</para>
                    <programlisting><![CDATA[import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        AbstractApplicationContext ctx
            = new ClassPathXmlApplicationContext(new String []{"beans.xml"});

        ]]><lineannotation>// add a shutdown hook for the above context... </lineannotation><![CDATA[
        ctx.registerShutdownHook();

        ]]><lineannotation>// app runs here...</lineannotation><![CDATA[

        ]]><lineannotation>// main method exits, hook is called prior to the app shutting down...</lineannotation><![CDATA[
    }
}]]></programlisting>
                </section>
            </section>
        </section>
        <section id="beans-factory-aware">
            <title>Knowing who you are</title>
            <section id="beans-factory-aware-beanfactoryaware">
                <title>
                    <interfacename>BeanFactoryAware</interfacename>
                </title>
                <para>A class which implements the
        <interfacename>org.springframework.beans.factory.BeanFactoryAware</interfacename>
        interface is provided with a reference to the <interfacename>BeanFactory</interfacename> that created
        it, when it is created by that <interfacename>BeanFactory</interfacename>.
        </para>
                <programlisting><![CDATA[public interface BeanFactoryAware {

    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}]]></programlisting>
                <para>
            This allows beans to manipulate the <interfacename>BeanFactory</interfacename>
            that created them programmatically, through the <interfacename>BeanFactory</interfacename>
            interface, or by casting the reference to a known subclass of this
            which exposes additional functionality. Primarily this would consist
            of programmatic retrieval of other beans. While there are cases when
            this capability is useful, it should generally be avoided, since it
            couples the code to Spring, and does not follow the Inversion of
            Control style, where collaborators are provided to beans as properties.
        </para>
                <para>
            An alternative option that is equivalent in effect to the
            <interfacename>BeanFactoryAware</interfacename>-based approach is to use the
            <classname>org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</classname>.
            (It should be noted that this approach still does not reduce the coupling to Spring,
            but it does not violate the central principal of IoC as much as the
            <interfacename>BeanFactoryAware</interfacename>-based approach.)
        </para>
                <para>
            The <classname>ObjectFactoryCreatingFactoryBean</classname> is a
            <link linkend="beans-factory-lifecycle-factorybean">
                        <interfacename>FactoryBean</interfacename>
                    </link>
            implementation that returns a reference to an object (factory) that can in turn be used to
            effect a bean lookup. The
            <classname>ObjectFactoryCreatingFactoryBean</classname> class does itself
            implement the <interfacename>BeanFactoryAware</interfacename> interface... what client
            beans are actually injected with is an instance of the
            <interfacename>ObjectFactory</interfacename> interface. This is a Spring-specific
            interface (and hence there is still no total decoupling from Spring), but clients
            can then use the <interfacename>ObjectFactory</interfacename>'s
            <literal>getObject()</literal> method to effect the bean lookup (under the hood the
            <interfacename>ObjectFactory</interfacename> implementation instance that is returned
            simply delegates down to a <interfacename>BeanFactory</interfacename> to actually
            lookup a bean by name). All that one need do is supply
            the <classname>ObjectFactoryCreatingFactoryBean</classname> with the name of the
            bean that is to be looked up. Let's look at an example:
        </para>
                <programlisting><![CDATA[package x.y;

public class NewsFeed {
    
    private String news;

    public void setNews(String news) {
        this.news = news;
    }

    public String getNews() {
        return this.toString() + ": '" + news + "'";
    }
}]]></programlisting>
                <programlisting><![CDATA[package x.y;

import org.springframework.beans.factory.ObjectFactory;

public class NewsFeedManager {

    private ObjectFactory factory;

    public void setFactory(ObjectFactory factory) {
        this.factory = factory;
    }

    public void printNews() {
        // here is where the lookup is performed; note that there is no
        // need to hardcode the name of the bean that is being looked up...
        NewsFeed news = (NewsFeed) factory.getObject();
        System.out.println(news.getNews());
    }
}]]></programlisting>
                <para>
            Find below the the XML configuration to wire together the above classes
            using the <classname>ObjectFactoryCreatingFactoryBean</classname> approach.
        </para>
                <programlisting><![CDATA[<beans>
    <bean id="newsFeedManager" class="x.y.NewsFeedManager">
        <property name="factory">
            <bean
class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean">
                <property name="targetBeanName">
                    <idref local="newsFeed" />
                </property>
            </bean>
        </property>
    </bean>
    <bean id="newsFeed" class="x.y.NewsFeed" singleton="false">
        <property name="news" value="... that's fit to print!" />
    </bean>
</beans>]]></programlisting>
                <para>
            And here is a small driver program to test the fact that new (prototype)
            instances of the <literal>newsFeed</literal> bean are actually being returned for
            each call to the injected <interfacename>ObjectFactory</interfacename> inside the
            <classname>NewsFeedManager</classname>'s <literal>printNews()</literal> method.
        </para>
                <programlisting><![CDATA[import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.NewsFeedManager;

public class Main {

    public static void main(String[] args) throws Exception {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        NewsFeedManager manager = (NewsFeedManager) ctx.getBean("newsFeedManager");
        manager.printNews();
        manager.printNews();
    }
}]]></programlisting>
                <para>
            The output from running the above program will look like so (results will of course vary
            on your machine).
        </para>
                <programlisting><![CDATA[x.y.NewsFeed@1292d26: '... that's fit to print!'
x.y.NewsFeed@5329c5: '... that's fit to print!']]></programlisting>
                <para>
            The interested reader may also find the <classname>ServiceLocatorFactoryBean</classname>
            (in the <literal>org.springframework.beans.factory.config</literal> package) to be
            of use... the approach is similar to that of the
            <classname>ObjectFactoryCreatingFactoryBean</classname>, but it allows one
            to specify one's own lookup interface as opposed to having to use a Spring-specific
            lookup interface such as the <interfacename>ObjectFactory</interfacename>.
            Consult the (copious) Javadocs for the <classname>ServiceLocatorFactoryBean</classname>
            for a full treatment of this alternative approach (that <emphasis>does</emphasis>
            reduce the coupling to Spring).
        </para>
            </section>
            <section id="beans-factory-aware-beannameaware">
                <title>BeanNameAware</title>
                <para>If a bean implements the
        <literal>org.springframework.beans.factory.BeanNameAware</literal>
        interface and is deployed in a <interfacename>BeanFactory</interfacename>, the <interfacename>BeanFactory</interfacename> will call
        the bean through this interface to inform the bean of the
        <emphasis>id</emphasis> it was deployed under. The callback will be
        Invoked after population of normal bean properties but before an init
        callback like <interfacename>InitializingBean</interfacename>'s
        <emphasis>afterPropertiesSet</emphasis> or a custom
        init-method.</para>
            </section>
        </section>
        <section id="beans-factory-lifecycle-factorybean">
            <title>FactoryBean</title>
            <para>The
      <literal>org.springframework.beans.factory.FactoryBean</literal>
      interface is to be implemented by objects that <emphasis>are themselves
      factories</emphasis>. The FactoryBean interface provides three methods:
      <itemizedlist spacing="compact">
                    <listitem>
                        <para><literal>Object getObject()</literal>: has to return an
            instance of the object this factory creates. The instance can
            possibly be shared (depending on whether this factory returns
            singletons or prototypes).</para>
                    </listitem>
                    <listitem>
                        <para><literal>boolean isSingleton()</literal>: has to return
            <emphasis>true</emphasis> if this FactoryBean returns singletons,
            <emphasis>false</emphasis> otherwise</para>
                    </listitem>
                    <listitem>
                        <para><literal>Class getObjectType()</literal>: has to return
            either the object type returned by the
            <literal>getObject()</literal> method or <literal>null</literal>
            if the type isn't known in advance</para>
                    </listitem>
                </itemizedlist></para>
        </section>
    </section>
    <section id="beans-child-bean-definitions">
        <title>Abstract and child bean definitions</title>
        <para>A bean definition potentially contains a large amount of
    configuration information, including container specific information (i.e.
    initialization method, static factory method name, etc.) and constructor
    arguments and property values. A child bean definition is a bean
    definition which inherits configuration data from a parent definition. It
    is then able to override some values, or add others, as needed. Using
    parent and child bean definitions can potentially save a lot of typing.
    Effectively, this is a form of templating.</para>
        <para>When working with a <interfacename>BeanFactory</interfacename> programmatically, child bean
    definitions are represented by the <literal>ChildBeanDefinition</literal>
    class. Most users will never work with them on this level, instead
    configuring bean definitions declaratively in something like the
    XmlBeanFactory. In an XmlBeanFactory bean definition, a child bean
    definition is indicated simply by using the <literal>parent</literal>
    attribute, specifying the parent bean as the value of this
    attribute.<programlisting>&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass"
    class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBean" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  &lt;!-- age should inherit value of 1 from parent --&gt;
&lt;/bean&gt;</programlisting></para>
        <para>A child bean definition will use the bean class from the parent
    definition if none is specified, but can also override it. In the latter
    case, the child bean class must be compatible with the parent, i.e. it
    must accept the parent's property values.</para>
        <para>A child bean definition will inherit constructor argument values,
    property values and method overrides from the parent, with the option to
    add new values. If init method, destroy method and/or static factory
    method are specified, they will override the corresponding parent
    settings.</para>
        <para>The remaining settings will <emphasis>always</emphasis> be taken
    from the child definition: <emphasis>depends on</emphasis>,
    <emphasis>autowire mode</emphasis>, <emphasis>dependency check</emphasis>,
    <emphasis>singleton</emphasis>, <emphasis>lazy init</emphasis>.</para>
        <para>Note that in the example above, we have explicitly marked the parent
    bean definition as <emphasis>abstract</emphasis> by using the
    <emphasis>abstract</emphasis> attribute. In the case that the parent
    definition does not specify a class:<programlisting>&lt;bean id="inheritedTestBeanWithoutClass"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  &lt;!-- age should inherit value of 1 from parent --&gt;
&lt;/bean&gt;</programlisting></para>
        <para>the parent bean cannot get instantiated on its own since it is
    incomplete, and it's also considered abstract. When a definition is
    considered abstract like this (explicitly or implicitly), it's usable just
    as a pure template or abstract bean definition that will serve as parent
    definition for child definitions. Trying to use such an abstract parent
    bean on its own (by referring to it as a ref property of another bean, or
    doing an explicit getBean() call with the parent bean id, will result in
    an error. Similarly, the container's internal
    <emphasis>preInstantiateSingletons</emphasis> method will completely
    ignore bean definitions which are considered abstract.</para>
        <para><emphasis>Important Note</emphasis>: Application contexts (but not
    simple bean factories) will by default pre-instantiate all singletons.
    Therefore it is important (at least for singleton beans) that if you have
    a (parent) bean definition which you intend to use only as a template, and
    this definition specifies a class, you must make sure to set the
    <emphasis>abstract</emphasis> attribute to <emphasis>true</emphasis>,
    otherwise the application context will actually pre-instantiate it.</para>
    </section>
    <section id="beans-factory-client">
        <title>Interacting with the BeanFactory</title>
        <para>A <interfacename>BeanFactory</interfacename> is essentially nothing more than the interface for an
    advanced factory capable of maintaining a registry of different beans and
    their dependencies. The <interfacename>BeanFactory</interfacename> enables you to read bean definitions
    and access them using the bean factory. When using just the BeanFactory
    you would create one and read in some bean definitions in the XML format
    as follows: <programlisting>InputStream is = new FileInputStream("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);</programlisting></para>
        <para>Basically that's all there is to it. Using
    <literal>getBean(String)</literal> you can retrieve instances of your
    beans. You'll get a reference to the same bean if you defined it as a
    singleton (the default) or you'll get a new instance each time if you set
    <literal>singleton</literal> to <emphasis>false</emphasis>. The
    client-side view of the <interfacename>BeanFactory</interfacename> is surprisingly simple. The
    <interfacename>BeanFactory</interfacename> interface has only five methods for clients
    to call: <itemizedlist spacing="compact">
                <listitem>
                    <para><literal>boolean containsBean(String)</literal>: returns true
          if the <interfacename>BeanFactory</interfacename> contains a bean definition or bean instance that
          matches the given name</para>
                </listitem>
                <listitem>
                    <para><literal>Object getBean(String)</literal>: returns an instance
          of the bean registered under the given name. Depending on how the
          bean was configured by the <interfacename>BeanFactory</interfacename> configuration, either a
          singleton and thus shared instance or a newly created bean will be
          returned. A <literal>BeansException</literal> will be thrown when
          either the bean could not be found (in which case it'll be a
          <literal>NoSuchBeanDefinitionException</literal>), or an exception
          occurred while instantiating and preparing the bean</para>
                </listitem>
                <listitem>
                    <para><literal>Object getBean(String,Class)</literal>: returns a
          bean, registered under the given name. The bean returned will be
          cast to the given Class. If the bean could not be cast,
          corresponding exceptions will be thrown
          (<literal>BeanNotOfRequiredTypeException</literal>). Furthermore,
          all rules of the getBean(String) method apply (see above)</para>
                </listitem>
                <listitem>
                    <para><literal>boolean isSingleton(String)</literal>: determines
          whether or not the bean definition or bean instance registered under
          the given name is a singleton or a prototype. If no bean
          corresponding to the given name could not be found, an exception
          will be thrown
          (<literal>NoSuchBeanDefinitionException</literal>)</para>
                </listitem>
                <listitem>
                    <para><literal>String[] getAliases(String)</literal>: Return the
          aliases for the given bean name, if any were defined in the bean
          definition</para>
                </listitem>
            </itemizedlist></para>
        <section>
            <title>Obtaining a FactoryBean, not its product</title>
            <para>Sometimes there is a need to ask a <interfacename>BeanFactory</interfacename> for an actual
      FactoryBean instance itself, not the bean it produces. This may be done
      by prepending the bean id with <literal>&amp;</literal> when calling the
      <methodname>getBean</methodname> method of <interfacename>BeanFactory</interfacename> (including
      ApplicationContext). So for a given FactoryBean with an id
      <literal>myBean</literal>, invoking <literal>getBean("myBean")</literal>
      on the <interfacename>BeanFactory</interfacename> will return the product of the FactoryBean, but
      invoking <literal>getBean("&amp;myBean")</literal> will return the
      FactoryBean instance itself.</para>
        </section>
    </section>
    <section id="beans-factory-customizing">
        <title>Customizing beans with BeanPostProcessors</title>
        <para>A bean post-processor is a java class which implements the
    <literal>org.springframework.beans.factory.config.BeanPostProcessor</literal>
    interface, which consists of two callback methods. When such a class is
    registered as a post-processor with the <interfacename>BeanFactory</interfacename>, for each bean
    instance that is created by the <interfacename>BeanFactory</interfacename>, the post-processor will get a
    callback from the <interfacename>BeanFactory</interfacename> before any initialization methods
    (<emphasis>afterPropertiesSet</emphasis> and any declared init method) are
    called, and also afterwards. The post-processor is free to do what it
    wishes with the bean, including ignoring the callback completely. A bean
    post-processor will typically check for marker interfaces, or do something
    such as wrap a bean with a proxy. Some Spring helper classes are
    implemented as bean post-processors.</para>
        <para>It is important to know that a <interfacename>BeanFactory</interfacename> treats bean
    post-processors slightly differently than an ApplicationContext. An
    <interfacename>ApplicationContext</interfacename> will automatically detect any beans which are deployed
    into it which implement the <literal>BeanPostProcessor</literal>
    interface, and register them as post-processors, to be then called
    appropriately by the factory on bean creation. Nothing else needs to be
    done other than deploying the post-processor in a similar fashion to any
    other bean. On the other hand, when using plain BeanFactories, bean
    post-processors have to manually be <emphasis>explicitly</emphasis>
    registered, with a code sequence such as the following:</para>
        <programlisting><![CDATA[ConfigurableBeanFactory bf = new .....;     // create BeanFactory
   // now register some beans...
// now register any needed BeanPostProcessors
MyBeanPostProcessor pp = new MyBeanPostProcessor();
bf.addBeanPostProcessor(pp);

// now start using the factory
  ...]]></programlisting>
        <para>Since this manual registration step is not convenient, and
    ApplicationContexts are functionally supersets of BeanFactories, it is
    generally recommended that <interfacename>ApplicationContext</interfacename> implementations are used when bean
    post-processors are needed.</para>
    </section>
    <section id="beans-factory-customizing-factory-postprocessors">
        <title>Customizing bean factories with BeanFactoryPostProcessors</title>
        <para>A bean factory post-processor is a java class which implements the
    <literal>org.springframework.beans.factory.config.BeanFactoryPostProcessor</literal>
    interface. It is executed manually (in the case of the BeanFactory) or
    automatically (in the case of the ApplicationContext) to apply changes of
    some sort to an entire <interfacename>BeanFactory</interfacename>, after it has been constructed. Spring
    includes a number of pre-existing bean factory post-processors, such as
    <literal>PropertyResourceConfigurer</literal> and
    <literal>PropertyPlaceHolderConfigurer</literal>, both described below,
    and <literal>BeanNameAutoProxyCreator</literal>, very useful for wrapping
    other beans transactionally or with any other kind of proxy, as described
    later in this manual. The BeanFactoryPostProcessor can be used to add
    custom editors (as also mentioned in <xref linkend="beans-beanfactory-customeditors" />).</para>
        <para>In a <interfacename>BeanFactory</interfacename>, the process of applying a BeanFactoryPostProcessor
    is manual, and will be similar to this:</para>
        <para>
            <programlisting>XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
// create placeholderconfigurer to bring in some property
// values from a Properties file
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
// now actually do the replacement
cfg.postProcessBeanFactory(factory);</programlisting>
        </para>
        <para><anchor id="beans-factory-autodetect-beanfactorypostprocessors" />An
    <interfacename>ApplicationContext</interfacename> will detect any beans which are deployed into it which
    implement the <literal>BeanFactoryPostProcessor</literal> interface, and
    automatically use them as bean factory post-processors, at the appropriate
    time. Nothing else needs to be done other than deploying these
    post-processor in a similar fashion to any other bean.</para>
        <para>Since this manual step is not convenient, and ApplictionContexts are
    functionally supersets of BeanFactories, it is generally recommended that
    <interfacename>ApplicationContext</interfacename> variants are used when bean factory post-processors are
    needed.</para>
        <section id="beans-factory-placeholderconfigurer">
            <title>The <interfacename>PropertyPlaceholderConfigurer</interfacename></title>
            <para>The <interfacename>PropertyPlaceholderConfigurer</interfacename>, implemented
      as a bean factory post-processor, is used to externalize some property
      values from a <interfacename>BeanFactory</interfacename> definition, into another separate file in Java
      Properties format. This is useful to allow the person deploying an
      application to customize some key properties (for example database URLs,
      usernames and passwords), without the complexity or risk of modifying
      the main XML definition file or files for the BeanFactory.</para>
            <para>Consider a fragment from a <interfacename>BeanFactory</interfacename> definition, where a
      DataSource with placeholder values is defined:</para>
            <para>In the example below, a datasource is defined, and we will
      configure some properties from an external Properties file. At runtime,
      we will apply a <interfacename>PropertyPlaceholderConfigurer</interfacename> to the
      <interfacename>BeanFactory</interfacename> which will replace some properties of the datasource:</para>
            <programlisting><![CDATA[<bean id="dataSource" destroy-method="close"
    class="org.apache.commons.dbcp.BasicDataSource">
  <property name="driverClassName" value="${jdbc.driverClassName}"/>
  <property name="url" value="${jdbc.url}"/>
  <property name="username" value="${jdbc.username}"/>
  <property name="password" value="${jdbc.password}"/>
</bean>]]></programlisting>
            <para>
				The actual values come from another file in the standard Java properties format:
			</para>
            <programlisting><![CDATA[jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root]]></programlisting>
            <para>
				To use this with a <interfacename>BeanFactory</interfacename>, the bean
				factory post-processor is manually executed on it:
			</para>
            <programlisting>XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
cfg.postProcessBeanFactory(factory);</programlisting>
            <para>
				Note that <interfacename>ApplicationContext</interfacename> instances are able to automatically recognize
				and apply beans deployed in them which implement
				<interfacename>BeanFactoryPostProcessor</interfacename>. This means that as described here, applying
				<classname>PropertyPlaceholderConfiguer</classname> is much more convenient when using an
				<interfacename>ApplicationContext</interfacename>. For this reason, it is recommended that users
				wishing to use this or other bean factory postprocessors use an
				<interfacename>ApplicationContext</interfacename> instead of a <interfacename>BeanFactory</interfacename>.
			</para>
            <para>
				The <classname>PropertyPlaceHolderConfigurer</classname> doesn't only
				look for properties in the Properties file you specify, but also checks
				against the Java System properties if it cannot find a property you are
				trying to use. This behavior can be customized by setting the
				<literal>systemPropertiesMode</literal> property of the configurer. It
				has three values, one to tell the configurer to always override, one to
				let it <emphasis>never</emphasis> override and one to let it override
				only if the property cannot be found in the properties file specified.
				Please consult the JavaDoc for the <classname>PropertiesPlaceholderConfigurer</classname> for
				more information.
			</para>
        </section>
        <section id="beans-factory-overrideconfigurer">
            <title>The <literal>PropertyOverrideConfigurer</literal></title>
            <para>The <literal>PropertyOverrideConfigurer</literal>, another bean
      factory post-processor, is similar to the
      <interfacename>PropertyPlaceholderConfigurer</interfacename>, but in contrast to the
      latter, the original definitions can have default values or no values at
      all for bean properties. If an overriding Properties file does not have
      an entry for a certain bean property, the default context definition is
      used.</para>
            <para>Note that the bean factory definition is <emphasis>not</emphasis>
      aware of being overridden, so it is not immediately obvious when looking
      at the XML definition file that the override configurer is being used.
      In case that there are multiple <classname>PropertyOverrideConfigurer</classname> instances that define
      different values for the same bean property, the last one will win (due
      to the overriding mechanism).</para>
            <para>
				Properties file configuration lines are expected to be in the format:
			</para>
			<programlisting><![CDATA[beanName.property=value]]></programlisting>
            <para>
				An example properties file could look like:
			</para>
			<programlisting><![CDATA[dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb]]></programlisting>
            <para>This example file would be usable against a <interfacename>BeanFactory</interfacename> definition
      which contains a bean in it called <emphasis>dataSource</emphasis>,
      which has <emphasis>driver</emphasis> and <emphasis>url</emphasis>
      properties.</para>
            <para>Note that compound property names are also supported, as long as
      every component of the path except the final property being overriden is
      already non-null (presumably initialized by the constructors). In this
      example:</para>
            <para><programlisting>foo.fred.bob.sammy=123</programlisting>the
      <literal>sammy</literal> property of the <literal>bob</literal> property
      of the <literal>fred</literal> property of the <literal>foo</literal>
      bean is being set to the scalar value 123.</para>
        </section>
    </section>
    <section id="beans-beanfactory-customeditors">
        <title>Registering additional custom PropertyEditors</title>
        <para>When setting bean properties as a string value, a BeanFactory
    ultimately uses standard JavaBeans PropertyEditors to convert these
    Strings to the complex type of the property. Spring pre-registers a number
    of custom PropertyEditors (for example, to convert a classname expressed
    as a string into a real <classname>Class</classname> object). Additionally, Java's standard
    JavaBeans <interfacename>PropertyEditor</interfacename> lookup mechanism allows a PropertyEditor for a
    class to be simply named appropriately and placed in the same package as
    the class it provides support for, to be found automatically.</para>
        <para>If there is a need to register other custom PropertyEditors, there
    are several mechanisms available.</para>
        <para>The most manual approach, which is not normally convenient or
    recommended, is to simply use the
    <literal>registerCustomEditor()</literal> method of the
    <interfacename>ConfigurableBeanFactory</interfacename> interface, assuming you have a
    <interfacename>BeanFactory</interfacename> reference.</para>
        <para>The more convenient mechanism is to use a special bean factory
    post-processor called <classname>CustomEditorConfigurer</classname>. Although
    bean factory post-processors can be used semi-manually with <interfacename>BeanFactory</interfacename> implementations,
    this one has a nested property setup, so it is strongly recommended that,
    as described <link linkend="beans-applicationcontext-customeditors">here</link>, it is used
    with the <interfacename>ApplicationContext</interfacename>, where it may be deployed in similar fashion
    to any other bean, and automatically detected and applied.</para>
        <para>Note that all bean factories and application contexts automatically
    use a number of built-in property editors, through their use of something
    called a <interfacename>BeanWrapper</interfacename> to handle property conversions.
    The standard property editors that the <interfacename>BeanWrapper</interfacename> registers are listed in
    the next chapter. Additionally, ApplicationContexts also override or add
    an additional number of editors to handle resource lookups in a manner appropriate
    to the specific application context type; these include:
    <classname>InputStreamEditor</classname>, <classname>ResourceEditor</classname>
    and <classname>URLEditor</classname>.</para>
    </section>
    <section id="beans-beanfactory-alias">
        <title>Using the alias element to add aliases to existing beans</title>
        <para>In a bean definition itself, you may supply more than one name for
    the bean, by using a combination of up to one name specified via the
    <literal>id</literal> attribute, and any number of other names via the
    <literal>alias</literal> attribute. All these names can be considered
    equivalent aliases to the same bean, and are useful for some situations,
    such as allowing each component used in an application to refer to a
    common dependency using a bean name that is specific to that component
    itself.</para>
        <para>Having to specify all aliases when the bean is actually defined is not
    always adequate however. It is sometimes desirable to introduce an alias
    for a bean which is defined elsewhere. This may be done via a standalone
    <literal>alias</literal> element.</para>
        <programlisting><![CDATA[<alias name="fromName" alias="toName"/>]]></programlisting>
        <para>In this case, a bean in the same context which is named
    <literal>fromName</literal>, may also after the use of this alias
    definition, be referred to as <literal>toName</literal>.</para>
        <para>As a concrete example, consider the case where component A defines a
    DataSource bean called componentA-dataSource, in its XML fragment.
    Component B would however like to refer to the DataSource as
    componentB-dataSource in its XML fragment. And the main application,
    MyApp, defines its own XML fragment and assembles the final application
    context from all three fragments, and would like to refer to the
    DataSource as myApp-dataSource. This scenario can be easily handled by
    adding to the MyApp XML fragment the following standalone aliases:</para>
        <programlisting><![CDATA[<alias name="componentA-dataSource" alias="componentB-dataSource"/>
<alias name="componentA-dataSource" alias="myApp-dataSource" />]]></programlisting>
        <para>
        Now each component and the main app can refer to the dataSource via
        a name that is unique and guaranteed not to clash with any other
        definition (effectively there is a namespace), yet they refer to the same
        bean.
    </para>
    </section>
    <section id="context-introduction">
        <title>The <interfacename>ApplicationContext</interfacename></title>
        <para>While the <literal>beans</literal> package provides basic
    functionality for managing and manipulating beans, often in a programmatic
    way, the <literal>context</literal> package adds <literal>
                <ulink url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html">ApplicationContext</ulink>
            </literal>,
    which enhances <interfacename>BeanFactory</interfacename> functionality in a more
    <emphasis>framework-oriented style</emphasis>. Many users will use
    <interfacename>ApplicationContext</interfacename> in a completely declarative fashion, not even having to
    create it manually, but instead relying on support classes such as
    ContextLoader to automatically start an <interfacename>ApplicationContext</interfacename> as part of the
    normal startup process of a J2EE web-app. Of course, it is still possible
    to programmatically create an ApplicationContext.</para>
        <para>The basis for the context package is the
    <interfacename>ApplicationContext</interfacename> interface, located in the
    <literal>org.springframework.context</literal> package. Deriving from the
    <interfacename>BeanFactory</interfacename> interface, it provides all the functionality of <interfacename>BeanFactory</interfacename>.
    To allow working in a more framework-oriented fashion, using layering and
    hierarchical contexts, the context package also provides the following:
    <itemizedlist spacing="compact">
                <listitem>
                    <para><interfacename>MessageSource</interfacename>, providing access to
          messages in, i18n-style</para>
                </listitem>
                <listitem>
                    <para><emphasis>Access to resources</emphasis>, such as URLs and
          files</para>
                </listitem>
                <listitem>
                    <para><emphasis>Event propagation</emphasis> to beans implementing
          the <interfacename>ApplicationListener</interfacename> interface</para>
                </listitem>
                <listitem>
                    <para><emphasis>Loading of multiple (hierarchical)
          contexts</emphasis>, allowing each to be focused on one particular
          layer, for example the web layer of an application</para>
                </listitem>
            </itemizedlist></para>
        <para>As the <interfacename>ApplicationContext</interfacename> includes all functionality of the
    <interfacename>BeanFactory</interfacename>, it is generally recommended that it be used over the
    <interfacename>BeanFactory</interfacename>, except for a few limited situations such as perhaps in an
    <classname>Applet</classname>, where memory consumption might be critical, and a few extra
    kilobytes might make a difference. The following sections described
    functionality which <interfacename>ApplicationContext</interfacename> adds to basic <interfacename>BeanFactory</interfacename>
    capabilities.</para>
    </section>
    <section id="context-functionality">
        <title>Added functionality of the <interfacename>ApplicationContext</interfacename></title>
        <para>As already stated in the previous section, the <interfacename>ApplicationContext</interfacename>
    has a couple of features that distinguish it from the <interfacename>BeanFactory</interfacename>. Let us
    review them one-by-one.</para>
        <section id="context-functionality-messagesource">
            <title>Using the <interfacename>MessageSource</interfacename></title>
            <para>The <interfacename>ApplicationContext</interfacename> interface extends an interface called
      <interfacename>MessageSource</interfacename>, and therefore provides messaging (i18n
      or internationalization) functionality. Together with the
      <classname>NestingMessageSource</classname>, capable of resolving
      hierarchical messages, these are the basic interfaces Spring provides to
      do message resolution. Let's quickly review the methods defined there:
      <itemizedlist spacing="compact">
                    <listitem>
                        <para><literal>String getMessage (String code, Object[] args,
            String default, Locale loc)</literal>: the basic method used to
            retrieve a message from the <interfacename>MessageSource</interfacename>. When no message is
            found for the specified locale, the default message is used. Any
            arguments passed in are used as replacement values, using the
            <literal>MessageFormat</literal> functionality provided by the
            standard library.</para>
                    </listitem>
                    <listitem>
                        <para><literal>String getMessage (String code, Object[] args,
            Locale loc)</literal>: essentially the same as the previous
            method, but with one difference: no default message can be
            specified; if the message cannot be found, a
            <classname>NoSuchMessageException</classname> is thrown.</para>
                    </listitem>
                    <listitem>
                        <para>
							<literal>String getMessage(MessageSourceResolvable
							resolvable, Locale locale)</literal>: all properties used in the
							methods above are also wrapped in a class named
							<interfacename>MessageSourceResolvable</interfacename>, which you can use via
							this method.
						</para>
                    </listitem>
                </itemizedlist></para>
            <para>
				When an <interfacename>ApplicationContext</interfacename> gets loaded, it automatically searches
				for a <interfacename>MessageSource</interfacename> bean defined in the context. The bean has to have
				the name <literal>messageSource</literal>. If such a bean is found, all
				calls to the methods described above will be delegated to the message
				source that was found. If no message source was found, the
				<interfacename>ApplicationContext</interfacename> attempts to see if it has a parent containing a bean
				with the same name. If so, it uses that bean as the <interfacename>MessageSource</interfacename>. If it
				can't find any source for messages, an empty
				<classname>StaticMessageSource</classname> will be instantiated in order to
				be able to accept calls to the methods defined above.
			</para>
            <para>
				Spring currently provides two <interfacename>MessageSource</interfacename>
				implementations. These are the
				<classname>ResourceBundleMessageSource</classname> and the
				<classname>StaticMessageSource</classname>. Both implement
				<classname>NestingMessageSource</classname> in order to do nested messaging.
				The <classname>StaticMessageSource</classname> is hardly ever used but provides programmatic
				ways to add messages to the source. The <classname>ResourceBundleMessageSource</classname> is
				more interesting and is the one we will provide an example for:
      </para>
      <programlisting><![CDATA[<beans>
  <bean id="messageSource"
        class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name="basenames">
      <list>
        <value>format</value>
        <value>exceptions</value>
        <value>windows</value>
      </list>
    </property>
  </bean>
</beans>]]></programlisting>
            <para>This assumes you have three resource bundles defined on your
      classpath called <literal>format</literal>,
      <literal>exceptions</literal> and <literal>windows</literal>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. For the purposes of the example,
      lets assume the contents of two of the above resource bundle files are...</para>
            <programlisting><![CDATA[# in 'format.properties'
message=Alligators rock!]]></programlisting>
            <programlisting><![CDATA[# in 'exceptions.properties'
argument.required=The '{0}' argument is required.]]></programlisting>
            <para>Some (admittedly trivial) driver code to exercise the
        <classname>MessageSource</classname> functionality can be found below. Remember
        that all <classname>ApplicationContext</classname> implementations are also
        <classname>MessageSource</classname> implementations and so can be cast to the
        <classname>MessageSource</classname> interface.</para>
            <programlisting><![CDATA[public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", null);
    System.out.println(message);
}]]></programlisting>
            <para>The resulting output from the above program will be...</para>
            <programlisting><![CDATA[Alligators rock!]]></programlisting>
            <para>So to summarise, the <classname>MessageSource</classname> is defined in a file
        called <literal>'beans.xml'</literal> (this file exists at the root of your classpath).
        The <literal>'messageSource'</literal> bean definition refers to a number
        of resource bundles via it's <literal>basenames</literal> property; the three files
        that are passed in the list to the <literal>basenames</literal> property exist as files
        at the root of your classpath (and are called
        <literal>format.properties</literal>, <literal>exceptions.properties</literal>,
        and <literal>windows.properties</literal> respectively).</para>
            <para>Lets look at another example, and this time we will look at passing arguments
        to the message lookup; these arguments will be converted into strings and inserted
        into placeholders in the lookup message. This is perhaps best explained with an
        example:</para>
            <programlisting><![CDATA[public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", null);
    System.out.println(message);
}]]></programlisting>
            <para>The resulting output from the runnning of the above program will be...</para>
            <programlisting><![CDATA[The 'userDao' argument is required.]]></programlisting>
            <para>With regard to internationalization (i18n), Spring's various
        <classname>MessageResource</classname> implementations follow the same locale resolution
        and fallback rules as the standard JDK ResourceBundle. In short, and continuing with
        the example <literal>'messageSource'</literal> defined previously, if you want to resolve
        messages against the British (en-GB) locale, one would create files called
        <literal>format_en_GB.properties</literal>, <literal>exceptions_en_GB.properties</literal>,
        and <literal>windows_en_GB.properties</literal> respectively.</para>
            <para>Locale resolution is typically going to be managed by the surrounding environment
        of the application. For the purpose of this example though, we'll just manually
        specify the locale that we want to resolve our (British) messages against.</para>
            <programlisting><![CDATA[# in 'exceptions_en_GB.properties'
argument.required=Ebagum lad, the '{0}' argument is required, I say, required.]]></programlisting>
            <programlisting><![CDATA[public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}]]></programlisting>
            <para>The resulting output from the runnning of the above program will be...</para>
            <programlisting><![CDATA[Ebagum lad, the 'userDao' argument is required, I say, required.]]></programlisting>
            <para>The <classname>MessageSourceAware</classname> interface can also be used to acquire
        a reference to any <classname>MessageSource</classname> that has been defined. Any bean
        that is defined in an <classname>ApplicationContext</classname> that implements the
        <classname>MessageSourceAware</classname> interface will be injected with the
        application context's <classname>MessageSource</classname> when it (the bean) is being
        created and configured.</para>
        </section>
        <section id="context-functionality-events">
            <title>Propagating events</title>
            <para>
				Event handling in the <interfacename>ApplicationContext</interfacename> is provided through the
				<classname>ApplicationEvent</classname> class and
				<interfacename>ApplicationListener</interfacename> interface. If a bean which
				implements the <interfacename>ApplicationListener</interfacename> interface is
				deployed into the context, every time an
				<classname>ApplicationEvent</classname> gets published to the
				<interfacename>ApplicationContext</interfacename>, that bean will be notified. Essentially, this is the
				standard <emphasis>Observer</emphasis> design pattern. Spring provides
				three standard events:
			</para>
			<table frame="all">
                <title>Built-in Events</title>
                <tgroup cols="2">
                    <colspec colname="c1" colwidth="2*" />
                    <colspec colname="c2" colwidth="5*" />
                    <thead>
                        <row>
                            <entry>Event</entry>
                            <entry>Explanation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <classname>ContextRefreshedEvent</classname>
                            </entry>
                            <entry>Event published when the <interfacename>ApplicationContext</interfacename> is
            initialized or refreshed. Initialized here means that all
            beans are loaded, singletons are pre-instantiated and the
            <interfacename>ApplicationContext</interfacename> is ready for use</entry>
                        </row>
                        <row>
                            <entry>
                                <classname>ContextClosedEvent</classname>
                            </entry>
                            <entry>Event published when the <interfacename>ApplicationContext</interfacename> is closed,
            using the <literal>close()</literal> method on the
            <interfacename>ApplicationContext</interfacename>. Closed here means that singletons are
            destroyed</entry>
                        </row>
                        <row>
                            <entry>
                                <classname>RequestHandledEvent</classname>
                            </entry>
                            <entry>A web-specific event telling all beans that a HTTP
            request has been serviced (i.e. this will be published
            <emphasis>after</emphasis> the request has been finished).
            Note that this event is only applicable for web applications
            using Spring's <classname>DispatcherServlet</classname></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>
				Implementing custom events can be done as well. Simply call the
				<literal>publishEvent()</literal> method on the <interfacename>ApplicationContext</interfacename>,
				specifying a parameter which is an instance of your custom event class
				implementing <classname>ApplicationEvent</classname>. Event listeners receive events
				synchronously. This means the <literal>publishEvent()</literal> method blocks until all
				listeners have finished processing the event (it is possible to supply
				an alternate event publishing strategy via a
				<interfacename>ApplicationEventMulticaster</interfacename> implementation).
				Furthermore, when a listener receives an event it operates inside the transaction context of
				the publisher, if a transaction context is available.
			</para>
            <para>
				Let's look at an example. First, the <interfacename>ApplicationContext</interfacename>:
            </para>
			<programlisting><![CDATA[<bean id="emailer" class="example.EmailBean">
  <property name="blackList">
    <list>
      <value>black@list.org</value>
      <value>white@list.org</value>
      <value>john@doe.org</value>
    </list>
  </property>
</bean>

<bean id="blackListListener" class="example.BlackListNotifier">
  <property name="notificationAddress" value="spam@list.org"/>
</bean>]]></programlisting>
			<para>
				and then, the actual beans:
			</para>
			<programlisting><![CDATA[public class EmailBean implements ApplicationContextAware {

    /** the blacklist */
    private List blackList;
    
    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }
    
    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }
    
    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent evt = new BlackListEvent(address, text);
            ctx.publishEvent(evt);
            return;
        }
        // send email
    }
}

public class BlackListNotifier implement ApplicationListener {

    /** notification address */
    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent evt) {
        if (evt instanceof BlackListEvent) {
            // notify appropriate person
        }
    }
}]]></programlisting>
			<para>
				Of course, this particular example could probably be
				implemented in better ways (perhaps by using AOP features), but it
				should be sufficient to illustrate the basic event mechanism.
			</para>
        </section>
        <section id="context-functionality-resources">
            <title>Low-level resources and the application context</title>
            <para>
				For optimal usage and understanding of application contexts, users
				should generally familiarize themselves with Spring's
				<interfacename>Resource</interfacename> abstraction, as described
				in the chapter entitled <xref linkend="resources" />.
			</para>
            <para>
				An application context is a <interfacename>ResourceLoader</interfacename>,
				able to be used to load <interfacename>Resource</interfacename>s. A
				<interfacename>Resource</interfacename> is essentially a
				<literal>java.net.URL</literal> on steroids (in fact, it just wraps and
				uses a URL where appropriate), which can be used to obtain low-level
				resources from almost any location in a transparent fashion, including
				from the classpath, a filesystem location, anywhere describable with a
				standard URL, and some other variations. If the resource location string
				is a simple path without any special prefixes, where those resources
				come from is specific and appropriate to the actual application context
				type.
			</para>
            <para>
				A bean deployed into the application context may implement the
				special marker interface, <interfacename>ResourceLoaderAware</interfacename>, to be
				automatically called back at initialization time with the application
				context itself passed in as the <interfacename>ResourceLoader</interfacename>.
			</para>
            <para>
				A bean may also expose properties of type
				<interfacename>Resource</interfacename>, to be used to access static resources, and
				expect that they will be injected into it like any other properties. The
				person deploying the bean may specify those <interfacename>Resource</interfacename>
				properties as simple String paths, and rely on a special JavaBean
				<interfacename>PropertyEditor</interfacename> that is automatically registerd by the context, to
				convert those text strings to actual <interfacename>Resource</interfacename>
				objects.
			</para>
            <para>
				The location path or paths supplied to an <interfacename>ApplicationContext</interfacename>
				constructor are actually resource strings, and in simple form are
				treated appropriately to the specific context implementation (i.e.
				<classname>ClassPathXmlApplicationContext</classname> treats a simple location path as a
				classpath location), but may also be used with special prefixes to force
				loading of definitions from the classpath or a URL, regardless of the
				actual context type.
			</para>
        </section>
    </section>
    <section id="beans-context-customization">
        <title>Customized behavior in the <interfacename>ApplicationContext</interfacename></title>
        <para>
			The <interfacename>BeanFactory</interfacename> already offers a number of
			mechanisms to control the
			lifecycle of beans deployed in it (such as marker interfaces like
			<interfacename>InitializingBean</interfacename> or <interfacename>DisposableBean</interfacename>,
			their configuration only equivalents such as the
			<literal>init-method</literal> and <literal>destroy-method</literal>
			attributes in an <classname>XmlBeanFactory</classname> configuration, and
			bean post-processors. In an
			<interfacename>ApplicationContext</interfacename>, all of these still work,
			but additional mechanisms are
			added for customizing behavior of beans and the container.
			</para>
        <section id="beans-context-applicationcontextaware">
            <title><literal>ApplicationContextAware</literal> marker interface</title>
            <para>
				All marker interfaces available with BeanFactories still work. The
				<interfacename>ApplicationContext</interfacename> does an additional
				extra marker interface which beans may implement,
				<interfacename>org.springframework.context.ApplicationContextAware</interfacename>.
				A bean which implements this interface and is deployed into the context
				will be called back on creation of the bean, using the interface's
				<literal>setApplicationContext(..)</literal> method, and provided with a
				reference to the context, which may be stored for later interaction with
				the context.
			</para>
        </section>
        <section id="beans-context-beanpostprocessor">
            <title>The <interfacename>BeanPostProcessor</interfacename></title>
            <para>
				Bean post-processors, which are simply Java classes that implement the
				<interfacename>org.springframework.beans.factory.config.BeanPostProcessor</interfacename>
				interface, have <link linkend="beans-factory-customizing">already been mentioned</link>.
				It is worth mentioning again here though, that
				post-processors are much more convenient to use in ApplicationContexts
				than in plain BeanFactories. In an <interfacename>ApplicationContext</interfacename>, any deployed bean
				which implements the above marker interface is automatically detected
				and registered as a bean post-processor, to be called appropriately at
				creation time for each bean in the factory.
			</para>
        </section>
        <section id="beans-context-beanfactorypostprocessor">
            <title>The <interfacename>BeanFactoryPostProcessor</interfacename></title>
            <para>
				Bean factory post-processors, which are simply Java classes that implement the
				<interfacename>org.springframework.beans.factory.config.BeanFactoryPostProcessor</interfacename>
				interface, have <link linkend="beans-factory-customizing-factory-postprocessors">already been mentioned</link>.
				It is worth mentioning again here though, that bean
				factory post-processors are much more convenient to use in an
				<interfacename>ApplicationContext</interfacename> than in a plain <interfacename>BeanFactory</interfacename>. In an
				<interfacename>ApplicationContext</interfacename>, any deployed bean which implements the above marker
				interface is automatically detected as a bean factory post-processor, to
				be called at the appropriate time.
			</para>
        </section>
        <section id="beans-context-placeholderconfigurer">
            <title>The <interfacename>PropertyPlaceholderConfigurer</interfacename></title>
            <para>
				The <interfacename>PropertyPlaceholderConfigurer</interfacename> has <link linkend="beans-factory-placeholderconfigurer">already</link> been
				described, as used with a <interfacename>BeanFactory</interfacename>. It is worth mentioning here
				though, that it is generally more convenient to use it with an
				<interfacename>ApplicationContext</interfacename>, since the context will automatically recognize and
				apply any bean factory post-processors, such as this one, when they are
				simply deployed into it like any other bean. There is no need for a
				manual step to execute it.
			</para>
            <programlisting><![CDATA[<!-- property placeholder post-processor -->
<bean id="placeholderConfig"
      class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
  <property name="location" value="jdbc.properties"/>
</bean>]]></programlisting>
        </section>
    </section>
    <section id="beans-applicationcontext-customeditors">
        <title>Registering additional custom <interfacename>PropertyEditor</interfacename> instances</title>
        <para>
			As <link linkend="beans-beanfactory-customeditors">previously</link>
			mentioned, standard JavaBeans <interfacename>PropertyEditor</interfacename>
			instances are used to convert property values expressed as strings to
			the actual complex type of the property.
			<classname>CustomEditorConfigurer</classname>, a bean factory post-processor,
			may be used to conveniently add support for additional
			<interfacename>PropertyEditor</interfacename> instances to an
			<interfacename>ApplicationContext</interfacename>.
		</para>
        <para>
			Consider a user class <classname>ExoticType</classname>, and another
			class <classname>DependsOnExoticType</classname> which needs
			<classname>ExoticType</classname> set as a property:
		</para>
		<programlisting><![CDATA[public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType { 
   
    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}]]></programlisting>
		<para>
			When things are properly set up, we want to be able to
    assign the type property as a string, which a <interfacename>PropertyEditor</interfacename> will behind
    the scenes convert into a real <classname>ExoticType</classname> object:
		</para>
		<programlisting><![CDATA[<bean id="sample" class="example.DependsOnExoticType">
    <property name="type"><value>aNameForExoticType</value></property>
</bean>]]></programlisting>
		<para>
			The <interfacename>PropertyEditor</interfacename> implementation could look similar to this:
		</para>
		<programlisting><![CDATA[// converts string representation to ExoticType object
public class ExoticTypeEditor extends PropertyEditorSupport {

    private String format;

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setAsText(String text) {
        if (format != null &amp;&amp; format.equals("upperCase")) {
            text = text.toUpperCase();
        }
        ExoticType type = new ExoticType(text);
        setValue(type);
    }
}]]></programlisting>
		<para>
			Finally, we use <literal>CustomEditorConfigurer</literal> to
			register the new <interfacename>PropertyEditor</interfacename>
			with the <interfacename>ApplicationContext</interfacename>, which will
			then be able to use it as needed:
		</para>
		<programlisting><![CDATA[<bean id="customEditorConfigurer" 
    class="org.springframework.beans.factory.config.CustomEditorConfigurer">
  <property name="customEditors">
    <map>
      <entry key="example.ExoticType">
        <bean class="example.ExoticTypeEditor">
          <property name="format" value="upperCase"/>
        </bean>
      </entry>
    </map>
  </property>
</bean>]]></programlisting>
    </section>
    <section>
        <title>Setting a bean property or constructor arg from a property expression</title>
        <para>
			<classname>PropertyPathFactoryBean</classname> is a
			<interfacename>FactoryBean</interfacename> that evaluates a property path on a given
			target object. The target object can be specified directly or via a bean
			name. This value may then be used in another bean definition as a property
			value or constructor argument.
		</para>
        <para>
			Here's an example where a path is used against another bean, by name:
		</para>
		<programlisting><![CDATA[// target bean to be referenced by name
<bean id="person" class="org.springframework.beans.TestBean" singleton="false">
  <property name="age"><value>10</value></property>
  <property name="spouse">
    <bean class="org.springframework.beans.TestBean">
      <property name="age"><value>11</value></property>
    </bean>
  </property>
</bean>

// will result in 11, which is the value of property 'spouse.age' of bean 'person'
<bean id="theAge"
    class="org.springframework.beans.factory.config.PropertyPathFactoryBean">
  <property name="targetBeanName" value="person"/>
  <property name="propertyPath" value="spouse.age"/>
</bean>]]></programlisting>
        <para>
			In this example, a path is evaluated against an inner bean:
		</para>
        <programlisting><![CDATA[// will result in 12, which is the value of property 'age' of the inner bean
<bean id="theAge"
    class="org.springframework.beans.factory.config.PropertyPathFactoryBean">
  <property name="targetObject">
    <bean class="org.springframework.beans.TestBean">
      <property name="age" value="12"/>
    </bean>
  </property>
  <property name="propertyPath"><value>age</value></property>
</bean>]]></programlisting>
		<para>
			There is also a shortcut form, where the bean name is the property path.
		</para>
		<programlisting><![CDATA[// will result in 10, which is the value of property 'age' of bean 'person'
<bean id="person.age"
    class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>]]></programlisting>
        <para>
			This form does mean that there is no choice in the name of the bean,
			any reference to it will also have to use the same id, which is the path.
			Of curse, if used as an inner bean, there is no need to refer to it at
			all:
		</para>
        <programlisting><![CDATA[<bean id="..." class="...">
  <property name="age">
    <bean id="person.age"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>
  </property>
</bean>]]></programlisting>
		<para>
			The result type may be specifically set in the actual definition.
			This is not necessary for most use cases, but can be of use for some.
			Please see the JavaDocs for more info on this feature.
		</para>
    </section>
    <section>
        <title>Setting a bean property or constructor arg from a field value</title>
        <para>
			<ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><classname>FieldRetrievingFactoryBean</classname></ulink>
			is a <interfacename>FactoryBean</interfacename> which retrieves a
			<literal>static</literal> or non-static field value. It is typically
			used for retrieving <literal>public</literal> <literal>static</literal>
			<literal>final</literal> constants, which may then be used to set a
			property value or constructor arg for another bean.
		</para>
        <para>
			Find below an example which shows how a <literal>static</literal> field is exposed, by
			using the <ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)"><literal>staticField</literal></ulink>
			property:
		</para>
        <programlisting><![CDATA[<bean id="myField"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean">
  <property name="staticField">
    <value>java.sql.Connection.TRANSACTION_SERIALIZABLE</value>
</property>
</bean>]]></programlisting>
        <para>
			There is also a convenience usage form where the <literal>static</literal> field is
			specified as a bean name:
		</para>
        <programlisting><![CDATA[<bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
    class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/>]]></programlisting>
        <para>
			This does mean that there is no longer any choice in what the bean id is (so
			any other bean that refers to it will also have to use this longer name),
			but this form is very concise to define, and very convenient to use as an
			inner bean since the id doesn't have to be specified for the bean
			reference:
		</para>
        <programlisting><![CDATA[<bean id="..." class="...">
  <property name="isolation">
    <bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
    class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
  </property>
</bean>]]></programlisting>
        <para>
			It is also possible to access a non-static (instance) field of another bean, as described in the
			<ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html">API documentation for the <classname>FieldRetrievingFactoryBean</classname></ulink>
			class.
		</para>
        <para>
			Injecting enum values into beans as either property or contructor arguments is a cinch in
			Spring, in that one doesn't actually have to <emphasis>do</emphasis> anything or know anything
			about the Spring internals (or even about classes such as the
			<classname>FieldRetrievingFactoryBean</classname>). Let's look at an example to see how easy
			injecting an enum value is; consider this JDK 5 enum:
		</para>
        <programlisting><![CDATA[package javax.persistence;
     
public enum PersistenceContextType {
    TRANSACTION,
    EXTENDED
}]]></programlisting>
        <para>
			Now consider a setter of type <classname>PersistenceContextType</classname>:
		</para>
        <programlisting><![CDATA[package example;

public class Client {

    private PersistenceContextType persistenceContextType;

    public void setPersistenceContextType(PersistenceContextType type) { 
        this.persistenceContextType = type;
    }
}]]></programlisting>
        <para>
        .. and the corresponding bean definition:
		</para>
        <programlisting><![CDATA[<bean class="example.Client">
    <property name="persistenceContextType" value="TRANSACTION" />
</bean>]]></programlisting>
        <para>
			This works for classic type-safe emulated enums (on JDK 1.4 and JDK 1.3) as well... Spring will
			automatically attempt to match the string property value to a constant on the enum class.
		</para>
    </section>
    <section>
        <title>Invoking another method and optionally using the return value.</title>
        <para>
			It is sometimes necessary to call a static or instance method in
			one class, just to perform some sort of initialization, before some other
			class is used. Additionally, it is sometimes necessary to set a property
			on a bean, as the result of a method call on another bean in the
			container, or a <literal>static</literal> method call on any arbitrary class. For both of
			these purposes, a helper class called
			<classname>MethodInvokingFactoryBean</classname> may be used. This is a
			<classname>FactoryBean</classname> which returns a
			value which is the result of a <literal>static</literal> or instance method
			invocation.
		</para>
        <para>
			We would however recommend that for the second use case,
			factory-methods, described previously, are a better all around
			choice.
		</para>
        <para>
			An example (in an XML based <interfacename>BeanFactory</interfacename> definition) of a bean
			definition which uses this class to force some sort of <literal>static</literal>
			initialization:
		</para>
        <programlisting><![CDATA[<bean id="force-init"
    class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
  <property name="staticMethod" value="com.example.MyClass.initialize"/>
</bean>

<bean id="bean1" class="..." depends-on="force-init">
  ...
</bean>]]></programlisting>
		<para>
			Note that the definition for the <literal>bean1</literal> bean
			has used the <literal>depends-on</literal>
			attribute to refer to the <literal>force-init</literal> bean, which will
			trigger initializing <literal>force-init</literal> first, and thus calling
			the <literal>static</literal> initializer method, when
			<literal>bean1</literal> is first initialized.
		</para>
        <para>
			Here's an example of a bean definition which uses this class to call
			a <literal>static</literal> factory method:
		</para>
        <programlisting><![CDATA[<bean id="myClass"
    class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
  <property name="staticMethod"
      value="com.whatever.MyClassFactory.getInstance"/>
</bean>]]></programlisting>
        <para>
			Find below an example of calling a <literal>static</literal> method
			then an instance method to get at a Java System property. (Somewhat
			verbose, but it works.)
		</para>
        <programlisting><![CDATA[<bean id="sysProps"
    class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
  <property name="targetClass"><value>java.lang.System</value></property>
  <property name="targetMethod"><value>getProperties</value></property>
</bean>

<bean id="javaVersion"
    class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
  <property name="targetObject"><ref local="sysProps"/></property>
  <property name="targetMethod"><value>getProperty</value></property>
  <property name="arguments">
    <list>
      <value>java.version</value>
    </list>
  </property>
</bean>]]></programlisting>
        <para>
			Note that as it is expected to be used mostly for accessing factory
			methods, <classname>MethodInvokingFactoryBean</classname> by default operates in a
			<emphasis>singleton</emphasis> fashion. The first request by the container
			for the factory to produce an object will cause the specified method
			invocation, whose return value will be cached and returned for the current
			and subsequent requests. An internal <literal>singleton</literal> property
			of the factory may be set to false, to cause it to invoke the target
			method each time it is asked for an object.
		</para>
        <para>
			A <literal>static</literal> target method may be specified by setting the
			<literal>targetMethod</literal> property to a String representing the
			<literal>static</literal> method name, with <literal>targetClass</literal> specifying the
			Class that the <literal>static</literal> method is defined on. Alternatively, a target
			instance method may be specified, by setting the
			<literal>targetObject</literal> property as the target object, and the
			<literal>targetMethod</literal> property as the name of the method to call
			on that target object. Arguments for the method invocation may be
			specified by setting the <literal>arguments</literal> property.
		</para>
    </section>
    <section id="context-import">
        <title>Importing Bean Definitions from One File Into Another</title>
        <para>
			It is often useful to split up container definitions into multiple
			XML files. One way to then load an application context which is configured
			from all these XML fragments is to use the application context constructor
			which takes multiple <interfacename>Resource</interfacename> locations. With a bean factory, a bean
			definition reader can be used multiple times to read definitions from each
			file in turn.
		</para>
        <para>
			Generally, the Spring team prefers the above approach, since it
			keeps container configurations files unaware of the fact that they are
			being combined with others. An alternate approach is to use one or more
			occurrences of the <literal>import</literal> element to load bean definitions
			from another file (or files). Any <literal>import</literal> elements must be
			placed before <literal>bean</literal> elements in the file doing the importing. 
			Let's look at a sample:
		</para>
		<programlisting><![CDATA[<beans>

  <import resource="services.xml"/>

  <import resource="resources/messageSource.xml"/>

  <import resource="/resources/themeSource.xml"/>

  <bean id="bean1" class="..."/>

  <bean id="bean2" class="..."/>
  . . .]]></programlisting>
        <para>
			In this example, external bean definitions are being loaded from 3
			files, <literal>services.xml</literal>,
			<literal>messageSource.xml</literal>, and
			<literal>themeSource.xml</literal>. All location paths are considered
			relative to the definition file doing the importing, so
			<literal>services.xml</literal> in this case must be in the same directory
			or classpath location as the file doing the importing, while
			<literal>messageSource.xml</literal> and
			<literal>themeSource.xml</literal> must be in a
			<literal>resources</literal> location below the location of the importing
			file. As you can see, a leading slash is actually ignored, but given that
			these are considered relative paths, it is probably better form not to use
			the slash at all.
		</para>
        <para>
			The contents of the files being imported must be fully valid XML
			bean definition files according to the DTD, including the top level
			<literal>beans</literal> element.
		</para>
    </section>
    <section id="context-create">
        <title>Creating an <interfacename>ApplicationContext</interfacename> for a web application</title>
        <para>
			As opposed to the <interfacename>BeanFactory</interfacename>, which will
			often be created programmatically,
			<interfacename>ApplicationContext</interfacename> instances can be created
			declaratively using for example a
			<interfacename>ContextLoader</interfacename>. Of course you can also create
			<interfacename>ApplicationContext</interfacename> instances programmatically
			using one of the <interfacename>ApplicationContext</interfacename> implementations.
			First, let's examine the <interfacename>ContextLoader</interfacename> interface
			and its implementations.
		</para>
        <para>
			The <interfacename>ContextLoader</interfacename> interface has two implementations: the
			<classname>ContextLoaderListener</classname> and the
			<classname>ContextLoaderServlet</classname>. They both have the same
			functionality but differ in that the listener cannot be used in Servlet
			2.2 compatible containers. Since the Servlet 2.4 specification, listeners
			are required to initialize after startup of a web application. A lot of
			2.3 compatible containers already implement this feature. It is up to you
			as to which one you use, but all things being equal you should probably
			prefer <classname>ContextLoaderListener</classname>; for more information on
			compatibility, have a look at the JavaDoc for the
			<classname>ContextLoaderServlet</classname>.
		</para>
        <para>
			You can register an <interfacename>ApplicationContext</interfacename> using the
			<classname>ContextLoaderListener</classname> as follows:
		</para>
		<programlisting><![CDATA[<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
</context-param>

<listener>
  <listener-class>
  org.springframework.web.context.ContextLoaderListener
  </listener-class>
</listener>

<!-- OR USE THE CONTEXTLOADERSERVLET INSTEAD OF THE LISTENER
<servlet>
  <servlet-name>context</servlet-name>
  <servlet-class>
  org.springframework.web.context.ContextLoaderServlet
  </servlet-class>
  <load-on-startup>1</load-on-startup>
</servlet>
-->]]></programlisting>
		<para>
			The listener inspects the
			<literal>contextConfigLocation</literal> parameter. If it doesn't exist,
			it'll use <literal>/WEB-INF/applicationContext.xml</literal> as a default.
			When it <emphasis>does</emphasis> exist, it'll separate the String using
			predefined delimiters (comma, semi-colon and space) and use the values as
			locations where application contexts will be searched for. The
			<classname>ContextLoaderServlet</classname> can - as said - be used
			instead of the <classname>ContextLoaderListener</classname>. The servlet
			will use the <literal>'contextConfigLocation'</literal> parameter just
			as the listener does.
		</para>
    </section>
    <section>
        <title>Glue code and the evil singleton</title>
        <para>
			The majority of the code inside an application is best written in a
			DI style, where that code is served out of a <interfacename>BeanFactory</interfacename>
			or <interfacename>ApplicationContext</interfacename> container, has its own
			dependencies supplied by the container when it is created, and is
			completely unaware of the container. However, for the small glue layers of
			code that are sometimes needed to tie other code together, there is
			sometimes a need for singleton (or quasi-singleton) style access to a
			<interfacename>BeanFactory</interfacename> or ApplicationContext. For example,
			third party code may try
			to construct new objects directly (<literal>Class.forName()</literal>
			style), without the ability to force it to get these objects out of a
			<interfacename>BeanFactory</interfacename>. If the object constructed by the third party code is just a
			small stub or proxy, which then uses a singleton style access to a
			<interfacename>BeanFactory</interfacename>/<interfacename>ApplicationContext</interfacename> to get a real object to delegate to, then
			inversion of control has still been achieved for the majority of the code
			(the object coming out of the <interfacename>BeanFactory</interfacename>); thus most code is still
			unaware of the container or how it is accessed, and remains uncoupled from
			other code, with all ensuing benefits. EJBs may also use this stub/proxy
			approach to delegate to a plain java implementation object, coming out of
			a <interfacename>BeanFactory</interfacename>. While the <interfacename>BeanFactory</interfacename> ideally does not have to be a
			singleton, it may be unrealistic in terms of memory usage or
			initialization times (when using beans in the <interfacename>BeanFactory</interfacename> such as a
			Hibernate <interfacename>SessionFactory</interfacename>) for each bean to use its own, non-singleton
			<interfacename>BeanFactory</interfacename>.
		</para>
        <para>
            As another example, in a complex J2EE apps with multiple layers
            (i.e. various JAR files, EJBs, and WAR files packaged as an EAR),
            with each layer having its own
            <interfacename>ApplicationContext</interfacename> definition
            (effectively forming a hierarchy), the preferred approach when
            there is only one web-app (WAR) in the top hierarchy is to simply
            create one composite <interfacename>ApplicationContext</interfacename>
            from the multiple XML definition files from each layer. All of the
            various <interfacename>ApplicationContext</interfacename> implementations
            may be constructed from multiple definition files in this fashion.
            However, if there are multiple sibling web-applications at the root
            of the hierarchy, it is problematic to create an
            <interfacename>ApplicationContext</interfacename> for each web-application
            which consists of mostly identical bean definitions from lower layers,
            as there may be issues due to increased memory usage, issues with
            creating multiple copies of beans which take a long time to initialize
            (i.e. a Hibernate <interfacename>SessionFactory</interfacename>), and
            possible issues due to side-effects. As an alternative, classes such as
            <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html">ContextSingletonBeanFactoryLocator</ulink></literal>
            or
            <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html">SingletonBeanFactoryLocator</ulink></literal>
            may be used to demand load multiple hierarchical (i.e. one is a parent of
            another) <interfacename>BeanFactory</interfacename> or
            <interfacename>ApplicationContext</interfacename> instances in an effectively
            singleton fashion, which may then be used as the parents of the web-application
            <interfacename>ApplicationContext</interfacename> instances. The result
            is that bean definitions for lower layers are loaded only as needed, and 
            loaded only once.
        </para>
        <section>
            <title>Using <classname>SingletonBeanFactoryLocator</classname> and <classname>ContextSingletonBeanFactoryLocator</classname></title>
            <para>
                One can see a detailed example of using
                <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html">SingletonBeanFactoryLocator</ulink></literal>
                and
                <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html">ContextSingletonBeanFactoryLocator</ulink></literal>
                by viewing their respective JavaDocs.
            </para>
            <para>
                As mentioned in the <link linkend="ejb">chapter on EJBs</link>, the
                Spring convenience base classes for EJBs normally use a non-singleton
                <classname>BeanFactoryLocator</classname> implementation, which is easily
                replaced by the use of <classname>SingletonBeanFactoryLocator</classname>
                and <classname>ContextSingletonBeanFactoryLocator</classname> if there is
                a need.
            </para>
        </section>
    </section>
</chapter>