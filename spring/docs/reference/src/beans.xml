<chapter id="beans">

    <title>The Bean Package</title>
    
    <sect1 id="beans-introduction">
    	<title>Introduction</title>

		<para>
			<emphasis>TODO: My idea is to generally describe the beans package for people to get
			a basic understanding of what it does. However, this is quite difficult as you might
			see... I have to take a further look at it... More info on IoC needs to be added and
			also some docs on the type 2 type 3 stuff...
			</emphasis>
		</para>
    	<para>
    		Spring's core is the <literal>org.springframework.beans</literal> package,
    		designed for working with JavaBeans, retrieving objects by name and managing
    		relationships between objects. The beans package and its subpackages provide 
    		functionality for specifying the infrastructure of a project using JavaBeans.
    	</para>
    	<para>
	    	There are three important concepts in the beans package. First of all there's the
	    	<literal>BeanWrapper</literal> which offers functionality for setting and getting
	    	properties of JavaBeans. Secondly, the concept of <literal>BeanFactories</literal> is
	    	important. A BeanFactory is a generic factory, capable of instantiating objects and
	    	manage relationships between different objects. Several different types of beans can
	    	be managed and there's support for initialization and other lifecycle methods.
	    	The BeanFactory basically instantiates <literal>BeanDefinitions</literal>. Bean definitions
	    	are - as the name might incur - the definitions of your beans. A BeanDefinition defines
	    	the class of the bean, the mode it will be instantiated in, but also defines what
	    	collaborators it needs at runtime. Each of the three concepts 
	    	(<emphasis>BeanFactory</emphasis>, <emphasis>BeanWrapper</emphasis> and 
	    	<emphasis>BeanDefinition</emphasis>) will be discussed in much more detail below.
    	</para>
    </sect1>
    
    <sect1 id="beans-beans">
    	<title>Bean manipulation and the <literal>BeanWrapper</literal></title>
    	<para>
    		The <literal>org.springframework.beans</literal> package adheres to the JavaBeans standard
    		provided by Sun. A JavaBean is simply a class with a default no-argument constructor, which
    		follows a naming conventions where a property named <literal>prop</literal> has a setter
    		<literal>setProp(...)</literal> and a getter <literal>getProp()</literal>. For more
    		information about JavaBeans and the specification, please refer to Sun website
    		(<ulink url="http://java.sun.com/products/javabeans/">java.sun.com/products/javabeans</ulink>).
    	</para>
    	<para>
    		One quite important concept of the beans package is the <literal>BeanWrapper</literal>
    		interface and its corresponding implementation (<literal>BeanWrapperImpl</literal>).
    		As quoted from the JavaDoc,  the BeanWrapper offers functionality to set and get property 
    		values (individually or in bulk), get property descriptors and query the readability and
    		writability of properties. Also, the BeanWrapper offers support for
    		nested properties, enabling the setting of properties on subproperties to an unlimited
    		depth. Then, the BeanWrapper support the ability to add standard
    		JavaBeans <literal>PropertyChangeListeners</literal> and <literal>VetoableChangeListeners</literal>,
    		without the need for supporting code in the target class. Last but not least, the
    		BeanWrapper provides support for the setting of indexed properties.	The BeanWrapper 
    		usually isn't used by application code directly, but by the <literal>DataBinder</literal> 
    		and the <literal>BeanFactory</literal>.
    	</para>
    	<para>
    		The way the BeanWrapper works is partly indicated by its name: 
    		<emphasis>it wraps a bean</emphasis> to perform action on that bean, like setting
    		and retrieving properties.
    	</para>
    	
    	<sect2 id="beans-beans-conventions">
    		<title>Setting and getting basic and nested properties</title>
    		<para>
    			Setting and getting properties is done using the <literal>setPropertyValue(s)</literal>
    			<literal>getPropertyValue(s)</literal> methods that both come with a couple of
    			overloaded variants. They're all described in more detail in the JavaDoc Spring
    			comes with. What's important to know that there's a couple of conventions for 
    			indicating properties of an object. A couple of examples:
				<table frame="all">
		            <title>Examples of properties</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="1*"/>
		                <colspec colname="c2" colwidth="5*"/>
		                <thead>
		                    <row>
		                        <entry>Expression</entry>
		                        <entry>Explanation</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry><literal>name</literal></entry>
				            	<entry>Indicates the property <literal>name</literal> corresponding to the
				            		methods <literal>getName()</literal> or <literal>isName()</literal> and
				            		<literal>setName()</literal>
				            	</entry>
				            </row>
				            <row>
				            	<entry><literal>account.name</literal></entry>
				            	<entry>Indicates the nested property <literal>name</literal> of the property
					            	<literal>account</literal> corresponding e.g. to the methods
					            	<literal>getAccount().setName()</literal> or <literal>getAccount().getName()</literal>
					            </entry>
				            </row>
				            <row>
				            	<entry><literal>account[2]</literal></entry>
				            	<entry>Indicates the <emphasis>third</emphasis> element of the indexed property
					            	<literal>account</literal>. Indexed properties can be of type <literal>array</literal>,
					            	<literal>list</literal> or other <emphasis>natural ordered</emphasis> collection
					            </entry>
				            </row>
				        </tbody>
			        </tgroup>
		        </table>
    		</para>
    		
			<para>
				Below you'll find some examples of working with the BeanWrapper to get
				and set properties.
			</para>
    		<para><emphasis>Note: this part is not important to you if you're not planning to
    			work with the BeanWrapper directly. If you're just using the 
    			<literal>DataBinder</literal> and the <literal>BeanFactory</literal> and their
    			out-of-the-box implementation, don't mind reading this and go on with
    			reading about <literal>PropertyEditors</literal>.</emphasis>
    		</para>
       		<para>    
       			Consider the following two classes:			
				<programlisting><![CDATA[
public class Company {
	private String name;
	private Employee managingDirector;
	
	public String getName()	{ 
		return this.name; 
	}
	public void setName(String name) { 
		this.name = name; 
	} 
	public Employee getManagingDirector() { 
		return this.managingDirector; 
	}
	public void setManagingDirector(Employee managingDirector) {
		this.managingDirector = managingDirector;							
	}
}
				]]></programlisting>
				<programlisting><![CDATA[
public class Employee {
	private float salary;
	
	public float getSalary() {
		return salary;
	}						
	public void setSalary(float salary) {
		this.salary = salary;
	}
}					
				]]></programlisting>
			</para>
			<para>
				The following code snippets show some examples of how to retrieve and
				manipulate some of the properties of instantiated:
				<literal>Companies</literal> and <literal>Employees</literal>
				<programlisting><![CDATA[
Company c = new Company();
BeanWrapper bwComp = BeanWrapperImpl(c);
// setting the company name...
bwComp.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue v = new PropertyValue("name", "Some Company Inc.");
bwComp.setPropertyValue(v);

// ok, let's create the director and tie it to the company:
Employee jim = new Employee();
BeanWrapper bwJim = BeanWrapperImpl(jim);
bwJim.setPropertyValue("name", "Jim Stravinsky");					
bwComp.setPropertyValue("managingDirector", jim);

// retrieving the salary of the managingDirector through the company
Float salary = (Float)bwComp.getPropertyValue("managingDirector.salary");
				]]></programlisting>				
			</para>
    	</sect2>
    	
    	<sect2 id="beans-beans-conversion">
    		<title>Converting properties using <literal>PropertyEditors</literal></title>
    		<para>
    			Sometimes it might be handy to be able to represent properties in a different
    			way than the object itself. For example, a date can be represented in a human
    			readable way, while we're still able to convert the human readable form back to
    			the original date (or even better: convert any date entered in a human readable form,
    			back to Date objects). This behavior can be achieved by <emphasis>registering
    			custom editors</emphasis>, of type <literal>java.beans.PropertyEditor</literal>.
    			Registering custom editors to a BeanWrapper gives it the knowledge of how to convert
    			properties to the desired type. Read more about PropertyEditors in the JavaDoc of the
    			<literal>java.beans</literal> package provided by Sun.
    		</para>
    		<para>
    			An example of working with a PropertyEditor convertin <literal>java.util.Date</literal>
    			objects to a form humans understand:
				<programlisting><![CDATA[
/** Details in this class are excluded for brevity */
public class Person {	
	public void setBirthDay(Date d);
	public Date getBirthDay();
}

/** and some other method */
public void doIt() {
	SimpleDateFormat df = new SimpleDateFormat("dd-MM-yyyy");
	// CustomDateEditor located in org.springframework.beans.propertyeditors
	// true indicated that null values are NOT allowed
	CustomDateEditor editor = new CustomDateEditor(df, false);
	
	Person p = new Person();
	BeanWrapper bw = new BeanWrapper(p);
	bw.registerCustomEditor(editor);
	// this will convert the String to the desired object type: java.util.Date!
	bw.setPropertyValue("birthDay", "22-12-1966");
}
				]]></programlisting>				
			</para>
			<para>
				The notion of <literal>PropertyEditors</literal> is quite important to for instance
				the MVC framework, but also other parts of the framework, so in the rest of this
				document, sometimes references to this part occur. For more information on how to
				write custom editors yourself, refer to
				the JavaBeans specification (<ulink url="http://java.sun.com/products/javabeans"/>).
			</para>
		</sect2>  
		
		<sect2 id="beans-beans-event">
			<title>Event propagation</title>
			<para>
				TODO: some info on changelisteners and things like that
			</para>
		</sect2>
		
		<sect2 id="beans-beans-other">
			<title>Other features worth mentioning</title>
			<para>
				Besides the features you've seen in the previous sections there a couple of
				features that might be intereseted to you, though not worth an entire section.
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							<emphasis>determining readability and writability</emphasis>: using
							the <literal>isReadable()</literal> and <literal>isWritable()</literal>
							methods, you can determine whether or not a property is readable or
							writable
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>retrieving propertydescriptors</emphasis>: using
							<literal>getPropertyDescriptor(String)</literal> and
							<literal>getPropertyDescriptors()</literal> you can retrieve
							objects of type <literal>java.beans.PropertyDescriptor</literal>,
							that might come in handy sometimes
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>			  		

    </sect1>
    
    <sect1 id="beans-factory">
    	<title>The BeanFactory</title>
    	<para>
    		The <literal>org.springframework.beans.factory</literal> package and its subpackages
    		provide the basis for Spring's IoC<footnote>
    			<para>
    				Inversion of Control, see <xref linkend="background-ioc"/> for more information
    			</para>
    		</footnote> container. Spring's BeanFactory supports IoC type 2 and 3. More information
    		about this can be found further along.
			The BeanFactory provides a way of obtaining beans by name from a central configuration
			repository, removing the need individual Java objects to read configuration data from
			for instance properties files. Configuration of the object is the responsibility of the
			BeanFactory which makes instances available when needed. Two things are important while
			considering the BeanFactory. First of all the BeanFactory implementations themselves and
			how to retrieve beans using the BeanFactory interface. Secondly, the way BeanFactories know
			about how to instantiate objects and what to do with them before returning them for use.
			The latter is realized using a concept of bean definitions.
    	</para>
    	<sect2 id="beans-factory-definitions">
    		<title>Bean definitions</title>
    		<para>
    			Bean definitions are the specifications of your beans. Beans are classes, providing
    			functionality, but how the BeanFactory is going to manage your beans and how
    			they are configured, is stated in a bean definition. The following is what actually
    			models the bean definition in order to be able to instantiates beans:
    			<itemizedlist spacing="compact">
    				<listitem>
    					<para>
    						The beanclass, which is the actual implementation of the bean related to the
    						bean definition
    					</para>
    				</listitem>
    				<listitem>
    					<para>
    						Bean behavioral configuration elements, which state how the bean should
    						behave in the container (i.e. prototype or singleton, autowiring mode, 
    						dependency checking mode, initialization and destruction methods)
    					</para>
    				</listitem>
    				<listitem>
    					<para>
    						Properties being configuration data for the bean. You could think of the number
    						of connections to use in a bean that manages a connection pool
    						(either specified as properties or as constructor arguments)
    					</para>
    				</listitem>
    				<listitem>
    					<para>
    						Other beans your bean needs to do its work, i.e. <emphasis>collaborators</emphasis>
    						(also specified as properties or as constructor arguments)
    					</para>    					
    				</listitem>
				</itemizedlist>
			</para>
		
			<para>				
				The concepts listed above, directly translate to a set of elements the bean definition consists
				of. These elements are listed below, along with a reference to further documentation about each
				of them.

				<table frame="all">
		            <title>Bean definition explanation</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="2*"/>
		                <colspec colname="c2" colwidth="4*"/>
		                <thead>
		                    <row>
		                        <entry>Feature</entry>
		                        <entry>More info</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry>class</entry>
				            	<entry><xref linkend="beans-factory-class"/></entry>
				            </row>
				            <row>
								<entry>singleton or prototype</entry>
								<entry><xref linkend="beans-factory-modes"/></entry>
				            </row>
					        <row>
					        	<entry>bean properties</entry>
					        	<entry><xref linkend="beans-factory-collaborators"/></entry>
						    </row>
					        <row>
					        	<entry>constructor arguments</entry>
					        	<entry><xref linkend="beans-factory-collaborators"/></entry>
						    </row>
				            <row>
				            	<entry>autowiring mode</entry>
				            	<entry><xref linkend="beans-factory-autowire"/></entry>
					        </row>
				            <row>
				            	<entry>dependency checking mode</entry>
				            	<entry><xref linkend="beans-factory-dependencies"/></entry>
				            </row>
					        <row>
					        	<entry>initialization method</entry>
					        	<entry><xref linkend="beans-factory-lifecycle"/></entry>
						    </row>
					        <row>
					        	<entry>destruction method</entry>
					        	<entry><xref linkend="beans-factory-lifecycle"/></entry>
						    </row>
				        </tbody>
			        </tgroup>
		        </table>
		    </para>
		    
		    <para>
		    	All the features described above will be configurable for each of your beans using
		    	one of the out-of-the-box BeanFactory implementation (like
		    	<literal>XmlBeanFactory</literal>). More information about each of the features
		    	will be found below.
		    </para>
		</sect2>
		
		<sect2 id="beans-factory-class">
			<title>The bean class</title>
			<para>
				Of course you need to specify the actual class of your bean, that should be obvious.
				There's absolutely no special requirements to your beanclass, it does not have to
				implement a special interface to make it Spring compatible. Just specifying the bean class
				should be enough. However, dependending on what type of IoC you're going to use for that specific
				bean, you should have a default constructor.
			</para>
			<para>
				The BeanFactory cannot only manage beans, but is able to manage 
				virtually <emphasis>any</emphasis> class you want it to manage. Most people using Spring
				prefer to have actual beans (having just a default constructor and appropriate setters
				and getters modelled after the properties) in the BeanFactory, but it it's also possible
				to have more exotic non-bean-style classes in your BeanFactory. If for example you're having
				a legacy connectionpool that absolutely does not adhere to the bean specification, no worries,
				Spring can manage it as well.
			</para>
		</sect2>
    	
    	<sect2 id="beans-factory-modes">
    		<title>To singleton or not to singleton</title>
    		<para>
    			Beans exist in two types, singletons and prototypes. When a bean is a singleton,
    			only one <emphasis>shared</emphasis> instance of the bean will be managed and all
    			requests for instances of that specific instances of bean will result in that one 
    			specific bean instance being returned.
    		</para>
    		<para>
    			The prototype mode of a bean results in <emphasis>creation of a new bean instance</emphasis>
    			every time a request for that specific bean is being done. This is ideal for situation
    			where for example each user needs an independent user object or something similar.
    		</para>
    		<para>
    			Beans exist in singleton mode by default, unless you specify otherwise. Keep in mind that by changing
    			the type to prototype, each request for a bean will result in a newly created bean and this
    			might not be what you actually want. So only change the mode to prototype when absolutely
    			necessary.
    		</para>
		</sect2>
		
		<sect2 id="beans-factory-collaborators">
			<title>Setting beans properties and collaborators</title>
			<para>
				The basic principle of IoC (Inversion of Control) is often referred to as the
				<emphasis>Hollywood Principle</emphasis> (<quote>don't call us, we'll call you!</quote>).
				The idea is that beans don't specify themselves who they're collaborating with
				and what additional properties they need. Also
				the client(s) that use the beans don't specify it. Instead (in case of Spring IoC), the
				BeanFactory takes care of resolving collaborators and giving them to the beans. This is
				done using the bean definitions discussed earlier. In the BeanDefinition structure,
				collaborators and properties are specified using 
				<literal>PropertyValue</literal> objects, which are used when insantiating a bean to resolve 
				references.
			</para>				
			<para>
				<emphasis>It's very important</emphasis> to understand the concept of IoC beacuse this is
				one of the basics of Spring and will make your applications much more elegant, configurable
				and maintainable. Configure each and every collaborator and property using the BeanDefinitions
				(for more information about the implementation have a look at one of the next sections)!
			</para>
			<para>
				The resolving of the dependencies is a little too complex to go get into it in depth here,
				the basic procedure is as follows:
				<orderedlist spacing="compact">
					<listitem>
						<para>Checking what the type of the property is (this can be a primitive-like type - 
							like int or String - or a collection - i.e. Map or List - or a collaborator). Collaborators
							are other beans the BeanFactory must capable of resolving
						</para>
					</listitem>
					<listitem>
						<para>In case of the first two options (primitive or collection), Spring constructs the
							collection and adds it to the bean definition as a PropertyValue
						</para>
					</listitem>
					<listitem>
						<para>In case of a collaborator, Sprign constructs a <literal>RuntimeBeanReference</literal>
							that is used later on when the bean is actually instantiated. Spring then actually resolves
							the instance of the collaborator and sets it on the bean
						</para>
					</listitem>
				</orderedlist>
			</para>
			<para>
				The setting of properties and collaborators can be done in two ways, which correspond to two of the
				different IoC types<footnote>
					<para>For more information about IoC types, see <xref linkend="background-ioc"/></para>
				</footnote>, namely type 2 and type 3. The type 2 support, will set the dependencies on a bean using 
				setter methods, IoC type 3 support will set the dependencies using constructor arguments.
				It's best to explain things using a concrete implementation of a BeanFactory. We will use the
				<literal>XmlBeanFactory</literal><footnote>
					<para>See <xref linkend="beans-factoryimpl"/> for more information about BeanFactory implementations</para>
				</footnote> here, which - as the name implies - stores bean definition in XML.
			</para>
			<para>
				First, an example of using the BeanFactory for IoC type 2 (using setters). Below, there's a small part of an
				XML file specifying bean definition. Also, you can find the actual bean itself, having the appropriate
				setters declared.
				<programlisting><![CDATA[
<bean id="exampleBean" class="examples.ExampleBean">
	<property name="beanOne"><ref bean="anotherExampleBean"/></property>
	<property name="beanTwo"><ref bean="yetAnotherBean"/></property>
	<property name="integerProperty">1</property>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
				]]></programlisting>
				
				<programlisting><![CDATA[
public class ExampleBean {
	
	private AnotherBean beanOne;
	private YetAnotherBean beanTwo;
	private int i;
	
	public void setBeanOne(AnotherBean beanOne) {
		this.beanOne = beanOne;
	}
	
	public void setBeanTwo(YetAnotherBean beanTwo) {
		this.beanTwo = beanTwo;
	}
	
	public void setIntegerProperty(int i) {
		this.i = i;
	}	
}
				]]></programlisting>
				
				As you can, setters have been declared to match against the properties specified in the XML file. (The properties
				from the XML file, directly relate to the <literal>PropertyValues</literal> object from the <literal>RootBeanDefinition</literal>)				
			</para>
			<para>
				Then, an example of using the BeanFactory for IoC type 3 (using constructors). Below you can find a snippet from
				an XML configuration file that specifies constructor arguments and the actual bean, specifying the constructor
				<programlisting><![CDATA[	
<bean id="exampleBean" class="examples.ExampleBean">
	<constructor-arg><ref bean="anotherExampleBean"/></constructor-arg>
	<constructor-arg><ref bean="yetAnotherBean"/></constructor-arg>
	<constructor-arg>1</constructor-arg>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
				]]></programlisting>
				
				<programlisting><![CDATA[
public class ExampleBean {

	private AnotherBean beanOne;
	private YetAnotherBean beanTwo;
	private int i;
	
	public ExampleBean(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
		this.beanOne = anotherBean;
		this.beanTwo = yetAnotherBean;
		this.i = i;
	}
}
				]]></programlisting>
				
				As you can see, the constructor arguments specified in the bean definition will be used to pass in as
				arguments to the constructor of the <literal>ExampleBean</literal>.	
			</para>
			
		</sect2>
		
		<sect2 id="beans-factory-autowire">	
			<title>Autowiring collaborators</title>
			<para>
				Spring has autowire capabilities, which means it's possible to automatically let Spring
				resolve collaborators (other beans) for you bean by inspecting the BeanFactory. The autowiring
				functionality has four modes. Autowiring is specified <emphasis>per</emphasis> bean and 
				can thus be enabled for a couple of beans, while other beans won't be autowired.
				When using autowiring, there might be no need for specifying properties or constructor 
				arguments<footnote>
					<para>See <xref linkend="beans-factory-collaborators"/></para>
				</footnote>
				
				<table frame="all">
		            <title>Autowiring modes</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="1*"/>
		                <colspec colname="c2" colwidth="5*"/>
		                <thead>
		                    <row>
		                        <entry>Mode</entry>
		                        <entry>Explanation</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry>no</entry>
				            	<entry>No autowiring at all. This is the default value and
				            		it's discouraged to change this for large applications,
				            		since specifying your collaborators yourself gives you a feeling
				            		of what you're actually doing and is a great way of
				            		somewhat documenting the structure of your system</entry>
				            </row>
				            <row>
								<entry>byName</entry>
								<entry>This option will inspect the BeanFactory and look for a bean
									named exactly the same as the property which needs to be autowired.
									So in case you have a collaborator on a BeanDefinition Cat which is called
									dog (so you have a setDog(Dog) method), Spring will look for a BeanDefinition
									named <literal>dog</literal> and use this as the collaborator
								</entry>
				            </row>
				            <row>
				            	<entry>byType</entry>
				            	<entry>This option can be found in some other IoC containers as well and gives
					            	you the ability to resolve collaborators by type instead of by name. Suppose
					            	you have a BeanDefinition with a collaborator typed <literal>DataSource</literal>,
					            	Spring will search the entire bean factory for a bean definition of type
					            	DataSource and use it as the collaborator. <emphasis>If 0 (zero) or more than
					            	1 (one) bean definitions of the desired exist in the BeanFactory, a failure
					            	will be reported and you won't be able to use autowiring for that specific bean</emphasis>
				            	</entry>
				            </row>
				        </tbody>
			        </tgroup>
		        </table>
		        <emphasis>Note: like already mentioned, for larger application it's discourage to use
		        autowiring beacuse it removes the transparency and the structure from your collaborating
		        classes.</emphasis>
			</para>
		</sect2>
		
		<sect2 id="beans-factory-dependencies">
			<title>Checking for dependencies</title>
			<para>
				Spring also offers the capability for checking required dependencies of your beans.
				This feature might come in handy when certain properties really need to be set and
				when you can't provide default values (which is an often used approach). Dependency
				checking can be done in three different ways. Dependency checking can also be
				enabled and disabled per bean, just as the autowiring functionality. The default is
				to <emphasis>not</emphasis> check dependencies.
				<table frame="all">
		            <title>Dependency checking modes</title>
		            <tgroup cols="2">
		                <colspec colname="c1" colwidth="1*"/>
		                <colspec colname="c2" colwidth="5*"/>
		                <thead>
		                    <row>
		                        <entry>Mode</entry>
		                        <entry>Explanation</entry>
		                    </row>
		                </thead>
			            <tbody>
				            <row>
				            	<entry>simple</entry>
				            	<entry>Dependency checking is done for primitive types and 
					            	collections (this means everything except collaborators)
					            </entry>
					        </row>
				            <row>
								<entry>object</entry>
								<entry>Dependency checking is done for collaborators</entry>
							</row>
				            <row>
				            	<entry>all</entry>
				            	<entry>Dependecny checking is done for both collaborators and
				            		primitive types and collections
				            	</entry>
				            </row>
				        </tbody>
			        </tgroup>
		        </table>
			</para>
		</sect2>
		
<sect2 id="beans-factory-lifecycle">
	    	<title>Bean Nature and Lifecycle Features</title>
	    	<para>
	    		Spring provides a couple of marker interfaces and some other features that allow
	    		customizing the nature and the lifecycle of a bean managed by a beanfactory. 
	    		Each of the marker interfaces as well as the other features and the the functionality
	    		they offer are described below.
	    	</para>
	    	
			<sect3 id="beans-factory-lifecycle-factorybean">
	    		<title>FactoryBean</title>
		    	<para>
		    		The <literal>org.springframework.beans.factory.FactoryBean</literal> is to be implemented
		    		objects that <emphasis>are themselves factories</emphasis>. The BeanFactory interface
		    		provides three method:
					<itemizedlist spacing="compact">
						<listitem>
							<para>
								<literal>Object getObject()</literal>: has to return an instance of
								the object this factory creates. The instance can possibly be shared
								(depending on this factory providing singleton or prototypes).
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>boolean isSingleton()</literal>: has to return <literal>true</literal>
								if this FactoryBean returns singletons, <literal>false</literal> otherwise
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>Class getObjectType()</literal>: has to return either
								the object type returned by the <literal>getObject()</literal> method or
								<literal>null</literal> if the type isn't known in advance
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</sect3>
			
			<sect3 id="beans-factory-lifecycle-initializingbean">
				<title>InitializingBean</title>
				<para>
					The <literal>org.springframework.beans.factory.InitializingBean</literal> gives
					you the ability the do initialization work after all necessary properties on a
					bean are set by the BeanFactory. The InitializingBean interface specifies exactly
					one method:
					<itemizedlist spacing="compact">
						<listitem>
							<para>
								<literal>void afterPropertiesSet()</literal>: called after all
								properties have been set by the beanfactory. This method enables you
								to do checking if all necessary properties have been set correctly, or
								to perform initialization work. You can throw <emphasis>any</emphasis>
								exception to indicate misconfiguration, initialization failures, etcetera
							</para>
						</listitem>
					</itemizedlist>
				</para>
				
				<para>
					<emphasis>Note: generally, the use of the <literal>InitializingBean</literal> can
					be avoided (and by some people is discouraged). The beans package provides support
					for a generic init-method, given to the beandefinition in the beanconfiguration store
					(may it be XML, properties-files or a database). For more information about this
					feature, see the next section)</emphasis>
				</para>
			</sect3>
			
			<sect3 id="beans-factory-lifecycle-initmethod">
				<title>init-method</title>
				<para>
					Besides the InitializingBean, Spring also offers a less intrusive way of defining
					an initialization method on your beans. Each of the implementations of the BeanFactory
					specifies this features in a different way, but they all have the same result: 
					a no-argument method getting called after all properties have been set and <emphasis>
					also after the <literal>afterPropertiesSet()</literal> method from InitializingBean 
					has been called</emphasis>. TODO INCLUDE REFERENCE TO DIFFERENT WAYS TO SPECIFY INIT_METHODS????
				</para>
			</sect3>
			
			<sect3 id="beans-factory-lifecycle-disposablebean">
				<title>DisposableBean</title>
				<para>
					The <literal>org.springframework.beans.factory.DisposableBean</literal> interface
					provides you with the ability to get a callback when a beanfactor is destroyed.
					The DisposableBean interface specifies one method:
					<itemizedlist spacing="compact">
						<listitem>
							<para>
								<literal>void destroy()</literal>: called on destruction of
								the beanfactory. This allows you to release any resources you are
								keeping in this bean (like database connections). You can throw
								an exception here, however, it will not stop the destruction of the bean
								factory. It will get logged though.
							</para>
						</listitem>
					</itemizedlist>
				</para>
				<para>
					<emphasis>Note: generally, the use of the <literal>DisposableBean</literal> can
					be avoided (and by some people is discouraged). The beans package provides support
					for a generic destroy-method, given to the beandefinition in the beanconfiguration store
					(may it be XML, properties-files or a database). For more information about this
					feature, see the next section)</emphasis>
				</para>
			</sect3>
			
			<sect3 id="beans-factory-lifecycle-destroymethod">
				<title>destroy-method</title>
				<para>
					Besides the Disposable, Spring also offers a less intrusive way of defining
					an destroy methods on your beans. Each of the implementations of the BeanFactory
					specifies this features in a different way, but they all have the same result: 
					a no-argument method getting called after all properties have been set and <emphasis>
					also after the <literal>destroy()</literal> method from 
					DisposableBean has been called</emphasis>.
					TODO INCLUDE REFERENCE TO DIFFERENT WAYS TO SPECIFY DESTROY_METHODS????
				</para>
			</sect3>
			
			<sect3 id="beans-factory-lifecycle-beanfactoryaware">
				<title>BeanFactoryAware</title>
				<para>
					The <literal>org.springframework.beans.factory.BeanFactoryAware</literal> interface
					gives you the ability to get a reference to the BeanFactory that manages the bean
					that implements the BeanFactoryAware interface. This feature allows for implementing
					beans to look up their collaborators in the beanfactory. The interface specifies one
					method:
					<itemizedlist spacing="compact">
						<listitem>
							<para>
								<literal>void setBeanFactory(BeanFactory)</literal>: method that will
								be called <emphasis>after the initialization methods</emphasis>
								(<literal>afterPropertiesSet</literal> and the init-method).
							</para>
						</listitem>
					</itemizedlist>
				</para>
			</sect3>
		</sect2>	
		
		<sect2 id="beans-factory-client">
			<title>Clients interacting with the factory</title>
			<para>
				The client-side view of the BeanFactory is surprisingly simple. The 
				<literal>BeanFactory</literal> interface four methods for clients to interact with
				it:
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							<literal>Object getBean(String)</literal>: returns an instance of the
							bean registered under the given name. Depending on how the bean was
							configured by the beanfactory configuration, a singleton and thus shared
							instance will be returned, or a newly created bean. A 
							<literal>BeansException</literal> will be thrown when either the
							bean could not be found (in which it'll be a <literal>NoSuchBeanDefinitionException</literal>),
							or an exception occured while instantiated and preparing the bean
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>Object getBean(String,Class)</literal>: returns a
							bean, registered under the given name. The bean returned will be cast
							to the given Class. If the bean could not be cast, corresponding exceptions
							will be thrown (<literal>BeanNotOfRequiredTypeException</literal>). Furthermore,
							all rules of the getBean(String) method apply (see above)
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>boolean isSingleton(String)</literal>: determines whether or not
							the beandefinition registered under the given name is a singleton or
							a prototype. If the beandefinition could corresponding the given name
							could not ben found, and exception will be thrown 
							(<literal>NoSuchBeanDefinitionException</literal>)							
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>String[] getAliases(String)</literal>: returns
							the aliases configured for this bean (TODO: WHAT IS THIS :)							
						</para>
					</listitem>					
				</itemizedlist>
			</para>
		</sect2>
		
		<sect2 id="beans-factory-diagrams">
			<title>Lifecycle of a bean in the BeanFactory</title>
			<para>
				This section describes the lifecycle of a bean in the BeanFactory, 
				some of the basic characteristics of events happening in the BeanFactory as well
				as the different types of beans.
			</para>
			
			<sect3 id="beans-factory-diagrams-lifecycle">
				<title>The basic lifecycle of a bean</title>
				<para>
					The lifecycle of a bean begins with a bean definition, for instance defined
					in XML or a properties file. The first step is the calling of the default constructor:
					
					<orderedlist spacing="compact">
						<listitem>
							<para>
								default constructor
							</para>
						</listitem>
					</orderedlist>

				</para>
				<para>
					The second step is the initialization process in which you can prepare your bean
					for use.
					<orderedlist spacing="compact" continuation="continues">
						<listitem>
							<para>
								the autowiring process in which any possible collaborators that can
								be automatically resolved, will be set (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								checking of dependencies, which means that if dependencies are satisfied
								(i.e. they are <literal>null</literal>), an <literal>UnsatisfiedDependencyException</literal>
								will be thrown. (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								property setting, which means that all properties defined with the bean definition
								in for instance an XML file, will be set on the bean
							</para>
						</listitem>
						<listitem>
							<para>
								<literal>afterPropertiesSet()</literal> is called. This method is specified by the
								<literal>InitializingBean</literal>, and thus will only be called if your bean 
								implements this interface (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								the extra initialization method will be called that might have been
								specified with the bean definition (TODO: reference)
							</para>
						</listitem>
						<listitem>
							<para>
								if your bean a <literal>BeanFactoryAware</literal> the 
								<literal>setBeanFactory()</literal> method will now be called enabling
								the bean to have access to the BeanFactory (TODO: reference)
							</para>
						</listitem>
					</orderedlist>
				</para>
				<para>
					Right now, your bean is ready for use. Calls to <literal>BeanFactory.getBean()</literal>
					with the name of the bean, will result in an instance of that bean being returned.
					Depending on whether or not this bean is a singleton, a shared instance will be returned.
					More information on consequences for singletons can be found below.
				</para>
				<para>
			        When the <literal>BeanFactory</literal> gets destroyed (for instance when the
			        application server shuts down, the destruction process of the BeanFactory
			        will try to destroy all beans that it still knows. The destruction process 
			        <emphasis>only comprises singletons beans</emphasis>.
			        
			        <orderedlist spacing="compact" continuation="continues">
			        	<listitem>
			        		<para>
			        			If your bean implements <literal>DisposableBean</literal> the
			        			BeanFactory will call <literal>destroy()</literal>
			        		</para>
			        	</listitem>
			        	<listitem>
			        		<para>
			        			If you bean definition includes a destroy method declaration,
			        			this method will be called as well
			        		</para>
			        	</listitem>
			        </orderedlist>
			    </para>
			    <para>
			    	A diagram illustrating the lifecycle of a bean:
			    </para>
				<mediaobject>
					<imageobject role="fo">
    		        	<imagedata fileref="images/bean-lifecycle-overview.gif" format="GIF" align="center"/>
		        	</imageobject>
		        </mediaobject>
			</sect3>
			
		</sect2>
				
	</sect1>
	
	<sect1 id="beans-factoryimpl">
		<title>BeanFactory implementations</title>
		<para>
			A couple of implementations of the BeanFactory come out-of-the-box. The
			<literal>XmlBeanFactory</literal> supports a bean definitions to be specified
			in XML files and the <literal>ListableBeanFactory</literal> supports bean definitions
			in the form of properties files. Most people use the XmlBeanFactory. However, implementing
			your own BeanFactory that supports bean definition in a database should not be to big an
			issue. Let's first discuss the XmlBeanFactory and the ListableBeanFactory and their features.
		</para>
		<para>
			Basically the two BeanFactory implementations Spring comes with provide all the
			features described above, like specifying the lifecycle methods, specifying whether or
			not to do autowiring, etcetera. The only way they differ is the way the configuration
			data (the bean definitions) are stored.
		</para>
		
		<sect2 id="beans-factoryimpl-xml">
			<title>Bean definitions specified in XML (<literal>XmlBeanFactory</literal>)</title>
			<para>
				One of the implementations of the BeanFactory is the 
				<literal>XmlBeanFactory</literal> (located in the package
				<literal>org.springframework.beans.factory.xml</literal>) which
				offers you the ability to specify bean definition in XML files as the name
				might have already told you. Spring comes with a DTD to do validation of the
				XML you're writing to specify beans in order to make things a bit more easy.
				The DTD is quite well documented so you should find everything you need in there
				as well. Here we will discuss the format shortly and provide some examples.
			</para>
			
			<para>
				The root of a Spring XML bean definition document 
				is a <literal>&lt;beans&gt;</literal> element. The <literal>&lt;beans&gt;</literal> element 
				contains one or more <literal>&lt;bean&gt;</literal> definitions. We normally specify 
				the class and properties of each bean definition. We must also specify the id, 
				which will be the name that we'll use this bean with in our code (see a previous section about 
				<link linkend="beans-factory-client">clients interacting</link> with the BeanFactory
				for more information. An initialization method as described earlier as well the destruction
				method can be specified as attributes of the <literal>&lt;bean&gt;</literal> element.
				The autowiring functionality as well as the de dependency checking can also be specified
				using attributes of the same element. Furthermore properties and collaborators can be 
				specified using	nested <literal>&lt;property&gt;</literal> elements. 
				In the following example, we use a BasicDataSource from the Jakarta Commons DBCP 
				project. This class (like many other existing classes) can easily be used in a 
				Spring bean factory, as it offers JavaBean-style configuration. 
				The close method that needs to be called on shutdown can be registered via 
				Spring's <quote>destroy-method</quote> attribute, to avoid the need for 
				BasicDataSource to implement any Spring interface (in this case that would
				be <literal>DisposableBean</literal> mentioned earlier in the section about
				lifecycle features).
				
				<programlisting><![CDATA[
<beans>
	<bean id="myDataSource"
		class="org.apache.commons.dbcp.BasicDataSource"
		destroy-method="close">
		<!-- results in a setDriverClassName(String) call -->
		<property name="driverClassName">
			<value>com.mysql.jdbc.Driver</value>
		</property>
		<property name="url">
			<value>jdbc:mysql://localhost:3306/mydb</value>
		</property>
		<property name="username">
			<value>root</value>
		</property>
	</bean>
</beans>
				]]></programlisting>
				Just as an destruction method is specified using the <literal>destroy-method</literal>
				attribute, we could specify a initialization method using the
				<literal>init-method</literal> attribute.				
			</para>
			
			<para>
				To specify properties and collaborators in XML files you have to use nested
				&lt;property&gt; elements. You have already seen the setting of 'primitive'
				properties in the example about, the setting of collaborators is done using
				the nested <literal>&lt;ref&gt;</literal> element.
				<programlisting><![CDATA[
<beans>
...
	<bean id="exampleDataAccessObject"
		class="example.ExampleDataAccessObject">
		<!-- results in a setDataSource(BasicDataSource) call -->
		<property name="dataSource">
			<ref bean="myDataSource"/>
		</property>
	</bean>
</beans>
				]]></programlisting>
				As you can see below, we're using the Commons DBCP datasource from the previous
				example here as a collaborator and we're specifying if using a &lt;ref bean&gt;
				element. References exist in three types that specify whether or not to search the
				collaborator in the same XML file or in some other XML file (multiple XML files is
				covered further along):
				<itemizedlist spacing="compact">
					<listitem>
						<para><literal>bean</literal>: tries to find the collaborator in either
							the same XML file or in some other XML file that has also been specified
						</para>
					</listitem>
					<listitem>
						<para><literal>local</literal>: tries to find the collaborator in the current
							XML file. This attribute is an <literal>XML IDREF</literal> so it 
							<emphasis>has</emphasis> to exist, otherwise validation will fail
						</para>
					</listitem>
					<listitem>
						<para><literal>external</literal>: explicitly states to find the bean
							 in another XML file and does not search in the current XML file
						</para>
					</listitem>
				</itemizedlist>
			</para>
			
			<para>
				There's a couple of possibilities for specifying more complex properties
				such as lists, properties object and maps. The following examples show this
				behavior:
				<programlisting><![CDATA[
<beans>
...
	<bean id="moreComplexObject"
		class="example.ComplexObject">
		<!-- results in a setPeople(java.util.Properties) call -->
		<property name="people">
			<props>
				<prop key="HaaryPotter">The magic property</prop>
				<prop key="JerrySeinfeld">The funny property</prop>
			</props>
		</property>
		<!-- results in a setSomeList(java.util.List) call -->
		<property name="someList">
			<list>
				<value>a list element followed by a reference</value>
				<ref bean="myDataSource"/>
			</list>
		</property>
		<!-- results in a setSomeMap(java.util.Map) call -->
		<property name="someMap">
			<map>
				<entry key="yup an entry">
					<value>just some string</value>
				</entry>
				<entry key="yup a ref">
					<ref bean="myDataSource</ref>
				</entry>
			</map>
		</property>
	</bean>	
</beans>
				]]></programlisting>
			</para>
			<para>
				<emphasis>Note that the value of a Map entry can also again be a list or another
				map.</emphasis>
			</para>
			
		</sect2>
    </sect1>
        	
</chapter>


