<?xml version="1.0" encoding="UTF-8"?>
<chapter id="beans">
  <title>Beans, BeanFactory and the ApplicationContext</title>

  <sect1 id="beans-introduction">
    <title>Introduction</title>

    <para>Two of Spring's most elementary and important packages are the
    <literal>org.springframework.beans</literal> and
    <literal>org.springframework.context</literal> package. These packages
    provide the basis for the Spring Inversion of Control features, or
    Dependency Injection as people have also recently started to name this
    pattern (see <xref linkend="background-ioc" /> for some resources on this
    topic). The <literal>BeanFactory</literal> provides an advanced
    configuration mechanism capable of managing beans of any nature, using
    potentially any kind of storage facility. The
    <literal>ApplicationContext</literal> builds on top of the BeanFactory and
    adds other functionality such as integration with Springs AOP features,
    messaging (using <emphasis>i18n</emphasis>), the capability of having
    contexts inherit from other contexts and defining application-layer
    specific contexts, such as the
    <literal>WebApplicationContext</literal>.</para>

    <para>In short, the <literal>BeanFactory</literal> provides the
    configuration framework and basic functionality, while the
    <literal>ApplicationContext</literal> adds enhanced capabilities to it,
    some of them more J2EE and enterprise-centric.</para>

    <para>This chapter is roughly divided into two parts, the first part
    covering the basic principles that apply to both the BeanFactory and the
    ApplicationContext. The second part will cover some of the features that
    only apply to the ApplicationContext.</para>

    <para>In order to get you started using the BeanFactory and the
    ApplicationContext we'll first introduce you to a couple of basic
    principles that might be handy to know when using these classes.</para>

    <para><itemizedlist spacing="compact">
        <listitem>
          <para><emphasis>Bean definition</emphasis>: the description of a
          bean managed by the BeanFactory. Each BeanFactory contains multiple
          bean definitions, each describing the nature of a bean, its
          properties, the methods that need to be called upon initialization
          and destruction, whether or not the bean needs to be autowired and
          some other aspects. There are different implementations of
          BeanFactory. The <literal>XmlBeanFactory</literal> for example is
          capable of reading bean definitions from an XML file, in which bean
          properties, as well as collaborators and lifecycle methods are
          defined in XML format.</para>
        </listitem>

        <listitem>
          <para><emphasis>Property editors</emphasis>: part of Java's
          JavaBeans specification is the concept of
          <literal>PropertyEditors</literal>. Property editors in Spring are
          used to convert properties of beans to human-readable Strings and
          vice versa. As the PropertyEditor Javadoc (<ulink
          url="http://java.sun.com/j2se/1.4.2/docs/api/"></ulink>) states, the
          <literal>getAsText()</literal>-method should return a human-readable
          String representing the property the editor is (so-called) editing.
          The <literal>setAsText()</literal>-method should be able to parse
          the same String and (using the
          <literal>setValue(Object)</literal>-method) set the resulting value
          of the property. PropertyEditors are heavily used in Spring, not
          only by the BeanFactory to transform the Strings defined in the
          XML-containing beans, to properties of those beans, but also in
          other areas such as the web MVC framework where they assist in
          converting request parameters submitted by a user after filling a
          form to properties of command objects that might be of some
          completely different type</para>
        </listitem>

        <listitem>
          <para><emphasis>BeanWrapper</emphasis>: a special class, instances
          of which are used to wrap JavaBeans. Managed BeanWrappers for
          example, have features for setting and getting properties from the
          beans they're wrapping. It's not likely you'll ever have to touch a
          BeanWrapper yourself, but it may be handy to know about them</para>
        </listitem>
      </itemizedlist></para>

    <para>Note: users are sometimes unsure whether BeanFactory or
    ApplicationContext are best suited for use in a particular situation.
    Normally when building most applications in a J2EE-environment, the better
    option would be to use the ApplicationContext, since it offers all the
    features of the BeanFactory and adds on to it, allowing a more framework
    style usage of the Spring Framework and allowing initialization using a
    ServletContextListener such as <literal>ContextLoaderListener</literal>.
    The main usage scenario when you might prefer to use the BeanFactory is
    when memory usage is the greatest concern (such as in an applet), and you
    don't need all the features of the ApplicationContext.</para>
  </sect1>

  <sect1 id="beans-basics">
    <title>BeanFactory and BeanDefinitions - the basics</title>

    <sect2 id="beans-definition">
      <title>The BeanDefinition</title>

      <para>As already stated in the introduction, bean definitions describe
      beans managed by a <literal>BeanFactory</literal> or
      <literal>ApplicationContext</literal>. Bean definitions contain the
      following information: <itemizedlist spacing="compact">
          <listitem>
            <para>A classname: this is normally the actual implementation
            class of the bean being described in the bean definition. However,
            if the bean is to be constructed by calling a static
            <emphasis>factory</emphasis> method instead of using a normal
            constructor, this will actually be the classname of the factory
            class.</para>
          </listitem>

          <listitem>
            <para>Bean behavioral configuration elements, which state how the
            bean should behave in the container (i.e. prototype or singleton,
            autowiring mode, dependency checking mode, initialization and
            destruction methods)</para>
          </listitem>

          <listitem>
            <para>Property values to set in the newly created bean. An example
            would be the number of connections to use in a bean that manages a
            connection pool (either specified as a property or as a
            constructor argument), or the class that should be used to create
            the connection pool</para>
          </listitem>

          <listitem>
            <para>Other beans your bean needs to do its work, i.e.
            <emphasis>collaborators</emphasis> (also specified as properties
            or as constructor arguments). These can also be called
            dependencies.</para>
          </listitem>
        </itemizedlist></para>

      <para>In the list above, we mentioned the use of constructor arguments,
      as well as setters. Spring supports two types of IoC: type 2 and type 3
      (Constructor Dependency Injection and Setter Dependency Injection). What
      that basically means is that when new objects are constructed you can
      set properties of the object using both regular JavaBean style setter
      methods, and also directory as arguments which you specify to the
      constructors (or static factory method used instead of a
      constructor).</para>

      <para>The concepts listed above directly translate to a set of elements
      the bean definition consists of. These elements are listed below, along
      with a link to further documentation about each of them. <table
          frame="all">
          <title>Bean definition explanation</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="2*" />

            <colspec colname="c2" colwidth="4*" />

            <thead>
              <row>
                <entry>Feature</entry>

                <entry>More info</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>class</entry>

                <entry><xref linkend="beans-factory-class" /></entry>
              </row>

              <row>
                <entry>singleton or prototype</entry>

                <entry><xref linkend="beans-factory-modes" /></entry>
              </row>

              <row>
                <entry>bean properties</entry>

                <entry><xref linkend="beans-factory-collaborators" /></entry>
              </row>

              <row>
                <entry>constructor arguments</entry>

                <entry><xref linkend="beans-factory-collaborators" /></entry>
              </row>

              <row>
                <entry>autowiring mode</entry>

                <entry><xref linkend="beans-factory-autowire" /></entry>
              </row>

              <row>
                <entry>dependency checking mode</entry>

                <entry><xref linkend="beans-factory-dependencies" /></entry>
              </row>

              <row>
                <entry>initialization method</entry>

                <entry><xref linkend="beans-factory-lifecycle" /></entry>
              </row>

              <row>
                <entry>destruction method</entry>

                <entry><xref linkend="beans-factory-lifecycle" /></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>

    <sect2 id="beans-factory">
      <title>The BeanFactory</title>

      <para>The BeanFactory is the actual <emphasis>container</emphasis>
      (although we don't like to use the word container too much, since it
      sounds somwhat <emphasis>heavy</emphasis>), containing and managing your
      beans. A BeanFactory loads BeanDefinitions and, upon request,
      instantiates one (or possibly more) instances of the bean in question
      and manages it by calling lifecycle methods.</para>

      <para>All of the features described in <xref
      linkend="beans-definition" /> will be configurable for each of your
      beans using one of the out-of-the-box BeanFactory implementations. In
      general, because <literal>XmlBeanFactory</literal> is the most powerful
      and most used BeanFactory implementation (including its supersets, the
      XML variants of the ApplicationContext), the following text will often
      describe BeanFactory and BeanDefinition capabilities and configuration
      aspects, in terms of the explicit <literal>XmlBeanFactory</literal>
      elements and attributes which are applicable to that
      functionality.</para>
    </sect2>

    <sect2 id="beans-factory-class">
      <title>The bean class</title>

      <para>The <literal>class</literal> attribute is mandatory is and is used
      for one of two purposes. In the much more common case where the
      BeanFactory itself directly creates the bean by calling its constructor
      (equivalent to Java code calling <emphasis>new</emphasis>), the class
      attribute specifies the class of the bean to be constructed. In the less
      common case where the BeanFactory calls a static, so-called
      <emphasis>factory</emphasis> method on a class to create the bean, the
      class attribute specifies the actual class containing the static factory
      method. (the type of the returned bean from the static factory method
      may be the same class or another class entirely, it doesn't
      matter).</para>

      <sect3>
        <title>Bean creation via constructor</title>

        <para>When creating a bean using the constructor approach, all normal
        classes are usable by Spring and compatible with Spring. That is, the
        class being created does not need to implement any specific interfaces
        or be coded in a specific fashion. Just specifying the bean class
        should be enough. However, depending on what type of IoC you are going
        to use for that specific bean, you may need a default (empty)
        constructor.</para>

        <para>Additionally, the BeanFactory isn't limited to just managing
        true JavaBeans, it is also able to manage virtually
        <emphasis>any</emphasis> class you want it to manage. Most people
        using Spring prefer to have actual JavaBeans (having just a default
        (no-argument) constructor and appropriate setters and getters modelled
        after the properties) in the BeanFactory, but it it's also possible to
        have more exotic non-bean-style classes in your BeanFactory. If, for
        example, you need to use a legacy connection pool that absolutely does
        not adhere to the JavaBean specification, no worries, Spring can
        manage it as well.</para>

        <para>Using the XmlBeanFactory you can specify your bean class as
        follows: <programlisting>&lt;bean id="exampleBean"
      class="examples.ExampleBean"/&gt;
&lt;bean name="anotherExample"
      class="examples.ExampleBeanTwo"/&gt; </programlisting></para>

        <para>The mechanism for supplying (optional) arguments to the
        constructor, or setting properties of the object instance after is has
        been constructed, will be described shortly.</para>
      </sect3>

      <sect3>
        <title>Bean creation via static factory method</title>

        <para>When defining a bean which is to be created using a static
        factory method, along with the <literal>class</literal> attribute
        which specifies the class containing the static factory method,
        another attribute named <literal>factory-method</literal> is needed to
        specify the name of the factory method itself. Spring expects to be
        able to call this method (with an optional list of arguments as
        described later) and get back a live object, which from that point on
        is treated as if it had been created normally via a constructor. One
        use for such a bean definition is to call static factories in legacy
        code.</para>

        <para>Following is an example of a bean definition which specifies
        that the bean is to be created by calling a factory-method. Note that
        the definition does not specify the type (class) of the returned
        object, only the class containing the factory method. In this example,
        <literal>createInstance</literal> must be a
        <emphasis>static</emphasis> method.<programlisting>&lt;bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/&gt;</programlisting></para>

        <para>The mechanism for supplying (optional) arguments to the factory
        method, or setting properties of the object instance after it has been
        returned from the factory, will be described shortly.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-beanname">
      <title>The bean identifiers (<literal>id</literal> and
      <literal>name</literal>)</title>

      <para>Every bean has one or more ids (also called identifiers, or names;
      these terms refer to the same thing). These ids must be unique within
      the BeanFactory or ApplicationContext the bean is hosted in. A bean will
      almost always have only one id, but if a bean has more than one id, the
      extra ones can essentially be considered aliases.</para>

      <para>In an XmlBeanFactory (including ApplicationContext variants), you
      user the <literal>id</literal> or <literal>name</literal> attributes to
      specify the bean id(s), and at least one id must be specified in one or
      both of these attributes. The <literal>id</literal> attribute allows you
      to specify one id, and as it is marked in the XML DTD (definition
      document) as a real XML element ID attribute, the parser is able to do
      some extra validation when other elements point back to this one. As
      such, it is the preferred way to specify a bean id. However, the XML
      spec does limit the characters which are legal in XML IDs. This is
      usually not really a constraint, but if you have a need to use one of
      these characters, or want to introduce other aliases to the bean, you
      may also or instead specify one or more bean ids (separated by a comma
      (,) or semicolon (;) via the <literal>name</literal> attribute.</para>
    </sect2>

    <sect2 id="beans-factory-modes">
      <title>To singleton or not to singleton</title>

      <para>Beans are defined to be deployed in one of two modes: singleton or
      non-singleton. (The latter is also called a prototype, although the term
      is used loosely as as it doesn't quite fit). When a bean is a singleton,
      only one <emphasis>shared</emphasis> instance of the bean will be
      managed and all requests for beans with an id or ids matching that bean
      definition will result in that one specific bean instance being
      returned.</para>

      <para>The non-singleton, prototype mode of a bean deployment results in
      the <emphasis>creation of a new bean instance</emphasis> every time a
      request for that specific bean is done. This is ideal for situations
      where for example each user needs an independent user object or
      something similar.</para>

      <para>Beans are deployed in singleton mode by default, unless you
      specify otherwise. Keep in mind that by changing the type to
      non-singleton (prototype), each request for a bean will result in a
      newly created bean and this might not be what you actually want. So only
      change the mode to prototype when absolutely necessary.</para>

      <para>In the example below, two beans are declared of which one is
      defined as a singleton, and the other one is a non-singleton
      (prototype). <literal>exampleBean</literal> is created each and every
      time a client asks the BeanFactory for this bean, while
      <literal>yetAnotherExample</literal> is only created once; a reference
      to the exact same instance is returned on each request for this
      bean.<programlisting>&lt;bean id="exampleBean"
      class="examples.ExampleBean" singleton="false"/&gt;
&lt;bean name="yetAnotherExample"
      class="examples.ExampleBeanTwo" singleton="true"/&gt;</programlisting></para>

      <para>Note: when deploying a bean in the prototype mode, the lifecycle
      of the bean changes slightly. By definition, Spring can not manage the
      complete lifecycle of a non-singleton/prototype bean, since after it is
      created, it is given to the client and the container does not keep track
      of it at all any longer. You can think of Spring's role when talking
      about a non-singleton/prototype bean as a replacement for the 'new'
      operator. Any lifecycle aspects past that point have to be handled by
      the client. The lifecycle of a bean in the BeanFactory is further
      described in <xref linkend="beans-factory-lifecycle" />.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-dependencies">
    <title>Properties, collaborators, autowiring and dependency
    checking</title>

    <sect2 id="beans-factory-collaborators">
      <title>Setting bean properties and collaborators</title>

      <para>Inversion of Control has already been referred to as
      <emphasis>Dependency Injection</emphasis>. The basic principle is that
      beans define their dependencies (i.e. the other objects they work with)
      only through constructor arguments, arguments to a factory method, or
      properties which are set on the object instance after it has been
      constructed or returned from a factory method. Then, it is the job of
      the container to actually <emphasis>inject</emphasis> those dependencies
      when it creates the bean. This is fundamentally the inverse (hence the
      name Inversion of Control) of the bean instantiating or locating its
      dependencies on its own using direct construction of classes, or
      something like the <emphasis>Service Locator</emphasis> pattern. While
      we will not elaborate too much on the advantages of Dependency
      Injection, it becomes evident upon usage that code gets much cleaner and
      reaching a higher grade of decoupling is much easier when beans do not
      look up their dependencies, but are provided them, and additionally do
      not even know where the dependencies are located and of what actual type
      they are.</para>

      <para>As touched on in the previous paragraph, Inversion of
      Control/Dependency Injection exists in two major variants:<itemizedlist
          spacing="compact">
          <listitem>
            <para><emphasis>setter-based</emphasis> dependency injection is
            realized by calling setters on your beans after invoking a
            no-argument constructor or no-argument static factory method to
            instantiate your bean. Beans defined in the BeanFactory that use
            setter-based dependency injection are <emphasis>true
            JavaBeans</emphasis>. Spring generally advocates usage of
            setter-based dependency injection, since a large number of
            constructor arguments can get unwieldy, especially when some
            properties are optional.</para>
          </listitem>

          <listitem>
            <para><emphasis>constructor-based</emphasis> dependency injection
            is realized by invoking a constructor with a number of arguments,
            each representing a collaborator or property. Additionally,
            calling a static factory method with specific arguments, to
            construct the bean, can be considered almost equivalent, and the
            rest of this text will consider arguments to a constructor and
            arguments to a static factory method similarily. Although Spring
            generally advocates usage of setter-based dependency injection for
            most situations, it does fully support the constructor-based
            approach as well, since you may wish to use it with pre-existing
            beans which provide only multi-argument constructors, and no
            setters. Additionally, for simpler beans, some people prefer the
            constructor approach as a means of ensuring beans can not be
            constructed in an invalid state.</para>
          </listitem>
        </itemizedlist></para>

      <para>The <classname>BeanFactory</classname> supports both of these
      variants for injecting dependencies into beans its manages. (It in fact
      also supports injecting setter-based dependencies after some
      dependencies have already been supplied via the constructor approach.)
      The configuration for the dependencies comes in the form of a
      <literal>BeanDefinition</literal>, which is used together with
      <literal>PropertyEditors</literal> to know how to convert properties
      from one format to another. The actual values being passed around are
      done in the form of <literal>PropertyValue</literal> objects. However,
      most users of Spring will not be dealing with these classes directly
      (i.e. programatically), but rather with an XML definition file which
      will be converted internally into instances of these classes, and used
      to load an entire BeanFactory or ApplicationContext.</para>

      <para>Bean dependency resolution generally happens as
      follows:<orderedlist spacing="compact">
          <listitem>
            <para>The BeanFactory is created and initialized with a
            configuration which describes all the beans. Most Spring users use
            a BeanFactory or ApplicationContext variant which supports XML
            format configuration files.</para>
          </listitem>

          <listitem>
            <para>Each bean has dependencies expressed in the form of
            properties, constructor arguments, or arguments to the
            static-factory method when that is used instead of a normal
            constructor. These dependencies will be provided to the bean,
            <emphasis>when the bean is actually created</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Each property or constructor-arg is either an actual
            definition of the value to set, or a reference to another bean in
            the BeanFactory. In the case of the ApplicationContext, the
            reference can be to a bean in a parent ApplicationContext.</para>
          </listitem>

          <listitem>
            <para><anchor id="???" />Each property or constructor argument
            which is a value must be able to be converted from whatever format
            it was specified in, to the actual type of that property or
            constructor argument. By default Spring can convert a value
            supplied in string format to all built-in types, such as
            <literal>int</literal>, <literal>Long</literal>,
            <literal>String</literal>, <literal>boolean</literal>, etc.
            Additionally, when talking about the XML based BeanFactory
            variants (including the ApplicationContext variants), these have
            built-in support for defining Lists, Maps, Sets, and Properties
            collection types. Additionally, Spring uses JavaBeans
            <classname>PropertyEditor</classname> definitions to be able to
            convert string values to other, arbitrary types. (You can provide
            the BeanFactory with your own <literal>PropertyEditor</literal>
            definitions to be able to convert your own custom types; more
            information about PropertyEditors and how to manually add custom
            ones, can be fouund in <xref linkend="beans-customeditors" />).
            When a bean property is a java Class, Spring allows you to specify
            the value for that property as a string value which is the name of
            the class, and the <literal>ClassEditor</literal> PropertyEditor
            which is built-in, will take care of converting that class name to
            an actual Class instance.</para>
          </listitem>

          <listitem>
            <para>It is important to realize that Spring validates the
            configuration of each bean in the BeanFactory when the BeanFactory
            is created, including the validation that properties which are
            bean references are actually referring to valid beans (i.e. the
            beans being referred to are also defined in the BeanFactory, or in
            the case of ApplicationContext, a parent context). However, the
            bean properties themselves are not set until the bean <emphasis>is
            actually created</emphasis>. For beans which are singleton and set
            to be pre-instantiated (such as singleton beans in an
            ApplicationContext), creation happens at the time that the
            BeanFactory is created, but otherwise this is only when the bean
            is requested. When a bean actually has to be created, this will
            potentially cause a graph of other beans to be created, as its
            dependencies and its dependencies' dependencies (and so on) are
            created and assigned.</para>
          </listitem>

          <listitem>
            <para>You can generally trust Spring to do the right thing. It
            will pick up configuraton issues, including references to
            non-existent beans and circular dependencies, at BeanFactory
            load-time. It will actually set properties and resolve
            dependencies (i.e. create those dependencies if needed) as late as
            possible, which is when the bean is actually created. This does
            mean that a BeanFactory which has loaded correctly, can later
            generate an exception when you request a bean, if there is a
            problem creating that bean or one of its dependencies. This could
            happen if the bean throws an exception as a result of a missing or
            invalid property, for example. This potentially delayed visibility
            of some configuration issues is why ApplicationContext by default
            pre-instantiates singleton beans. At the cost of some upfront time
            and memory to create these beans before they are actually needed,
            you find out about configuration issues when the
            ApplicationContext is created, not later. If you wish, you can
            still override this default behavior and set any of these
            singleton beans to lazy-load (not be preinstantiated).</para>
          </listitem>
        </orderedlist></para>

      <para>Some examples:</para>

      <para>First, an example of using the BeanFactory for setter-based
      dependency injection. Below is a small part of an
      <literal>XmlBeanFactory</literal> config file specifying some bean
      definitions. Following is the code for the actual main bean itself,
      showing the appropriate setters declared. <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;
    &lt;property name="beanTwo"&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/property&gt;
    &lt;property name="integerProperty"&gt;1&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>
      <programlisting>public class ExampleBean {
    
    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }
    
    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }
    
    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}</programlisting>As you can see, setters have been declared to match against
      the properties specified in the XML file. (The properties from the XML
      file, directly relate to the <literal>PropertyValues</literal> object
      from the <literal>RootBeanDefinition</literal>)</para>

      <para>Now, an example of using the BeanFactory for IoC type 3
      (Constructor Dependency Injection). Below is a snippet from an XML
      configuration that specifies constructor arguments and the actual bean
      code, showing the constructor: <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;
</programlisting> <programlisting>public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</programlisting>As you can see, the constructor arguments specified in the
      bean definition will be used to pass in as arguments to the constructor
      of the <literal>ExampleBean</literal>.</para>

      <para>Now consider a variant of this where instead of using a
      constructor, Spring is told to call a static factory method to return an
      instance of the object.: <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&gt;
    &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>
      <programlisting>public class ExampleBean {

    ...

    // a private constructor
    private ExampleBean(...) {
      ...
    }
    
    // a static factory method
    // the arguments to this method can be considered the dependencies of the bean that
    // is returned, regardless of how those arguments are actually used.
    public static ExampleBean ExampleBean(AnotherBean anotherBean,
                                          YetAnotherBean yetAnotherBean, int i) {
        ExampleBean eb = new ExampleBean(...);
        // some other operations
        ...
        return eb;
    }
}</programlisting></para>

      <para>Note that arguments to the static factory method are supplied via
      <literal>constructor-arg</literal> elements, exactly the same as if a
      constructor had actually been used. These areguments are optional. Also,
      it is important to realize that the type of the class being returned by
      the factory method does not have to be of the same type as the class
      which contains the static factory method, although in this example it
      is.</para>
    </sect2>

    <sect2 id="beans-factory-properties-detailed">
      <title>Bean properties and constructor arguments detailed</title>

      <para>As mentioned in the previous section, bean properties and
      constructor arguments can be defined as either references to other
      managed beans (collaborators), or values defined inline. The
      <literal>XmlBeanFactory</literal> supports a number of subelement types
      within its <literal>property</literal> and
      <literal>constructor-arg</literal> elements for this purpose.</para>

      <para>The <literal>value</literal> element specifies a property or
      constructor argument as a human-readable string representation. As
      mentioned in detail <link
      linkend="beans-factory-collaborators-propertyeditor">previously</link>,
      JavaBeans PropertyEditors are used to convert these string values from a
      <literal>java.lang.String</literal> to the actual property or argument
      type.<programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
    &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;!-- results in a setDriverClassName(String) call --&gt;
        &lt;property name="driverClassName"&gt;
            &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="url"&gt;
            &lt;value&gt;jdbc:mysql://localhost:3306/mydb&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="username"&gt;
            &lt;value&gt;root&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt; </programlisting></para>

      <para>The <literal>null</literal> element is used to handle null values.
      Spring treats empty arguments for properties and the like as empty
      Strings. The following XmlBeanFactory configuration: <programlisting>&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;        </programlisting>results in the email property being set
      to "", equivalent to the java code:
      <literal>exampleBean.setEmail("")</literal>. The special
      <literal>&lt;null&gt;</literal> element may be used to indicate a null
      value, so that: <programlisting>&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;        </programlisting>is equivalent to the java code:
      <literal>exampleBean.setEmail(<emphasis>null</emphasis>)</literal>.</para>

      <para>The <literal>list</literal>, <literal>set</literal>,
      <literal>map</literal>, and <literal>props</literal> elements allow
      properties and arguments of Java type <literal>List</literal>,
      <literal>Set</literal>, <literal>Map</literal>, and
      <literal>Properties</literal>, respectively, to be defined and
      set.<programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
    ...
    &lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
        &lt;!-- results in a setPeople(java.util.Properties) call --&gt;
        &lt;property name="people"&gt;
            &lt;props&gt;
                &lt;prop key="HaaryPotter"&gt;The magic property&lt;/prop&gt;
                &lt;prop key="JerrySeinfeld"&gt;The funny property&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeList(java.util.List) call --&gt;
        &lt;property name="someList"&gt;
            &lt;list&gt;
                &lt;value&gt;a list element followed by a reference&lt;/value&gt;
                &lt;ref bean="myDataSource"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
        &lt;property name="someMap"&gt;
            &lt;map&gt;
                &lt;entry key="yup an entry"&gt;
                    &lt;value&gt;just some string&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry key="yup a ref"&gt;
                    &lt;ref bean="myDataSource"&lt;/ref&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
        &lt;property name="someSet"&gt;
            &lt;set&gt;
                &lt;value&gt;just some string&lt;/value&gt;
                &lt;ref bean="myDataSource"&lt;/ref&gt;
            &lt;/map&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
&lt;/beans&gt;</programlisting></para>

      <para><emphasis>Note that the value of a Map entry, or a set value, can
      also again be any of the elements:</emphasis><programlisting>(bean | ref | idref | list | set | map | props | value | null)</programlisting></para>

      <para>A <literal>bean</literal> element inside the
      <literal>property</literal> element is used to define a bean value
      inline, instead of referring to a bean defined elsewhere in the
      BeanFactory. The inline bean definition does not have any
      <programlisting>&lt;bean id="outer" class="..."&gt;
    &lt;!-- Instead of using a reference to target, just use an inner bean --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.mycompany.PersonImpl"&gt;
            &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
            &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
        &lt;/bean&gt;
   &lt;/property&gt;
&lt;/bean&gt;</programlisting>An idref element is simply a shorthand and
      error-proof way to set a property to the String <emphasis>id</emphasis>
      or <emphasis>name</emphasis> of another bean in the
      container.<programlisting>&lt;bean id="theTargetBean" class="..."&gt;
&lt;/bean&gt;
&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>This is exactly equivalent at runtime to the
      following fragment:<programlisting>&lt;bean id="theTargetBean" class="..."&gt;
&lt;/bean&gt;
&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;value&gt;theTargetBean&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>The main reason the first form is preferrable to
      the second is that using the <literal>idref</literal> tag will allow
      Spring to validate at deployment time that the other bean actually
      exists. In the second variation, the class who's
      <emphasis>targetName</emphasis> property is forced to do its own
      validation, and that will only happen when that class is actually
      instantiated by Spring, possibly long after the container is actually
      deployed.</para>

      <para>Additionally, if the bean being referred to is in the same actual
      XML file, and the bean name is the bean <emphasis>id</emphasis>, the
      <literal>local</literal> attribute may be used, which will allow the XML
      parser itself to validate the bean name even earlier, at XML document
      parse time.<programlisting>    &lt;property name="targetName"&gt;
        &lt;idref local="theTargetBean"/&gt;
    &lt;/property&gt;</programlisting></para>

      <para>The <literal>ref</literal> element is the final element allowed
      inside a <literal>property</literal> definition element. It is used to
      set the value of the specified property to be a reference to another
      bean managed by the container, a collaborator, so to speak. As mentioned
      in a previous section, the referred-to bean is considered to be a
      dependency of the bean who's property is being set, and will be
      initialized on demand as needed (if it is a singleton bean it may have
      already been initialized by the container) before the property is set.
      All references are ultimately just a reference to another object, but
      there are 3 variations on how the id/name of the other object may be
      specified, which determines how scoping anf validation is
      handled.</para>

      <para>Specifying the target bean by using the <literal>bean</literal>
      attribute of the <literal>ref</literal> tag is the most general form,
      and will allow creating a reference to any bean in the same
      BeanFactory/ApplicationContext (whether or not in the same XML file), or
      parent BeanFactory/ApplicationContext. The value of the
      <literal>bean</literal> attribute may be ther same as either the
      <literal>id</literal> attribute of the target bean, or one of the values
      in the <literal>name</literal> attribute of the target
      bean.<programlisting>    &lt;ref bean="someBean"/&gt;</programlisting></para>

      <para>Specifying the target bean by using the <literal>local</literal>
      attribute leverages the ability of the XML parser to validate XML id
      references within the same file. The value of the
      <literal>local</literal> attribute must be the same as the
      <literal>id</literal> attribute of the target bean. The XML parser will
      issue an error if no matching element is found in the same file. As
      such, using the local variant is the best choice (in order to know about
      errors are early as possible) if the target bean is in the same XML
      file.<programlisting>    &lt;ref local="someBean"/&gt;</programlisting></para>

      <para>Specifying the target bean by using the <literal>parent</literal>
      attribute allows a reference to be created to a bean which is in a
      parent BeanFactory (or ApplicationContext) of the current BeanFactory
      (or ApplicationContext). The value of the <literal>parent</literal>
      attribute may be ther same as either the <literal>id</literal> attribute
      of the target bean, or one of the values in the <literal>name</literal>
      attribute of the target bean, and the target bean must be in a parent
      BeanFactory or ApplicationContext to the current one. The main use of
      this bean reference variant is when there is a need to wrap an existing
      bean in a parent context with some sort of proxy (which may have the
      same name as the parent), and needs the original object so it may wrap
      it. <programlisting>    &lt;ref parent="someBean"/&gt;</programlisting></para>
    </sect2>

    <sect2 id="beans-factory-method-injection">
      <title>Method Injection</title>

      <para>For most users, the majority of the beans in the container will be
      singletons. When a singleton bean needs to collaborate with (use)
      another singleton bean, or a non-singleton bean needs to collaborate
      with another non-singleton bean, the typical and common approach of
      handling this dependency by defining one bean to be a property of the
      other, is quite adequate. There is however a problem when the bean
      lifecycles are different. Consider a singleton bean A which needs to use
      a non-singleton (prototype) bean B, perhaps on each method invocation on
      A. The container will only create the singleton bean A once, and thus
      only get the opportunity to set its properties once. There is no
      opportunity for the container to provide bean A with a new instance of
      bean B every time one is needed..</para>

      <para>One solution to this problem is to forgo some inversion of
      control. Bean A can be aware of the container (as described <link
      linkend="beans-factory-aware-beanfactoryaware">here</link>) by
      implementing<literal> BeanFactoryAware</literal>, and use programmatic
      means (as described <link linkend="beans-factory-client">here</link>) to
      ask the container via a <literal>getBean("B")</literal> call for (a new)
      bean B every time it needs it. This is generally not a desireable
      solution since the bean code is then aware of and coupled to
      Spring.</para>

      <para>Method Injection, an advanced feature of the BeanFactory, allows
      this use case to be handled in a clean fashion, along with some other
      scenarios.</para>

      <sect3>
        <title>Lookup method Injection</title>

        <para>Lookup method injection refers to the ability of the container
        to override abstract or concrete methods on managed beans in the
        container, to return the result of looking up another named bean in
        the container. The lookup will typically be of a non-singleton bean as
        per the scenario described above (although it can also be a
        singleton). Spring implements this by performing bytecode modification
        on the client class, using the CGLIB library.</para>

        <para>In the client class containing the method to be injected, the
        method definition must be an abstract (or concrete) definition in this
        form:</para>

        <para><programlisting>protected abstract SingleShotHelper createSingleShotHelper();</programlisting></para>

        <para>If the method is not abstract, Spring will simply override the
        existing implementation. In the XmlBeanFactory case, you instruct
        Spring to inject/override this method to return a particular bean from
        the container, by using the <literal>lookup-method</literal> element
        inside the bean definition. For example:<programlisting>&lt;!-- a stateful bean deployed as a protype (non-singleton) --&gt;
&lt;bean id="singleShotHelper class="..." singleton="false"&gt;
&lt;/bean&gt;

&lt;!-- myBean uses singleShotHelper --&gt;
&lt;bean id="myBean" class="..."&gt;
  &lt;lookup-method name="createSingleShotHelper"
                 bean="singleShotHelper"/&gt;
  &lt;property&gt;
    ...
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para>The bean identified as <emphasis>myBean</emphasis> will call its
        own method <literal>createSingleShotHelper</literal> whenever it needs
        a new instance of the <emphasis>singleShotHelper</emphasis> bean. It
        is important to note that the person deploying the beans must be
        careful to deploy <emphasis>singleShotHelper</emphasis> as a
        non-singleton (if that is actually what is needed). If it is deployed
        as a singleton (either explicitly, or relying on the default
        <emphasis>true</emphasis> setting for this flag), the same instance of
        singleShotHelper will be returned each time!</para>

        <para>Note that lookup method injection can be combined with
        Constructor Injection (supplying optional constructor arguments to the
        bean being constructed), and also with Setter Injection (settings
        properties on the bean being constructed).</para>
      </sect3>

      <sect3>
        <title>Arbitrary method replacement</title>

        <para>A less commonly useful form of method injection than Lookup
        Method Injection is the ability to replace arbitrary methods in a
        managed bean with another method implementation. Users may safely skip
        the rest of this section (which describes this somewhat advanced
        feature), until this functionality is actually needed.</para>

        <para>In an XmlBeanFactory, the <literal>replaced-method</literal>
        element may be used to replace an existing method implementation with
        another, for a deployed bean. Consider the following class, with a
        method computeValue, which we want to override:<programlisting>...
public class MyValueCalculator {
  public String computeValue(String input) {
    ... some real code
  }

  ... some other methods
}</programlisting></para>

        <para>A class implementing the
        <literal>org.springframework.beans.factory.support.MethodReplacer</literal>
        interface is needed to provide the new method
        defintion.<programlisting>/** meant to be used to override the existing computeValue
    implementation in MyValueCalculator */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ... 
        return ...;
}</programlisting></para>

        <para>The BeanFactory deployment definition to deploy the original
        class and specify the method override would look like:<programlisting>&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplaceMentComputeValue"&gt;
&lt;/bean&gt;</programlisting>One or more contained
        <literal>arg-type</literal> elements within the
        <literal>replaced-method</literal> element may be used to indicate the
        method signature of the method being overriden. Note that the
        signature for the arguments is actually only needed in the case that
        the method is actually overloaded and there are mutliple variants
        within the class. For convenience, the type string for an argument may
        be a substring of the fully qualified type name. For example, all the
        following would match
        <emphasis>java.lang.String</emphasis>.<programlisting>    java.lang.String
    String
    Str</programlisting>Since the number of arguments is often enough to
        distinguish between each possible choice, this shortcut can save a lot
        of typing, by just using the shortest string which will match an
        argument.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-dependson">
      <title>Using <literal>depends-on</literal></title>

      <para>For most situations, the fact that a bean is a dependency of
      another is expressed simply by the fact that one bean is set as a
      property of another. This is typically done with the
      <literal>ref</literal> element in the XmlBeanFactory. In a variation of
      this, sometimes a bean which is aware of the container is simply given
      the id of its dependency (using a string value or alternately the
      <literal>idref</literal> element, which evaluates the same as a string
      value). The first bean then programmatically asks the container for its
      dependency. In either case, the dependency is properly initialized
      before the dependent bean.</para>

      <para>For the relatively infrequent situations where dependencies
      between beans are less direct (for example, when a static initializer in
      a class needs to be triggered, such as database driver registration),
      the <literal>depends-on</literal> element may be used to explicitly
      force one or more beans to be initialized before the bean using this
      element is initialized.</para>

      <para>Following is an example config:<programlisting>&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"&gt;
    &lt;property name="manager"&gt;&lt;ref local="manager"/&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean"/&gt;</programlisting></para>
    </sect2>

    <sect2 id="beans-factory-autowire">
      <title>Autowiring collaborators</title>

      <para>A BeanFactory is able to <emphasis>autowire</emphasis>
      relationships between collaborating beans. This means it's possible to
      automatically let Spring resolve collaborators (other beans) for your
      bean by inspecting the contents of the BeanFactory. The autowiring
      functionality has five modes. Autowiring is specified
      <emphasis>per</emphasis> bean and can thus be enabled for some beans,
      while other beans won't be autowired. Using autowiring, it is possible
      to reduce or eliminate the need to specify properties or constructor
      arguments, saving a significant amount of typing.<footnote>
          <para>See <xref linkend="beans-factory-collaborators" /></para>
        </footnote>In an XmlBeanFactory, the autowire mode for a bean
      definition is specified by using the <literal>autowire</literal>
      attribute of the bean element. The following values are allowed.<table
          frame="all">
          <title>Autowiring modes</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="1*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Mode</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>no</entry>

                <entry>No autowiring at all. Bean references must be defined
                via a <literal>ref</literal> element. This is the default
                value and changing this is discouraged for larger deployments,
                since explicitely specifying collaborators gives greater
                control and clarity. To some extent, it is a form of
                documentation about the structure of a system. </entry>
              </row>

              <row>
                <entry>byName</entry>

                <entry>Autowiring by property name. This option will inspect
                the BeanFactory and look for a bean named exactly the same as
                the property which needs to be autowired. For example, if you
                have a bean definition which is set to autowire by name, and
                it contains a <emphasis>master</emphasis> property (that is,
                it has a <emphasis>setMaster</emphasis>(...) method), Spring
                will look for a bean definition named master, and use it to
                set the property.</entry>
              </row>

              <row>
                <entry>byType</entry>

                <entry>Allows a property to be autowired if there is exactly
                one bean of the property type in the BeanFactory. If there is
                more than one, a fatal exception is thrown, and this indicates
                that you may not use <emphasis>byType</emphasis> autowiring
                for that bean. If there are no matching beans, nothing
                happens; the property is not set. If this is not desirable,
                setting the <literal>dependency-check="objects"</literal>
                attribute value specifies that an error should be thrown in
                this case.</entry>
              </row>

              <row>
                <entry>constructor</entry>

                <entry>This is analogous to <emphasis>byType</emphasis>, but
                applies to constructor arguments. If there isn't exactly one
                bean of the constructor argument type in the bean factory, a
                fatal error is raised.</entry>
              </row>

              <row>
                <entry>autodetect</entry>

                <entry>Chooses <emphasis>constructor</emphasis> or
                <emphasis>byType</emphasis> through introspection of the bean
                class. If a default constructor is found, byType gets
                applied.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Note that explicit dependencies, i.e. <literal>property</literal>
      and <literal>constructor-arg</literal> elements, always override
      autowiring. Autowire behaviour can be combined with dependency checking,
      which will be performed after all autowiring has been completed.</para>

      <para><emphasis>Note: as has already been mentioned, for larger
      applications, it is discouraged to use autowiring because it removes the
      transparency and the structure from your collaborating
      classes.</emphasis></para>
    </sect2>

    <sect2 id="beans-factory-dependencies">
      <title>Checking for dependencies</title>

      <para>Spring has the ability to try to check for the existence of
      unresolved dependencies of a bean deployed into the BeanFactory. These
      are JavaBeans properties of the bean, which do not have actual values
      set for them in the bean definition, or alternately provided
      automatically by the autowiring feature.</para>

      <para>This feature is sometimes useful when you want to ensure that all
      properties (or all properties of a certain type) are set on a bean. Of
      course, in many cases a bean class will have default values for many
      properties, or some properties do not apply to all usage scenarios, so
      this feature is of limited use. Dependency checking can also be enabled
      and disabled per bean, just as with the autowiring functionality. The
      default is to <emphasis>not</emphasis> check dependencies. Dependency
      checking can be handled in serveral different modes. In an
      XmlBeanFactory, this is specified via the
      <literal>dependency-check</literal> attribute in a bean definition,
      which may have the following values.<table frame="all">
          <title>Dependency checking modes</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="1*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Mode</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>none</entry>

                <entry>No dependency checking. Properties of the bean which
                have no value specified for them are simply not set.</entry>
              </row>

              <row>
                <entry>simple</entry>

                <entry>Dependency checking is performed for primitive types
                and collections (everything except collaborators, i.e. other
                beans)</entry>
              </row>

              <row>
                <entry>object</entry>

                <entry>Dependency checking is performed for
                collaborators</entry>
              </row>

              <row>
                <entry>all</entry>

                <entry>Dependency checking is done for collaborators,
                primitive types and collections</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>
  </sect1>

  <sect1 id="beans-factory-nature">
    <title>Customizing the nature of a bean</title>

    <sect2 id="beans-factory-lifecycle">
      <title>Lifecycle interfaces</title>

      <para>Spring provides several marker interfaces to change the behavior
      of your bean in the BeanFactory. They include
      <literal>InitializingBean</literal> and
      <literal>DisposableBean</literal>. Implementing these interfaces will
      result in the BeanFactory calling
      <literal>afterPropertiesSet()</literal> for the former and
      <literal>destroy()</literal> for the latter to allow the bean to perform
      certain actions upon initialization and destruction.</para>

      <para>Internally, Spring uses <literal>BeanPostProcessors</literal> to
      process any marker interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <literal>BeanFactoryPostProcessor</literal> yourself. More information
      about this can be found in <xref
      linkend="beans-factory-postprocessor" />.</para>

      <para>All the different lifecycle marker interfaces are described below.
      In one of the appendices, you can find diagram that show how Spring
      manages beans and how those lifecycle features change the nature of your
      beans and how they are managed.</para>

      <sect3 id="beans-factory-lifecycle-initializingbean">
        <title>InitializingBean / <literal>init-method</literal></title>

        <para>Implementing the
        <literal>org.springframework.beans.factory.InitializingBean</literal>
        allows a bean to perform initialization work after all necessary
        properties on the bean are set by the BeanFactory. The
        InitializingBean interface specifies exactly one
        method:<programlisting>    * Invoked by a BeanFactory after it has set all bean properties supplied
    * (and satisfied BeanFactoryAware and ApplicationContextAware).
    * &lt;p&gt;This method allows the bean instance to perform initialization only
    * possible when all bean properties have been set and to throw an
    * exception in the event of misconfiguration.
    * @throws Exception in the event of misconfiguration (such
    * as failure to set an essential property) or if initialization fails.
    */
    void afterPropertiesSet() throws Exception;</programlisting></para>

        <para><emphasis>Note: generally, the use of the
        <literal>InitializingBean</literal> marker interface can be avoided
        (and is discouraged since it unecessarilly couples the code to
        Spring). A bean definition provides support for a generic
        initialization method to be specified. In the case of the
        XmlBeanFactory, this is done via the <literal>init-method</literal>
        attribute. For example, the following definition:</emphasis></para>

        <para><programlisting>&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;

public class ExampleBean {
    public void init() {
        // do some initialization work
    }
}</programlisting>Is exactly the same as: <programlisting>&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements InitializingBean {
    public void afterPropertiesSet() {
        // do some initialization work
    }
}</programlisting>but does not couple the code to Spring.</para>
      </sect3>

      <sect3 id="beans-factory-lifecycle-disposablebean">
        <title>DisposableBean / <literal>destroy-method</literal></title>

        <para>Implementing the
        <literal>org.springframework.beans.factory.DisposableBean</literal>
        interface allows a bean to get a callback when the BeanFactory
        containing it is destroyed. The DisposableBean interface specifies one
        method: <programlisting>    /**
    * Invoked by a BeanFactory on destruction of a singleton.
    * @throws Exception in case of shutdown errors.
    * Exceptions will get logged but not rethrown to allow
    * other beans to release their resources too.
    */
    void destroy() throws Exception;
</programlisting></para>

        <para><emphasis>Note: generally, the use of the
        <literal>DisposableBean</literal> marker interface can be avoided (and
        is discouraged since it unecessarilly couples the code to Spring). A
        bean definition provides support for a generic destroy method to be
        specified. In the case of the XmlBeanFactory, this is done via the
        <literal>destroy-method</literal> attribute. For example, the
        following definition: </emphasis></para>

        <para><programlisting>&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;

public class ExampleBean {
    public void cleanup() {
        // do some destruction work (like closing connection)
    }
}</programlisting> Is exactly the same as: <programlisting>&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements DisposableBean {
    public void destroy() {
        // do some destruction work
    }
}</programlisting>but does not couple the code to Spring.</para>

        <para><emphasis>Important note: when deploying a bean in the prototype
        mode, the lifecycle of the bean changes slightly. By definition,
        Spring can not manage the complete lifecycle of a
        non-singleton/prototype bean, since after it is created, it is given
        to the client and the container does not keep track of it at all any
        longer. You can think of Spring's role when talking about a
        non-singleton/prototype bean as a replacement for the 'new' operator.
        Any lifecycle aspects past that point have to be handled by the
        client. The lifecycle of a bean in the BeanFactory is further
        described in <xref
        linkend="beans-factory-lifecycle" /></emphasis></para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-aware">
      <title>Knowing who you are</title>

      <sect3 id="beans-factory-aware-beanfactoryaware">
        <title>BeanFactoryAware</title>

        <para>A class which implements the
        <literal>org.springframework.beans.factory.BeanFactoryAware</literal>
        interface is provided with a reference to the BeanFactory that created
        it, when it is created by that BeanFactory.<programlisting>public interface BeanFactoryAware {
   /**
    * Callback that supplies the owning factory to a bean instance.
    * &lt;p&gt;Invoked after population of normal bean properties but before an init
    * callback like InitializingBean's afterPropertiesSet or a custom init-method.
    * @param beanFactory owning BeanFactory (may not be null).
    * The bean can immediately call methods on the factory.
    * @throws BeansException in case of initialization errors
    * @see BeanInitializationException
    */
    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</programlisting></para>

        <para>This allows beans to manipulate the BeanFactory that created
        them programmatically, through the
        <literal>org.springframework.beans.factory.BeanFactory</literal>
        interface, or by casting the reference to a known subclass of this
        which exposes additional functionality. Primarilly this would consist
        of programmatic retrieval of other beans. While there are cases when
        this capability is useful, it shold generally be avoided, since it
        couples the code to Spring, and does not follow the Inversion of
        Control style, where collaborators are provided to beans as
        properties.</para>
      </sect3>

      <sect3 id="beans-factory-aware-beannameaware">
        <title>BeanNameAware</title>

        <para>If a bean implements the
        <literal>org.springframework.beans.factory.BeanNameAware</literal>
        interface and is deployed in a BeanFactory, the BeanFactory will call
        the bean through this interface to inform the bean of the
        <emphasis>id</emphasis> it was deployed under. The callback will be
        Invoked after population of normal bean properties but before an init
        callback like <literal>InitializingBean</literal>'s
        <emphasis>afterPropertiesSet</emphasis> or a custom
        init-method.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-lifecycle-factorybean">
      <title>FactoryBean</title>

      <para>The
      <literal>org.springframework.beans.factory.FactoryBean</literal> is to
      be implemented by objects that <emphasis>are themselves
      factories</emphasis>. The BeanFactory interface provides three method:
      <itemizedlist spacing="compact">
          <listitem>
            <para><literal>Object getObject()</literal>: has to return an
            instance of the object this factory creates. The instance can
            possibly be shared (depending on this factory providing singleton
            or prototypes).</para>
          </listitem>

          <listitem>
            <para><literal>boolean isSingleton()</literal>: has to return
            <literal>true</literal> if this FactoryBean returns singletons,
            <literal>false</literal> otherwise</para>
          </listitem>

          <listitem>
            <para><literal>Class getObjectType()</literal>: has to return
            either the object type returned by the
            <literal>getObject()</literal> method or <literal>null</literal>
            if the type isn't known in advance</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
  </sect1>

  <sect1 id="beans-factory-client">
    <title>Interacting with the BeanFactory</title>

    <para>Essentially, the BeanFactory is nothing more than the interface for
    an advanced factory capable of maintaining a registry of different beans
    and their dependencies. The BeanFactory enables you to read bean
    definitions and access them using the bean factory. When using just the
    BeanFactory you would create one and read in some bean definitions in the
    XML format as follows: <programlisting>InputStream is = new FileInputStream("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);</programlisting></para>

    <para>Basically that's all there is to it. Using
    <literal>getBean(String)</literal> you can retrieve instances of your
    beans. You'll get a reference to the same bean if you defined it as a
    singleton (the default) or you'll get a new instance each time if you set
    <literal>singleton</literal> to <emphasis>false</emphasis>. The
    client-side view of the BeanFactory is surprisingly simple. The
    <literal>BeanFactory</literal> interface has only five methods for clients
    to call: <itemizedlist spacing="compact">
        <listitem>
          <para><literal>boolean containsBean(String)</literal>: returns true
          if the BeanFactory contains a beandefinition that matches the given
          name</para>
        </listitem>

        <listitem>
          <para><literal>Object getBean(String)</literal>: returns an instance
          of the bean registered under the given name. Depending on how the
          bean was configured by the BeanFactory configuration, either a
          singleton and thus shared instance or a newly created bean will be
          returned. A <literal>BeansException</literal> will be thrown when
          either the bean could not be found (in which case it'll be a
          <literal>NoSuchBeanDefinitionException</literal>), or an exception
          occured while instantiated and preparing the bean</para>
        </listitem>

        <listitem>
          <para><literal>Object getBean(String,Class)</literal>: returns a
          bean, registered under the given name. The bean returned will be
          cast to the given Class. If the bean could not be cast,
          corresponding exceptions will be thrown
          (<literal>BeanNotOfRequiredTypeException</literal>). Furthermore,
          all rules of the getBean(String) method apply (see above)</para>
        </listitem>

        <listitem>
          <para><literal>boolean isSingleton(String)</literal>: determines
          whether or not the beandefinition registered under the given name is
          a singleton or a prototype. If the beandefinition corresponding to
          the given name could not be found, an exception will be thrown
          (<literal>NoSuchBeanDefinitionException</literal>)</para>
        </listitem>

        <listitem>
          <para><literal>String[] getAliases(String)</literal>: Return the
          aliases for the given bean name, if any were defined in the
          BeanDefinition</para>
        </listitem>
      </itemizedlist></para>

    <sect2>
      <title>Obtaining a FactoryBean, not its product</title>

      <para>Sometimes there is a need to ask a BeanFactory for an actual
      FactoryBean instance itself, not the bean it produces. This may be done
      by prepending the bean id with <literal>&amp;</literal> when calling the
      <methodname>getBean</methodname> method of BeanFactory (including
      ApplicationContext). So for a given FactoryBean with an id
      <literal>myBean</literal>, invoking <literal>getBean("myBean")</literal>
      on the BeanFactory will return the product of the FactoryBean, but
      invoking <literal>getBean("&amp;myBean")</literal> will return the
      FactoryBean instance itself.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-factory-customizing">
    <title>Customizing the BeanFactory</title>

    <para>When in need of special behavior in the BeanFactory you need to
    consult the <literal>org.springframework.beans.factory.config</literal>
    package, which should provide you all the things you need. Using the
    config package you can for instance define a properties file of which the
    property-entries are used as replacements values in the BeanFactory. Also,
    you can implement custom behavior (like adding custom editors) using the
    BeanFactoryPostProcessor. Each of the features the config-package offers
    is described below:</para>

    <sect2 id="beans-factory-postprocessor">
      <title>The <literal>BeanFactoryPostProcessor</literal></title>

      <para>The BeanFactoryPostProcessor is the superclass for all post
      processors that are capable of applying changes to the BeanFactory (or
      beans in it) after the factory has been initialized. The
      BeanFactoryPostProcessor can be used to add custom editors (as also
      mentioned in <xref linkend="beans-beans-conversion" />). Some
      out-of-the-box post processors are available, like the
      <literal>PropertyResourceConfigurer</literal> and the
      <literal>PropertyPlaceHolderConfigurer</literal>, both described below,
      and <literal>BeanNameAutoProxyCreator</literal>, very useful for
      wrapping other beans transactionally, as described later in this
      manual.</para>
    </sect2>

    <sect2 id="beans-factory-placeholderconfigurer">
      <title>The <literal>PropertyPlaceholderConfigurer</literal></title>

      <para>The <literal>PropertyPlaceholderConfigurer</literal> is an
      excellent solution when you want to externalize a few properties from a
      file containing bean definitions. Say you want to let the person
      responsible for deploying applications just fill in database URLs,
      usernames and passwords. You could of course let him change the XML file
      containing bean definitions, but that would be risky. Instead, use the
      <literal>PropertyPlaceHolderConfigurer</literal> to - at runtime -
      replace those properties by values from a properties file.</para>

      <para>In the example below, a datasource is defined, and we will
      configure some properties from an external Properties file. At runtime,
      we will apply a <literal>PropertyPlaceholderConfigurer</literal> to the
      BeanFactory which will replace some properties of the datasource:</para>

      <programlisting>&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName"&gt;&lt;value&gt;${jdbc.driverClassName}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="url"&gt;&lt;value&gt;${jdbc.url}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="username"&gt;&lt;value&gt;${jdbc.username}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="password"&gt;&lt;value&gt;${jdbc.password}&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <programlisting>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</programlisting>

      <programlisting>XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
cfg.postProcessBeanFactory(factory);</programlisting>

      <para>The <literal>PropertyPlaceHolderConfigurer</literal> does not only
      look for properties in the properties file you're defining, but also
      checks against the System properties if it cannot find the properties
      you're trying to replace. This behavior can be customized by tweaking
      with the <literal>systemPropertiesMode</literal> property of the
      configurer. It has three values, one to tell the configurer to always
      override, one to let it <emphasis>never</emphasis> override and one to
      let it override only if the property cannot be found in the properties
      file specified. Please consult the JavaDoc for the
      PropertiesPlaceHolderConfigurer for more information.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-factoryimpl">
    <title>BeanFactory structure and implementations (WIP)</title>

    <emphasis>From here on, up till the Context stuff, needs an
    overhaul.</emphasis>

    <para>The <literal>beans</literal> package contains a couple of different
    implementations. Concrete BeanFactories include the XmlBeanFactory which
    is the most popular format at the moment. However, the
    <literal>ListableBeanFactory</literal> is also a nice one, which is
    capable of reading bean definitions from properties files.</para>

    <sect2 id="beans-factoryimpl-structure"><title>Structure of the beans
    package</title> <para> Include UML and description here </para></sect2>

    <sect2 id="beans-factoryimpl-xml"><title>The
    <literal>XmlBeanFactory</literal></title> <para> The
    <literal>XmlBeanFactory</literal> is the most often-used implementation of
    the BeanFactory and is capable of reading bean definitions from XML files.
    XML files need to adhere to the Spring DTD, included in Appendix </para>
    <para> A couple of implementations of the BeanFactory come out-of-the-box.
    The <literal>XmlBeanFactory</literal> supports a bean definitions to be
    specified in XML files and the <literal>ListableBeanFactory</literal>
    supports bean definitions in the form of properties files. Most people use
    the XmlBeanFactory. However, implementing your own BeanFactory that
    supports bean definition in a database should not be to big an issue.
    Let's first discuss the XmlBeanFactory and the ListableBeanFactory and
    their features. </para> <para> Basically the two BeanFactory
    implementations Spring comes with provide all the features described
    above, like specifying the lifecycle methods, specifying whether or not to
    do autowiring, etcetera. The only way they differ is the way the
    configuration data (the bean definitions) are stored. </para></sect2>

    <sect2 id="beans-factoryimpl-xml2"><title>Bean definitions specified in
    XML (<literal>XmlBeanFactory</literal>)</title> <para> One of the
    implementations of the BeanFactory is the
    <literal>XmlBeanFactory</literal> (located in the package
    <literal>org.springframework.beans.factory.xml</literal>) which offers you
    the ability to specify bean definition in XML files as the name might have
    already told you. Spring comes with a DTD to do validation of the XML
    you're writing to specify beans in order to make things a bit more easy.
    The DTD is quite well documented so you should find everything you need in
    there as well. Here we will discuss the format shortly and provide some
    examples. </para></sect2>
  </sect1>

  <sect1 id="context-introduction">
    <title>Introduction to the <literal>ApplicationContext</literal></title>

    <para>While the <literal>beans</literal> package provides basic
    functionality for managing and manipulating beans, often in a programmatic
    way, the <literal>ApplicationContext</literal> introduces BeanFactory
    functionality in a more <emphasis>framework-style</emphasis> approach.
    Instead of programmatically loading beans using for example the
    XmlBeanFactory and retrieving them using the <literal>getBean()</literal>
    method, with the ApplicationContext you will be able to let the framework
    you're working in load your beans using for example the
    <literal>ContextLoader</literal>.</para>

    <para>The basis for the context package is the
    <literal>ApplicationContext</literal> interface, located in the
    <literal>org.springframework.context</literal> package. First of all it
    provides all the functionality the BeanFactory also provides. To be able
    to work in a more framework-oriented way, using layering and hierarchical
    contexts, the context package also provides the following: <itemizedlist
        spacing="compact">
        <listitem>
          <para><emphasis>MessageSource</emphasis>, providing access to
          messages in, i18n-style</para>
        </listitem>

        <listitem>
          <para><emphasis>Access to resources</emphasis>, like URLs and
          files</para>
        </listitem>

        <listitem>
          <para><emphasis>Event propagation</emphasis> to beans implementing
          the <literal>ApplicationListener</literal> interface</para>
        </listitem>

        <listitem>
          <para><emphasis>Loading of multiple contexts</emphasis>, allowing
          some of them to be focused and used for example only by the
          web-layer of an application</para>
        </listitem>
      </itemizedlist></para>

    <para>The ApplicationContext includes all the functionality the bean
    factory has as well. This means you can define beans using the XML format
    as explained in <xref linkend="beans-factoryimpl-xml" /> and <xref
    linkend="springbeansdtd" /> and retrieve them using their name or id.
    Also, you will be able to use all of the other features explained in this
    chapter, such as <emphasis>autowiring</emphasis>,
    <emphasis>setter-based</emphasis> or
    <emphasis>constructor-based</emphasis> dependency injection,
    <emphasis>dependency checking</emphasis>, <emphasis>lifecycle
    interfaces</emphasis>, etcetera. All other features the ApplicationContext
    includes are described below, as well as the ways to access an
    ApplicationContext, load beans into an ApplicationContext and the ways to
    customize existing ApplicationContexts using special beans defined in
    them.</para>
  </sect1>

  <sect1 id="context-functionality">
    <title>Added functionality of the
    <literal>ApplicationContext</literal></title>

    <para>As already stated in the previous section, the ApplicationContext
    has a couple of features that distinguish it from the BeanFactory. Let us
    review them one-by-one.</para>

    <sect2 id="context-functionality-messagesource">
      <title>Using the <literal>MessageSource</literal></title>

      <para>The ApplicationContext interface extends an interface called
      <literal>MessageSource</literal>, and therefore provides messaging
      (i18n) functionality. Together with the
      <literal>NestingMessageSource</literal>, capable of hierarchical message
      resolving, these are the basic interfaces Spring provides to do message
      resolving. Let's quickly review the methods defined there: <itemizedlist
          spacing="compact">
          <listitem>
            <para><literal>String getMessage (String code, Object[] args,
            String default, Locale loc)</literal>: the basic method to
            retrieve a message from the MessageSource. When no message could
            be found for the locale specified, the default message is used.
            Any arguments passed in are used as replacement values, using the
            <literal>MessageFormat</literal> functionality provided by the
            JDK</para>
          </listitem>

          <listitem>
            <para><literal>String getMessage (String code, Object[] args,
            Locale loc)</literal>: basically the same as the one above with
            one difference: the fact that no default message can be specified
            results in a <literal>NoSuchMessageException</literal> being
            thrown if the message could not be found</para>
          </listitem>

          <listitem>
            <para><literal>String getMessage(MessageSourceResolvable
            resolvable, Locale locale)</literal>: all properties used in the
            methods above are also wrapped in a class - the
            <literal>MessageSourceResolvable</literal>, which you can use in
            this method</para>
          </listitem>
        </itemizedlist></para>

      <para>When an ApplicationContext gets loaded, it automatically searches
      for a MessageSource bean defined in the context. The bean has to have
      the name <literal>messageSource</literal>. If such a bean is found, all
      calls to the methods desribed above will be delegated to the message
      source that was found. If no message source was found, the
      ApplicationContext inspects to see if it has a parent containing a
      similar bean, with a similar name. If so, it uses that bean as the
      MessageSource. If it can't find any source for messages, an empty
      <literal>StaticMessageSource</literal> will be instantiated in order to
      be able to accept calls to the methods defined above.</para>

      <para>Spring provides two <literal>MessageSource</literal>
      implementations at the moment. These are the
      <literal>ResourceBundleMessageSource</literal> and the
      <literal>StaticMessageSource</literal>. Both implement
      <literal>NestingMessageSource</literal> in order to do nested messaging.
      The StaticMessageSource is hardly ever used but provides programmatic
      ways to add messages to the source. The ResourceBundleMessageSource is
      more interesting and is the one we will provides an example for:
      <programlisting>&lt;beans&gt;
    &lt;bean id="messageSource" 
            class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;format&lt;/value&gt;
                &lt;value&gt;exceptions&lt;/value&gt;
                &lt;value&gt;windows&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt; </programlisting></para>

      <para>This assumes you have three resource bundles defined on your
      classpath called <literal>format</literal>,
      <literal>exceptions</literal> and <literal>windows</literal>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. TODO: SHOW AN
      EXAMPLE</para>
    </sect2>

    <sect2 id="context-functionality-events">
      <title>Propagating events</title>

      <para>Event handling in the ApplicationContext is provided through the
      <literal>ApplicationEvent</literal> class and
      <literal>ApplicationListener</literal> interface. When implementing the
      <literal>ApplicationListener</literal> in one of your beans, everytime
      an <literal>ApplicationEvent</literal> gets published to the
      ApplicationContext, your bean will be notified, based on the standard
      Observer design pattern implemented by the <literal>java.util</literal>
      package. Spring provides three standard events: <table frame="all">
          <title>Built-in Events</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="2*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Event</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>ContextRefreshedEvent</literal></entry>

                <entry>Event published when the ApplicationContext is
                initialized or refreshed. Initialized here means that all
                beans are loaded, singletons are pre-instantiated and the
                ApplicationContext is ready for use</entry>
              </row>

              <row>
                <entry><literal>ContextClosedEvent</literal></entry>

                <entry>Event published when the ApplicationContext is closed,
                using the <literal>close()</literal> method on the
                ApplicationContext. Closed here means that singletons are
                destroyed</entry>
              </row>

              <row>
                <entry><literal>RequestHandledEvent</literal></entry>

                <entry>A web-specific event telling all beans that a HTTP
                request has been serviced (i.e. this will be published
                <emphasis>after</emphasis> the request has been finished).
                Note that this event is only applicable for web applications
                using Spring's DispatcherServlet</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Implementing custom events can be done as well. All you need to do
      is call the <literal>publishEvent()</literal> method on the
      ApplicationContext and you're done. Let's have a look at an example.
      First, the ApplicationContext: <programlisting>&lt;bean id="emailer" class="example.EmailBean"&gt;
    &lt;property name="blackList"&gt;
        &lt;list&gt;
            &lt;value&gt;black@list.org&lt;/value&gt;
            &lt;value&gt;white@list.org&lt;/value&gt;
            &lt;value&gt;john@doe.org&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListListener" class="example.BlackListNotifier"&gt;
    &lt;property name="notificationAddress"&gt;
        &lt;value&gt;spam@list.org&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting> and then, the actual beans: <programlisting>public class EmailBean implements ApplicationContextAware {

    /** the blacklist */
    private List blackList;
    
    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }
    
    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }
    
    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent evt = new BlackListEvent(address, text);
            ctx.publishEvent(evt);
            return;
        }
        // send email
    }
}

public class BlackListNotifier implement ApplicationListener {

    /** notification address */
    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent evt) {
        if (evt instanceof BlackListEvent) {
            // notify appropriate person
        }
    }
}</programlisting> Of course, this behavior could be more cleanly implemented
      maybe, by using AOP features, but just to illustrate the basic behavior,
      this should do.</para>
    </sect2>

    <sect2 id="context-functionality-resources">
      <title>Using resources within Spring</title>

      <para>Emphasis: not sure where to cover this, let's leave it for now (so
      it's not complete yet).</para>

      <para>A lot of applications need to access resources. Resources here,
      might mean files, but also newsfeeds from the Internet or normal
      webpages. Spring provides a clean and transparent way of accessing
      resources in a protocol independent way. The ApplicationContext has a
      method (<literal>getResource(String)</literal>) to take care of
      this.</para>

      <para>The Resource class defines a couple of methods that are shared
      across all Resource implementations: <table frame="all">
          <title>Resource functionality</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="2*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Method</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>getInputStream()</literal></entry>

                <entry>Opens an InputStream on the resource and returns
                it</entry>
              </row>

              <row>
                <entry><literal>exists()</literal></entry>

                <entry>Checks if the resource exists, returning false if it
                doesn't</entry>
              </row>

              <row>
                <entry><literal>isOpen()</literal></entry>

                <entry>Will return true is multiple streams cannot be opened
                for this resource. This will be false for some resources, but
                file-based resources for instance, cannot be read multiple
                times concurrently</entry>
              </row>

              <row>
                <entry><literal>getDescription()</literal></entry>

                <entry>Returns a description of the resource, often the fully
                qualified file name or the actual URL</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>A couple of Resource implementations are provided by Spring. They
      all need a String representing the actual location of the resource.
      Based upon that String, Spring will automatically choose the right
      Resource implementation for you. When asking an ApplicationContext for a
      resource first of all Spring will inspect the resource location you're
      specifying and look for any prefixes. Depending on the implenentation of
      the ApplicationContext more or less Resource implementations are
      available. Resources can best be configured by using the ResourceEditor
      and for example the XmlBeanFactory.</para>
    </sect2>
  </sect1>

  <sect1 id="context-markers">
    <title>Extra marker interfaces and lifecycle features</title>

    <para>The BeanFactory already offers you some methods to control the
    lifecycle of your beans (like <literal>InitializingBean</literal> or
    <literal>init-method</literal> and its counterpart,
    <literal>DisposableBean</literal> or <literal>destroy-method</literal>).
    The <literal>context</literal> package builds on top of the BeanFactory so
    you can use those features in the context package as well. Besides the
    lifecycle features, the ApplicationContext has one extra marker interface
    you can add to your beans, the <literal>ApplicationContextAware</literal>
    interface. This interface will be used to let the bean know about the
    ApplicationContext it is <emphasis>contained</emphasis> in, using the
    <literal>setApplicationContext()</literal> method, which provides the
    ApplicationContext as an argument.</para>
  </sect1>

  <sect1 id="context-customization">
    <title>Customization of the ApplicationContext</title>

    <para>Where the BeanFactory can be customized programmatically using
    <literal>BeanFactoryPostProcessor</literal>, the ApplicationContext can be
    customized using special beans, defined in your ApplicationContext</para>
  </sect1>

  <sect1 id="beans-customeditors">
    <title>Registering additional custom editors</title>

    <para>When in need of a custom editor in your BeanFactory or
    ApplicationContext (e.g. you have some exotic type that you need to
    express as a property in a BeanFactory XML file), you can use the
    <literal>CustomEditorConfigurer</literal>, which is a special kind of
    <literal>BeanFactoryPostProcessor</literal> (more about those can be found
    in <xref linkend="beans-factory-customizing" />). Consider the following
    code samples: <programlisting>public class ExoticType {

    private String name;
    
    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {
    
    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}</programlisting> Wiring this up should be done something like this:
    <programlisting>&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type"&gt;&lt;value&gt;exoticTypeTwo&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting> When you want to do this, you would need to
    create a PropertyEditor and wire it up using the
    <literal>CustomEditorConfigurer</literal>: <programlisting>public class ExoticTypeEditor extends PropertyEditorSupport {

    private String format;

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setAsText(String text) {
        if (format != null &amp;&amp; format.equals("upperCase")) {
            text = text.toUpperCase();
        }
        ExoticType type = new ExoticType(text);
        setValue(type);
    }
}</programlisting> To actually register it, do the following: <programlisting>&lt;bean id="customEditorConfigurer" 
    class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="customEditors"&gt;
        &lt;map&gt;
            &lt;entry key="example.ExoticType"&gt;
                &lt;bean class="example.ExoticTypeEditor"&gt;
                    &lt;property name="format"&gt;
                        &lt;value&gt;upperCase&lt;/value&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>Besides using the <literal>CustomEditorConfigurer</literal>, you can
    also register custom editors programmatically if you need to. This might
    come in handy when for instance using the BeanFactory (which does not
    automatically detect BeanFactoryPostProcessors). Use the
    <literal>ConfigurableBeanFactory.registerCustomEditor()</literal> method
    to do this.</para>
  </sect1>

  <sect1>
    <title>Setting a bean property as the result of a method
    invocation</title>

    <para>It is sometimes necessary to set a property on a bean, as the result
    of a method call on another bean in the container, or a static method call
    on any arbitrary class. Additionally, it is sometimes necessary to call a
    static or non-static method just to perform some sort of initialization.
    For both of these purposes, a helper class called
    <classname>MethodInvokingFactoryBean</classname> may be used. This is a
    <literal><classname>FactoryBean</classname></literal> which returns a
    value which is the result of a static or instance method
    invocation.</para>

    <para>An example (in an XML based BeanFactory definition) of a bean
    definition which uses this class to call a static factory method:</para>

    <para><programlisting>&lt;bean id="myClass" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="staticMethod"&gt;&lt;value&gt;com.whatever.MyClassFactory.getInstance&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>An example of calling a static method then an instance method to get
    at a Java System property. Somewhat verbose, but it works.</para>

    <para><programlisting>&lt;bean id="sysProps" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetClass"&gt;&lt;value&gt;java.lang.System&lt;/value&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperties&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="javaVersion" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject"&gt;&lt;ref local='sysProps'/&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperty&lt;/value&gt;&lt;/property&gt;
  &lt;property name="arguments"&gt;
    &lt;list&gt;
      &lt;value&gt;java.version&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>Note that as it is expected to be used mostly for accessing factory
    methods, MethodInvokingFactoryBean by default operates in a
    <emphasis>singleton</emphasis> fashion. The first request by the container
    for the factory to produce an object will cause the specified method
    invocation, whose return value will cached and returned for the current
    and subsequent requests. An internal <literal>singleton</literal> property
    of the factory may be set to false, to cause it to invoke the target
    method each time it is asked for an object.</para>

    <para>A static target method may be specified by setting the
    <literal>targetMethod</literal> property to a String representing the
    static method name, with <literal>targetClass</literal> specifying the
    Class that the static method is defined on. Alternatively, a target
    instance method may be specified, by setting the
    <literal>targetObject</literal> property as the target object, and the
    <literal>targetMethod</literal> property as the name of the method to call
    on that target object. Arguments for the method invocation may be
    specified by setting the <literal>args</literal> property.</para>
  </sect1>

  <sect1 id="context-create">
    <title>Creating an ApplicationContext from a web application</title>

    <para>As opposed to the BeanFactory, which will often be created
    programmatically, ApplicationContexts can be created declaratively using
    for example a <literal>ContextLoader</literal>. Of course you can also
    create ApplicationContexts programmatically using one of the
    ApplicationContext implementations. First, let's examine the ContextLoader
    and its implementations.</para>

    <para>The ContextLoader has two implementations: the
    <literal>ContextLoaderListener</literal> and the
    <literal>ContextLoaderServlet</literal>. They both have the same
    functionality but differ in that the listener cannot be used in Servlet
    2.2 compatible containers. Since the Servlet 2.4 specification, listener
    are required to initialize after startup of a webapplication. A lot of 2.3
    compatible containers already implement this feature. It is up to you as
    to which one you use, but all things being equal you should probably
    prefer <literal>ContextLoaderListener</literal>; for more information on
    compatibility, have a look at the JavaDoc for the
    <literal>ContextLoaderServlet</literal>.</para>

    <para>You can register an ApplicationContext using the
    <literal>ContextLoaderListener</literal> as follows: <programlisting>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- OR USE THE CONTEXTLOADERSERVLET INSTEAD OF THE LISTENER
&lt;servlet&gt;
    &lt;servlet-name&gt;context&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--&gt;</programlisting> The listener inspects the
    <literal>contextConfigLocation</literal> parameter. If it doesn't exist,
    it'll use <literal>/WEB-INF/applicationContext.xml</literal> as a default.
    When it <emphasis>does</emphasis> exist, it'll separate the String using
    predefined delimiters (comma, semi-colon and space) and use the values as
    locations where application contexts will be searched for. The
    ContextLoaderServlet can - as said - be used instead of the
    ContextLoaderListener. The servlet will use the contextConfigLocation
    parameter just as the listener does.</para>
  </sect1>

  <sect1>
    <title>Glue code and the evil singleton</title>

    <para>The majority of the code inside an application is best written in a
    Dependency Injection (Inversion of Control) style, where that code is
    served out of a BeanFactory or ApplicationContext container, has its own
    dependencies supplied by the container when it is created, and is
    completely unaware of the container. However, for the small glue layers of
    code that are sometimes needed to tie other code together, there is
    sometimes a need for singleton (or quasi-singleton) style access to a
    BeanFactory or ApplicationContext. For example, third party code may try
    to construct new objects directly (<literal>Class.forName()</literal>
    style), without the ability to force it to get these objects out of a
    BeanFactory. If the object constructed by the third party code is just a
    small stub or proxy, which then uses a singleton style access to a
    BeanFactory/ApplicationContext to get a real object to delegate to, then
    inversion of control has still been achieved for the majority of the code
    (the object coming out of the BeanFactory); thus most code is still
    unaware of the container or how it is accessed, and remains uncoupled from
    other code, with all ensuing benefits. EJBs may also use this stub/proxy
    approach to delegate to a plain java implementation object, coming out of
    a BeanFactory. While the BeanFactory ideally does not have to be a
    singleton, it may be unrealistic in terms of memory usage or
    initialization times (when using beans in the BeanFactory such as a
    Hibernate SessionFactory) for each bean to use its own, non-singleton
    BeanFactory.</para>

    <para>As another example, in a complex J2EE apps with multiple layers
    (i.e. various JAR files, EJBs, and WAR files packaged as an EAR), with
    each layer having its own ApplicationContext definition (effectively
    forming a hierarchy), the preferred approach when there is only one
    web-app (WAR) in the top hierarchy is to simply create one composite
    ApplicationContext from the multiple XML definition files from each layer.
    All the ApplicationContext variants may be constructed from multiple
    definition files in this fashion. However, if there are multiple sibling
    web-apps at the top of the hierarchy, it is problematic to create an
    ApplicationContext for each web-app which conssists of mostly identical
    bean definitions from lower layers, as there may be issues due to
    increased memory usage, issues with creating mutliple copies of beans
    which take a long time to initialize (i.e. a Hibernate SessionFactory),
    and possible issues due to side-effects. As an alternative, classes like
    <literal>ContextSingletonBeanFactoryLocator</literal> or
    <literal>SingletonBeanFactoryLocator</literal> may be used to demand load
    multiple hierarchical (i.e. one is a parent of another) BeanFactories or
    ApplicationContexts in an effectively singleton fashion, which may then be
    used as the parents of the web-app ApplicationContexts. The result is that
    bean definitions for lower layers are loaded only as needed, and loaded
    only once.</para>

    <sect2>
      <title>Using SingletonBeanFactoryLocator and
      ContextSingletonBeanFactoryLocator</title>

      <para>You can see a detailed example of using
      <literal>SingletonBeanFactoryLocator</literal> and
      <literal>ContextSingletonBeanFactoryLocator</literal> by viewing their
      respective JavaDocs, available at <ulink
      url="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html">http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html</ulink>
      and <ulink
      url="http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html">http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html</ulink>.</para>

      <para>As mentioned in the chapter on EJBs, the Spring convenience base
      classes for EJBs normally use a non-singleton
      <literal>BeanFactoryLocator</literal> implementation, which is easily
      replaced by the use of <literal>SingletonBeanFactoryLocator</literal>
      and <literal>ContextSingletonBeanFactoryLocator</literal> if there is a
      need.</para>

      <para></para>
    </sect2>
  </sect1>
</chapter>