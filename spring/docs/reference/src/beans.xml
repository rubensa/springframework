<?xml version="1.0" encoding="UTF-8"?>
<chapter id="beans">
  <title>Beans, BeanFactory and the ApplicationContext</title>

  <sect1 id="beans-introduction">
    <title>Introduction</title>

    <para>Two of the most elementary and important packages in Spring are the
    <literal>org.springframework.beans</literal> and
    <literal>org.springframework.context</literal> packages. Code in these
    packages provides the basis for Spring's <emphasis>Inversion of
    Control</emphasis> (alternately called <emphasis>Dependency
    Injection</emphasis>) features. The <literal><ulink
    url="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</ulink></literal>
    provides an advanced configuration mechanism capable of managing beans
    (objects) of any nature, using potentially any kind of storage facility.
    The <ulink
    url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html">ApplicationContext</ulink>
    builds on top of the BeanFactory (it's a subclass) and adds other
    functionality such as easier integration with Springs AOP features,
    message resource handling (for use in internationalization), event
    propagation, declarative mechanisms to create the ApplicationContext and
    optional parent contexts, and application-layer specific contexts such as
    the <literal>WebApplicationContext</literal>, among other
    enhancements.</para>

    <para>In short, the <literal>BeanFactory</literal> provides the
    configuration framework and basic functionality, while the
    <literal>ApplicationContext</literal> adds enhanced capabilities to it,
    some of them perhaps more J2EE and enterprise-centric. In general, an
    ApplicationContext is a complete superset of a BeanFactory, and any
    description of BeanFactory capabilities and behavior should be considered
    to apply to ApplicationContexts as well.</para>

    <para>Users are sometimes unsure whether a BeanFactory or an
    ApplicationContext are best suited for use in a particular situation.
    Normally when building most applications in a J2EE-environment,
    <emphasis>the best option is to use the ApplicationContext</emphasis>,
    since it offers all the features of the BeanFactory and adds on to it in
    terms of features, while also allowing a more declarative approach to use
    of some functionality, which is generally desirable. The main usage
    scenario when you might prefer to use the BeanFactory is when memory usage
    is the greatest concern (such as in an applet where every last kilobyte
    counts), and you don't need all the features of the
    ApplicationContext.</para>

    <para>This chapter covers material related to both the BeanFactory and the
    ApplicationContext. When mention is made only of the BeanFactory, you may
    always assume the text also applies to the ApplicaitonContext. When
    functionality is only available in the ApplicationContext, explicit
    mention is made of this.</para>
  </sect1>

  <sect1 id="beans-basics">
    <title>BeanFactory and BeanDefinitions - the basics</title>

    <sect2 id="beans-factory">
      <title>The BeanFactory</title>

      <para>The <literal><ulink
      url="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</ulink></literal>
      is the actual <emphasis>container</emphasis> which instantiates,
      configures, and manages a number of beans. These beans typically
      collaborate with one another, and thus have dependencies between
      themselves. These dependencies are reflected in the configuration data
      used by the BeanFactory (although some dependencies may not be visible
      as configuration data, but rather be a function of programmatic
      interactions between beans at runtime).</para>

      <para>A BeanFactory is represented by the interface
      <literal>org.springframework.beans.factory.BeanFactory</literal>, for
      which there are multiple implementations. The most commonly used simple
      BeanFactory implementation is
      <literal>org.springframework.beans.factory.xml.XmlBeanFactory</literal>.
      (This should be qualified with the reminder that ApplicationContexts are
      a subclass of BeanFactory, and most users ultimately prefer to use XML
      variants of ApplicationContext).</para>

      <para>Although for most scenarios, almost all user code managed by the
      BeanFactory does not have to be aware of the BeanFactory, the
      BeanFactory does have to be instantiated somehow. This can happen via
      explicit user code such as:<programlisting>Resource res = new FileSystemResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(res);</programlisting></para>

      <para>or<programlisting>ClassPathResource res = new ClassPathResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(res);</programlisting></para>

      <para>or<programlisting>ClassPathXmlApplicationContext appContext = new ClassPathXmlApplicationContext(
        new String[] {"applicationContext.xml", "applicationContext-part2.xml"});
// of course, an ApplicationContext is just a BeanFactory
BeanFactory factory = (BeanFactory) appContext;</programlisting></para>

      <para>For many usage scenarios, user code will not have to instantiate
      the BeanFactory, since Spring Framework code will do it. For example,
      the web layer provides support code to load a Spring ApplicationContext
      automatically as part of the normal startup process of a J2EE web-app.
      This declarative process is described <link
      linkend="context-create">here</link>:</para>

      <para>While programmatic manipulation of BeanFactories will be described
      later, the following sections will concentrate on describing the
      configuration of BeanFactories.</para>

      <para>A BeanFactory configuration consists of, at its most basic level,
      definitions of one or more beans that the BeanFactory must manage. In an
      XmlBeanFactory, these are configured as one or more
      <literal>bean</literal> elements inside a top-level
      <literal>beans</literal> element.<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd"&gt;

&lt;beans&gt;
  
  &lt;bean id="..." class="..."&gt;
    ...
  &lt;/bean&gt;
  &lt;bean id="..." class="..."&gt;
    ...
  &lt;/bean&gt;

  ...

&lt;/beans&gt;</programlisting></para>
    </sect2>

    <sect2 id="beans-definition">
      <title>The BeanDefinition</title>

      <para>Bean definitions inside a DefaultListableBeanFactory variant (like
      XmlBeanFactory) are represented as BeanDefinition objects, which contain
      (among other information) the following details: <itemizedlist
          spacing="compact">
          <listitem>
            <para>a class name: this is normally the actual implementation
            class of the bean being described in the bean definition. However,
            if the bean is to be constructed by calling a static
            <emphasis>factory</emphasis> method instead of using a normal
            constructor, this will actually be the class name of the factory
            class.</para>
          </listitem>

          <listitem>
            <para>bean behavioral configuration elements, which state how the
            bean should behave in the container (i.e. prototype or singleton,
            autowiring mode, dependency checking mode, initialization and
            destruction methods)</para>
          </listitem>

          <listitem>
            <para>constructor arguments and property values to set in the
            newly created bean. An example would be the number of connections
            to use in a bean that manages a connection pool (either specified
            as a property or as a constructor argument), or the pool size
            limit.</para>
          </listitem>

          <listitem>
            <para>other beans a bean needs to do its work, i.e.
            <emphasis>collaborators</emphasis> (also specified as properties
            or as constructor arguments). These can also be called
            dependencies.</para>
          </listitem>
        </itemizedlist></para>

      <para>The concepts listed above directly translate to a set of elements
      the bean definition consists of. Some of these element groups are listed
      below, along with a link to further documentation about each of them.
      <table frame="all">
          <title>Bean definition explanation</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="2*" />

            <colspec colname="c2" colwidth="4*" />

            <thead>
              <row>
                <entry>Feature</entry>

                <entry>More info</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>class</entry>

                <entry><xref linkend="beans-factory-class" /></entry>
              </row>

              <row>
                <entry>id and name</entry>

                <entry><xref linkend="beans-beanname" /></entry>
              </row>

              <row>
                <entry>singleton or prototype</entry>

                <entry><xref linkend="beans-factory-modes" /></entry>
              </row>

              <row>
                <entry>constructor arguments</entry>

                <entry><xref linkend="beans-factory-collaborators" /></entry>
              </row>

              <row>
                <entry>bean properties</entry>

                <entry><xref linkend="beans-factory-collaborators" /></entry>
              </row>

              <row>
                <entry>autowiring mode</entry>

                <entry><xref linkend="beans-factory-autowire" /></entry>
              </row>

              <row>
                <entry>dependency checking mode</entry>

                <entry><xref linkend="beans-factory-dependencies" /></entry>
              </row>

              <row>
                <entry>initialization method</entry>

                <entry><xref linkend="beans-factory-lifecycle" /></entry>
              </row>

              <row>
                <entry>destruction method</entry>

                <entry><xref linkend="beans-factory-lifecycle" /></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Note that a bean definition is represented by the real interface
      <literal>org.springframework.beans.factory.config.BeanDefinition</literal>,
      and its various sub-interfaces and implementations. However, it is very
      unlikely that most user code would ever work with a
      BeanDefinition.</para>

      <para>Besides bean definitions which contain information on how to
      create a bean, a bean factory can also allow to register existing bean
      instances. DefaultListableBeanFactory supports this through the
      <literal>registerSingleton</literal> method, as defined by the
      <literal>org.springframework.beans.factory.config.ConfigurableBeanFactory</literal>
      interface. Typical applications purely work with bean definitions,
      though.</para>
    </sect2>

    <sect2 id="beans-factory-class">
      <title>The bean class</title>

      <para>The <literal>class</literal> attribute is normally mandatory (see
      <xref linkend="beans-instance-factory-method" /> and <xref
      linkend="beans-child-bean-definitions" /> for the two exception) and is
      used for one of two purposes. In the much more common case where the
      BeanFactory itself directly creates the bean by calling its constructor
      (equivalent to Java code calling <emphasis>new</emphasis>), the class
      attribute specifies the class of the bean to be constructed. In the less
      common case where the BeanFactory calls a static, so-called
      <emphasis>factory</emphasis> method on a class to create the bean, the
      class attribute specifies the actual class containing the static factory
      method. (the type of the returned bean from the static factory method
      may be the same class or another class entirely, it doesn't
      matter).</para>

      <sect3>
        <title>Bean creation via constructor</title>

        <para>When creating a bean using the constructor approach, all normal
        classes are usable by Spring and compatible with Spring. That is, the
        class being created does not need to implement any specific interfaces
        or be coded in a specific fashion. Just specifying the bean class
        should be enough. However, depending on what type of IoC you are going
        to use for that specific bean, you may need a default (empty)
        constructor.</para>

        <para>Additionally, the BeanFactory isn't limited to just managing
        true JavaBeans, it is also able to manage virtually
        <emphasis>any</emphasis> class you want it to manage. Most people
        using Spring prefer to have actual JavaBeans (having just a default
        (no-argument) constructor and appropriate setters and getters modeled
        after the properties) in the BeanFactory, but it it's also possible to
        have more exotic non-bean-style classes in your BeanFactory. If, for
        example, you need to use a legacy connection pool that absolutely does
        not adhere to the JavaBean specification, no worries, Spring can
        manage it as well.</para>

        <para>Using the XmlBeanFactory you can specify your bean class as
        follows: <programlisting>&lt;bean id="exampleBean"
      class="examples.ExampleBean"/&gt;
&lt;bean name="anotherExample"
      class="examples.ExampleBeanTwo"/&gt; </programlisting></para>

        <para>The mechanism for supplying (optional) arguments to the
        constructor, or setting properties of the object instance after it has
        been constructed, will be described shortly.</para>
      </sect3>

      <sect3>
        <title>Bean creation via static factory method</title>

        <para>When defining a bean which is to be created using a static
        factory method, along with the <literal>class</literal> attribute
        which specifies the class containing the static factory method,
        another attribute named <literal>factory-method</literal> is needed to
        specify the name of the factory method itself. Spring expects to be
        able to call this method (with an optional list of arguments as
        described later) and get back a live object, which from that point on
        is treated as if it had been created normally via a constructor. One
        use for such a bean definition is to call static factories in legacy
        code.</para>

        <para>Following is an example of a bean definition which specifies
        that the bean is to be created by calling a factory-method. Note that
        the definition does not specify the type (class) of the returned
        object, only the class containing the factory method. In this example,
        <literal>createInstance</literal> must be a
        <emphasis>static</emphasis> method.<programlisting>&lt;bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/&gt;</programlisting></para>

        <para>The mechanism for supplying (optional) arguments to the factory
        method, or setting properties of the object instance after it has been
        returned from the factory, will be described shortly.</para>
      </sect3>

      <sect3 id="beans-instance-factory-method">
        <title>Bean creation via instance factory method</title>

        <para>Quite similar to using a static factory method to create a bean,
        is the use of an instance (non-static) factory method, where a factory
        method of an existing bean from the factory is called to create the
        new bean.</para>

        <para>To use this mechanism, the <literal>class</literal> attribute
        must be left empty, and the <literal>factory-bean</literal> attribute
        must specify the name of a bean in the current or an ancestor bean
        factory which contains the factory method. The factory method itself
        should still be set via the <literal>factory-method</literal>
        attribute.</para>

        <para>Following is an example:<programlisting>&lt;!-- The factory bean, which contains a method called
     createInstance --&gt;
&lt;bean id="myFactoryBean"
      class="..."&gt;
  ...
&lt;/bean&gt;
&lt;!-- The bean to be created via the factory bean --&gt;
&lt;bean id="exampleBean"
      factory-bean="myFactoryBean"
      factory-method="createInstance"/&gt;</programlisting></para>

        <para>Although the mechanisms for setting bean properties are still to
        be discussed, one implication of this approach is that the factory
        bean itself can be managed and configured via Dependency Injection, by
        the container.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-beanname">
      <title>The bean identifiers (<literal>id</literal> and
      <literal>name</literal>)</title>

      <para>Every bean has one or more ids (also called identifiers, or names;
      these terms refer to the same thing). These ids must be unique within
      the BeanFactory or ApplicationContext the bean is hosted in. A bean will
      almost always have only one id, but if a bean has more than one id, the
      extra ones can essentially be considered aliases.</para>

      <para>In an XmlBeanFactory (including ApplicationContext variants), you
      use the <literal>id</literal> or <literal>name</literal> attributes to
      specify the bean id(s), and at least one id must be specified in one or
      both of these attributes. The <literal>id</literal> attribute allows you
      to specify one id, and as it is marked in the XML DTD (definition
      document) as a real XML element ID attribute, the parser is able to do
      some extra validation when other elements point back to this one. As
      such, it is the preferred way to specify a bean id. However, the XML
      spec does limit the characters which are legal in XML IDs. This is
      usually not really a constraint, but if you have a need to use one of
      these characters, or want to introduce other aliases to the bean, you
      may also or instead specify one or more bean ids (separated by a comma
      (<literal>,</literal>) or semicolon (<literal>;</literal>) via the
      <literal>name</literal> attribute.</para>
    </sect2>

    <sect2 id="beans-factory-modes">
      <title>To singleton or not to singleton</title>

      <para>Beans are defined to be deployed in one of two modes: singleton or
      non-singleton. (The latter is also called a prototype, although the term
      is used loosely as it doesn't quite fit). When a bean is a singleton,
      only one <emphasis>shared</emphasis> instance of the bean will be
      managed and all requests for beans with an id or ids matching that bean
      definition will result in that one specific bean instance being
      returned.</para>

      <para>The non-singleton, prototype mode of a bean deployment results in
      the <emphasis>creation of a new bean instance</emphasis> every time a
      request for that specific bean is done. This is ideal for situations
      where for example each user needs an independent user object or
      something similar.</para>

      <para>Beans are deployed in singleton mode by default, unless you
      specify otherwise. Keep in mind that by changing the type to
      non-singleton (prototype), each request for a bean will result in a
      newly created bean and this might not be what you actually want. So only
      change the mode to prototype when absolutely necessary.</para>

      <para>In the example below, two beans are declared of which one is
      defined as a singleton, and the other one is a non-singleton
      (prototype). <literal>exampleBean</literal> is created each and every
      time a client asks the BeanFactory for this bean, while
      <literal>yetAnotherExample</literal> is only created once; a reference
      to the exact same instance is returned on each request for this
      bean.<programlisting>&lt;bean id="exampleBean"
      class="examples.ExampleBean" singleton="false"/&gt;
&lt;bean name="yetAnotherExample"
      class="examples.ExampleBeanTwo" singleton="true"/&gt;</programlisting></para>

      <para>Note: when deploying a bean in the prototype mode, the lifecycle
      of the bean changes slightly. By definition, Spring cannot manage the
      complete lifecycle of a non-singleton/prototype bean, since after it is
      created, it is given to the client and the container does not keep track
      of it at all any longer. You can think of Spring's role when talking
      about a non-singleton/prototype bean as a replacement for the 'new'
      operator. Any lifecycle aspects past that point have to be handled by
      the client. The lifecycle of a bean in the BeanFactory is further
      described in <xref linkend="beans-factory-lifecycle" />.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-dependencies">
    <title>Properties, collaborators, autowiring and dependency
    checking</title>

    <sect2 id="beans-factory-collaborators">
      <title>Setting bean properties and collaborators</title>

      <para>Inversion of Control has already been referred to as
      <emphasis>Dependency Injection</emphasis>. The basic principle is that
      beans define their dependencies (i.e. the other objects they work with)
      only through constructor arguments, arguments to a factory method, or
      properties which are set on the object instance after it has been
      constructed or returned from a factory method. Then, it is the job of
      the container to actually <emphasis>inject</emphasis> those dependencies
      when it creates the bean. This is fundamentally the inverse (hence the
      name Inversion of Control) of the bean instantiating or locating its
      dependencies on its own using direct construction of classes, or
      something like the <emphasis>Service Locator</emphasis> pattern. While
      we will not elaborate too much on the advantages of Dependency
      Injection, it becomes evident upon usage that code gets much cleaner and
      reaching a higher grade of decoupling is much easier when beans do not
      look up their dependencies, but are provided with them, and additionally
      do not even know where the dependencies are located and of what actual
      type they are.</para>

      <para>As touched on in the previous paragraph, Inversion of
      Control/Dependency Injection exists in two major variants:<itemizedlist
          spacing="compact">
          <listitem>
            <para><emphasis>setter-based</emphasis> dependency injection is
            realized by calling setters on your beans after invoking a
            no-argument constructor or no-argument static factory method to
            instantiate your bean. Beans defined in the BeanFactory that use
            setter-based dependency injection are <emphasis>true
            JavaBeans</emphasis>. Spring generally advocates usage of
            setter-based dependency injection, since a large number of
            constructor arguments can get unwieldy, especially when some
            properties are optional.</para>
          </listitem>

          <listitem>
            <para><emphasis>constructor-based</emphasis> dependency injection
            is realized by invoking a constructor with a number of arguments,
            each representing a collaborator or property. Additionally,
            calling a static factory method with specific arguments, to
            construct the bean, can be considered almost equivalent, and the
            rest of this text will consider arguments to a constructor and
            arguments to a static factory method similarly. Although Spring
            generally advocates usage of setter-based dependency injection for
            most situations, it does fully support the constructor-based
            approach as well, since you may wish to use it with pre-existing
            beans which provide only multi-argument constructors, and no
            setters. Additionally, for simpler beans, some people prefer the
            constructor approach as a means of ensuring beans cannot be
            constructed in an invalid state.</para>
          </listitem>
        </itemizedlist></para>

      <para>The <classname>BeanFactory</classname> supports both of these
      variants for injecting dependencies into beans it manages. (It in fact
      also supports injecting setter-based dependencies after some
      dependencies have already been supplied via the constructor approach.)
      The configuration for the dependencies comes in the form of a
      <literal>BeanDefinition</literal>, which is used together with JavaBeans
      <literal>PropertyEditors</literal> to know how to convert properties
      from one format to another. The actual values being passed around are
      done in the form of <literal>PropertyValue</literal> objects. However,
      most users of Spring will not be dealing with these classes directly
      (i.e. programmatically), but rather with an XML definition file which
      will be converted internally into instances of these classes, and used
      to load an entire BeanFactory or ApplicationContext.</para>

      <para>Bean dependency resolution generally happens as
      follows:<orderedlist spacing="compact">
          <listitem>
            <para>The BeanFactory is created and initialized with a
            configuration which describes all the beans. Most Spring users use
            a BeanFactory or ApplicationContext variant which supports XML
            format configuration files.</para>
          </listitem>

          <listitem>
            <para>Each bean has dependencies expressed in the form of
            properties, constructor arguments, or arguments to the
            static-factory method when that is used instead of a normal
            constructor. These dependencies will be provided to the bean,
            <emphasis>when the bean is actually created</emphasis>.</para>
          </listitem>

          <listitem>
            <para>Each property or constructor-arg is either an actual
            definition of the value to set, or a reference to another bean in
            the BeanFactory. In the case of the ApplicationContext, the
            reference can be to a bean in a parent ApplicationContext.</para>
          </listitem>

          <listitem>
            <para><anchor
            id="beans-factory-collaborators-propertyeditor" />Each property or
            constructor argument which is a value must be able to be converted
            from whatever format it was specified in, to the actual type of
            that property or constructor argument. By default Spring can
            convert a value supplied in string format to all built-in types,
            such as <literal>int</literal>, <literal>long</literal>,
            <literal>String</literal>, <literal>boolean</literal>, etc.
            Additionally, when talking about the XML based BeanFactory
            variants (including the ApplicationContext variants), these have
            built-in support for defining Lists, Maps, Sets, and Properties
            collection types. Additionally, Spring uses JavaBeans
            <classname>PropertyEditor</classname> definitions to be able to
            convert string values to other, arbitrary types. (You can provide
            the BeanFactory with your own <literal>PropertyEditor</literal>
            definitions to be able to convert your own custom types; more
            information about PropertyEditors and how to manually add custom
            ones, can be found in <xref
            linkend="beans-beanfactory-customeditors" />). When a bean
            property is a Java Class type, Spring allows you to specify the
            value for that property as a string value which is the name of the
            class, and the <literal>ClassEditor</literal> PropertyEditor,
            which is built-in, will take care of converting that class name to
            an actual Class instance.</para>
          </listitem>

          <listitem>
            <para>It is important to realize that Spring validates the
            configuration of each bean in the BeanFactory when the BeanFactory
            is created, including the validation that properties which are
            bean references are actually referring to valid beans (i.e. the
            beans being referred to are also defined in the BeanFactory, or in
            the case of ApplicationContext, a parent context). However, the
            bean properties themselves are not set until the bean <emphasis>is
            actually created</emphasis>. For beans which are singleton and set
            to be pre-instantiated (such as singleton beans in an
            ApplicationContext), creation happens at the time that the
            BeanFactory is created, but otherwise this is only when the bean
            is requested. When a bean actually has to be created, this will
            potentially cause a graph of other beans to be created, as its
            dependencies and its dependencies' dependencies (and so on) are
            created and assigned.</para>
          </listitem>

          <listitem>
            <para>You can generally trust Spring to do the right thing. It
            will pick up configuration issues, including references to
            non-existent beans and circular dependencies, at BeanFactory
            load-time. It will actually set properties and resolve
            dependencies (i.e. create those dependencies if needed) as late as
            possible, which is when the bean is actually created. This does
            mean that a BeanFactory which has loaded correctly, can later
            generate an exception when you request a bean, if there is a
            problem creating that bean or one of its dependencies. This could
            happen if the bean throws an exception as a result of a missing or
            invalid property, for example. This potentially delayed visibility
            of some configuration issues is why ApplicationContext by default
            pre-instantiates singleton beans. At the cost of some upfront time
            and memory to create these beans before they are actually needed,
            you find out about configuration issues when the
            ApplicationContext is created, not later. If you wish, you can
            still override this default behavior and set any of these
            singleton beans to lazy-load (not be pre-instantiated).</para>
          </listitem>
        </orderedlist></para>

      <para>Some examples:</para>

      <para>First, an example of using the BeanFactory for setter-based
      dependency injection. Below is a small part of an
      <literal>XmlBeanFactory</literal> configuration file specifying some
      bean definitions. Following is the code for the actual main bean itself,
      showing the appropriate setters declared. <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;
    &lt;property name="beanTwo"&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/property&gt;
    &lt;property name="integerProperty"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>
      <programlisting>public class ExampleBean {
    
    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }
    
    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }
    
    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}</programlisting>As you can see, setters have been declared to match against
      the properties specified in the XML file. (The properties from the XML
      file, directly relate to the <literal>PropertyValues</literal> object
      from the <literal>RootBeanDefinition</literal>)</para>

      <para>Now, an example of using the BeanFactory for IoC type 3
      (constructor-based dependency injection). Below is a snippet from an XML
      configuration that specifies constructor arguments and the actual bean
      code, showing the constructor: <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg type="int"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>
      <programlisting>public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</programlisting>As you can see, the constructor arguments specified in the
      bean definition will be used to pass in as arguments to the constructor
      of the <literal>ExampleBean</literal>.</para>

      <para>Now consider a variant of this where instead of using a
      constructor, Spring is told to call a static factory method to return an
      instance of the object.: <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&gt;
    &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</programlisting>
      <programlisting>public class ExampleBean {

    ...

    // a private constructor
    private ExampleBean(...) {
      ...
    }
    
    // a static factory method
    // the arguments to this method can be considered the dependencies of the bean that
    // is returned, regardless of how those arguments are actually used.
    public static ExampleBean createInstance(
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        ExampleBean eb = new ExampleBean(...);
        // some other operations
        ...
        return eb;
    }
}</programlisting></para>

      <para>Note that arguments to the static factory method are supplied via
      <literal>constructor-arg</literal> elements, exactly the same as if a
      constructor had actually been used. These arguments are optional. Also,
      it is important to realize that the type of the class being returned by
      the factory method does not have to be of the same type as the class
      which contains the static factory method, although in this example it
      is. An instance (non-static) factory method, mentioned previously, would
      be used in an essentially identical fashion (aside from the use of the
      <literal>factory-bean</literal> attribute instead of the
      <literal>class</literal> attribute), so will not be detailed
      here.</para>
    </sect2>

    <sect2>
      <title>Constructor Argument Resolution</title>

      <para>Constructor argument resolution matching occurs using the
      argument's type. When another bean is referenced, the type is known, and
      matching can occur. When a simple type is used, such as
      <literal>&lt;value&gt;true&lt;value&gt;</literal>, Spring cannot
      determine the type of the value, and so cannot match by type without
      help. Consider the following class, which is used for the following two
      sections: <programlisting>package examples;

public class ExampleBean {

    private int years;             //No. of years to the calculate the Ultimate Answer
    private String ultimateAnswer; //The Answer to Life, the Universe, and Everything

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</programlisting></para>

      <sect3>
        <title>Constructor Argument Type Matching</title>

        <para>The above scenario <emphasis>can</emphasis> use type matching
        with simple types by explicitly specifying the type of the constructor
        argument using the <literal>type</literal> attribute. For example:
        <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
     &lt;constructor-arg type="int"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
     &lt;constructor-arg type="java.lang.String"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt; </programlisting></para>
      </sect3>

      <sect3>
        <title>Constructor Argument Index</title>

        <para>Constructor arguments can have their index specified explicitly
        by use of the <literal>index</literal> attribute. For example:
        <programlisting>&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
     &lt;constructor-arg index="0"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
     &lt;constructor-arg index="1"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt; </programlisting> As well as solving the ambiguity problem of
        multiple simple values, specifying an index also solves the problem of
        ambiguity where a constructor may have two arguments of the same type.
        Note that the <emphasis>index is 0 based</emphasis>.</para>

        <para>Specifying a constructor argument index is the preferred way of
        performing constructor IoC.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-properties-detailed">
      <title>Bean properties and constructor arguments detailed</title>

      <para>As mentioned in the previous section, bean properties and
      constructor arguments can be defined as either references to other
      managed beans (collaborators), or values defined inline. The
      <literal>XmlBeanFactory</literal> supports a number of sub-element types
      within its <literal>property</literal> and
      <literal>constructor-arg</literal> elements for this purpose.</para>

      <sect3 id="beans-value-element">
        <title>The <literal>value</literal> element</title>

        <para>The <literal>value</literal> element specifies a property or
        constructor argument as a human-readable string representation. As
        mentioned in detail <link
        linkend="beans-factory-collaborators-propertyeditor">previously</link>,
        JavaBeans PropertyEditors are used to convert these string values from
        a <literal>java.lang.String</literal> to the actual property or
        argument type.<programlisting>&lt;beans&gt;
    &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
        &lt;!-- results in a setDriverClassName(String) call --&gt;
        &lt;property name="driverClassName"&gt;
            &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="url"&gt;
            &lt;value&gt;jdbc:mysql://localhost:3306/mydb&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="username"&gt;
            &lt;value&gt;root&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</programlisting></para>
      </sect3>

      <sect3 id="beans-null-element">
        <title>The <literal>null</literal> element</title>

        <para>The <literal>null</literal> element is used to handle null
        values. Spring treats empty arguments for properties and the like as
        empty Strings. The following XmlBeanFactory configuration:
        <programlisting>&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;        </programlisting>results in the email property being set
        to "", equivalent to the java code:
        <literal>exampleBean.setEmail("")</literal>. The special
        <literal>&lt;null&gt;</literal> element may be used to indicate a null
        value, so that: <programlisting>&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;        </programlisting>is equivalent to the java code:
        <literal>exampleBean.setEmail(null)</literal>.</para>
      </sect3>

      <sect3 id="beans-collection-elements">
        <title>The collection elements</title>

        <para>The <literal>list</literal>, <literal>set</literal>,
        <literal>map</literal>, and <literal>props</literal> elements allow
        properties and arguments of Java type <literal>List</literal>,
        <literal>Set</literal>, <literal>Map</literal>, and
        <literal>Properties</literal>, respectively, to be defined and
        set.<programlisting>&lt;beans&gt;
    ...
    &lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
        &lt;!-- results in a setPeople(java.util.Properties) call --&gt;
        &lt;property name="people"&gt;
            &lt;props&gt;
                &lt;prop key="HarryPotter"&gt;The magic property&lt;/prop&gt;
                &lt;prop key="JerrySeinfeld"&gt;The funny property&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeList(java.util.List) call --&gt;
        &lt;property name="someList"&gt;
            &lt;list&gt;
                &lt;value&gt;a list element followed by a reference&lt;/value&gt;
                &lt;ref bean="myDataSource"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
        &lt;property name="someMap"&gt;
            &lt;map&gt;
                &lt;entry key="yup an entry"&gt;
                    &lt;value&gt;just some string&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry key="yup a ref"&gt;
                    &lt;ref bean="myDataSource"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
        &lt;property name="someSet"&gt;
            &lt;set&gt;
                &lt;value&gt;just some string&lt;/value&gt;
                &lt;ref bean="myDataSource"/&gt;
            &lt;/set&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
&lt;/beans&gt;</programlisting></para>

        <para><emphasis>Note that the value of a Map entry, or a set value,
        can also again be any of the elements:</emphasis><programlisting>(bean | ref | idref | list | set | map | props | value | null)</programlisting></para>
      </sect3>

      <sect3 id="beans-inner-beans">
        <title>Inner bean definitions via nested bean elements</title>

        <para>A <literal>bean</literal> element inside the
        <literal>property</literal> element is used to define a bean value
        inline, instead of referring to a bean defined elsewhere in the
        BeanFactory. The inline bean definition does not need to have any id
        defined. <programlisting>&lt;bean id="outer" class="..."&gt;
    &lt;!-- Instead of using a reference to target, just use an inner bean --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.mycompany.PersonImpl"&gt;
            &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
            &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
        &lt;/bean&gt;
   &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para>Note that the <literal>singleton</literal> flag and any
        <literal>id</literal> attribute are effectively ignored. Inner beans
        are anonymous prototypes.</para>
      </sect3>

      <sect3 id="beans-idref-element">
        <title>The <literal>idref</literal> element</title>

        <para>An idref element is simply a shorthand and error-proof way to
        set a property to the String <emphasis>id</emphasis> or
        <emphasis>name</emphasis> of another bean in the
        container.<programlisting>&lt;bean id="theTargetBean" class="..."&gt;
&lt;/bean&gt;
&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>This is exactly equivalent at runtime to the
        following fragment:<programlisting>&lt;bean id="theTargetBean" class="..."&gt;
&lt;/bean&gt;
&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;value&gt;theTargetBean&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>The main reason the first form is preferable to
        the second is that using the <literal>idref</literal> tag will allow
        Spring to validate at deployment time that the other bean actually
        exists. In the second variation, the class who's
        <emphasis>targetName</emphasis> property is forced to do its own
        validation, and that will only happen when that class is actually
        instantiated by Spring, possibly long after the container is actually
        deployed.</para>

        <para>Additionally, if the bean being referred to is in the same
        actual XML file, and the bean name is the bean
        <emphasis>id</emphasis>, the <literal>local</literal> attribute may be
        used, which will allow the XML parser itself to validate the bean name
        even earlier, at XML document parse time.<programlisting>    &lt;property name="targetName"&gt;
        &lt;idref local="theTargetBean"/&gt;
    &lt;/property&gt;</programlisting></para>
      </sect3>

      <sect3 id="beans-ref-element">
        <title>The <literal>ref</literal> element</title>

        <para>The <literal>ref</literal> element is the final element allowed
        inside a <literal>property</literal> definition element. It is used to
        set the value of the specified property to be a reference to another
        bean managed by the container, a collaborator, so to speak. As
        mentioned in a previous section, the referred-to bean is considered to
        be a dependency of the bean who's property is being set, and will be
        initialized on demand as needed (if it is a singleton bean it may have
        already been initialized by the container) before the property is set.
        All references are ultimately just a reference to another object, but
        there are 3 variations on how the id/name of the other object may be
        specified, which determines how scoping and validation is
        handled.</para>

        <para>Specifying the target bean by using the <literal>bean</literal>
        attribute of the <literal>ref</literal> tag is the most general form,
        and will allow creating a reference to any bean in the same
        BeanFactory/ApplicationContext (whether or not in the same XML file),
        or parent BeanFactory/ApplicationContext. The value of the
        <literal>bean</literal> attribute may be the same as either the
        <literal>id</literal> attribute of the target bean, or one of the
        values in the <literal>name</literal> attribute of the target
        bean.<programlisting>    &lt;ref bean="someBean"/&gt;</programlisting></para>

        <para>Specifying the target bean by using the <literal>local</literal>
        attribute leverages the ability of the XML parser to validate XML id
        references within the same file. The value of the
        <literal>local</literal> attribute must be the same as the
        <literal>id</literal> attribute of the target bean. The XML parser
        will issue an error if no matching element is found in the same file.
        As such, using the local variant is the best choice (in order to know
        about errors are early as possible) if the target bean is in the same
        XML file.<programlisting>    &lt;ref local="someBean"/&gt;</programlisting></para>

        <para>Specifying the target bean by using the
        <literal>parent</literal> attribute allows a reference to be created
        to a bean which is in a parent BeanFactory (or ApplicationContext) of
        the current BeanFactory (or ApplicationContext). The value of the
        <literal>parent</literal> attribute may be the same as either the
        <literal>id</literal> attribute of the target bean, or one of the
        values in the <literal>name</literal> attribute of the target bean,
        and the target bean must be in a parent BeanFactory or
        ApplicationContext to the current one. The main use of this bean
        reference variant is when there is a need to wrap an existing bean in
        a parent context with some sort of proxy (which may have the same name
        as the parent), and needs the original object so it may wrap
        it.</para>

        <para><programlisting>    &lt;ref parent="someBean"/&gt;</programlisting></para>
      </sect3>

      <sect3>
        <title id="beans-value-ref-shortcuts">Value and Ref shortcut
        forms</title>

        <para>It is so common to need to configure a value or a bean
        reference, that there exist some shortcut forms which are less verbose
        than using the full <literal>value</literal> and
        <literal>ref</literal> elements. The <literal>property</literal>,
        <literal>constructor-arg</literal>, and <literal>entry</literal>
        elements all support a <literal>value</literal> attribute which may be
        used instead of embedding a full <literal>value</literal> element.
        Therefore, the following:</para>

        <para><programlisting>&lt;property name="myProperty"&gt;
    &lt;value&gt;hello&lt;/value&gt;
&lt;/property</programlisting><programlisting>&lt;constructor-arg&gt;
    &lt;value&gt;hello&lt;/value&gt;
&lt;/constructor-arg&gt;</programlisting><programlisting>&lt;entry key="myKey"&gt;
    &lt;value&gt;hello&lt;/value&gt;
&lt;/entry&gt;</programlisting></para>

        <para>are equivalent to:</para>

        <para><programlisting>&lt;property name="myProperty" value="hello"/&gt;</programlisting><programlisting>&lt;constructor-arg value="hello"/&gt;</programlisting><programlisting>&lt;entry key="myKey" value="hello"/&gt;</programlisting>In
        general, when typing definitions by hand, you will probably prefer to
        use the less verbose shortcut form.</para>

        <para>The <literal>property</literal> and
        <literal>constructor-arg</literal> elements support a similar shortcut
        <literal>ref</literal> attribute which may be used instead of a full
        nested <literal>ref</literal> element. Therefore, the
        following:</para>

        <para><programlisting>&lt;property name="myProperty"&gt;
    &lt;ref bean="myBean"&gt;
&lt;/property</programlisting><programlisting>&lt;constructor-arg&gt;
    &lt;ref bean="myBean"&gt;
&lt;/constructor-arg&gt;</programlisting></para>

        <para>is equivalent to:</para>

        <para><programlisting>&lt;property name="myProperty" ref="myBean"/&gt;</programlisting><programlisting>&lt;constructor-arg ref="myBean"/&gt;</programlisting></para>

        <para>Note however that the shortcut form is equivalent to a
        <literal>&lt;ref bean="xxx"&gt;</literal> element, there is no
        shortcut for <literal>&lt;ref local="xxx"</literal>&gt;. For a local
        ref you must use the long form.</para>

        <para>Finally, the entry element allows a shortcut form to specify the
        key and/or value of the map, in the form of the
        <literal>key-ref</literal> and <literal>value-ref</literal>
        attributes. Therefore, the following:</para>

        <para><programlisting>&lt;entry&gt;
  &lt;key&gt;&lt;ref bean="myKeyBean"/&gt;&lt;/key&gt;
  &lt;ref bean="myValueBean"/&gt;
&lt;/entry&gt;
</programlisting></para>

        <para>is equivalent to:</para>

        <para><programlisting>&lt;entry key-ref="myKeyBean" value-ref="myValueBean"/&gt;
</programlisting>Again, the shortcut form is equivalent to a <literal>&lt;ref
        bean="xxx"&gt;</literal> element, there is no shortcut for
        <literal>&lt;ref local="xxx"</literal>&gt;.</para>
      </sect3>

      <sect3>
        <title id="beans-value-ref-shortcuts">Compound property names</title>

        <para>Note that compound or nested property names are perfectly legal
        when setting bean properties, as long as all components of the path
        except the final property name are non-null. For example, in this bean
        definition:</para>

        <para><programlisting>&lt;bean id="foo" class="foo.Bar"&gt;
   &lt;property name="fred.bob.sammy"&gt;
      &lt;value&gt;123&lt;/value&gt;
   &lt;/property&gt;
 &lt;/bean&gt;</programlisting></para>

        <para>the foo bean has a <literal>fred</literal> property which has a
        <literal>bob</literal> property, which has a <literal>sammy</literal>
        property, and that final <literal>sammy</literal> property is being
        set to a scalar value of 123. In order for this to work, the
        <literal>fred</literal> property of <literal>foo</literal>, and the
        <literal>bob</literal> property of <literal>fred</literal> must both
        be non-null after the bean is constructed, or a null-pointer exception
        will be thrown.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-method-injection">
      <title>Method Injection</title>

      <para>For most users, the majority of the beans in the container will be
      singletons. When a singleton bean needs to collaborate with (use)
      another singleton bean, or a non-singleton bean needs to collaborate
      with another non-singleton bean, the typical and common approach of
      handling this dependency by defining one bean to be a property of the
      other, is quite adequate. There is however a problem when the bean
      lifecycles are different. Consider a singleton bean A which needs to use
      a non-singleton (prototype) bean B, perhaps on each method invocation on
      A. The container will only create the singleton bean A once, and thus
      only get the opportunity to set its properties once. There is no
      opportunity for the container to provide bean A with a new instance of
      bean B every time one is needed.</para>

      <para>One solution to this problem is to forgo some inversion of
      control. Bean A can be aware of the container (as described <link
      linkend="beans-factory-aware-beanfactoryaware">here</link>) by
      implementing<literal> BeanFactoryAware</literal>, and use programmatic
      means (as described <link linkend="beans-factory-client">here</link>) to
      ask the container via a <literal>getBean("B")</literal> call for (a new)
      bean B every time it needs it. This is generally not a desirable
      solution since the bean code is then aware of and coupled to
      Spring.</para>

      <para>Method Injection, an advanced feature of the BeanFactory, allows
      this use case to be handled in a clean fashion, along with some other
      scenarios.</para>

      <sect3>
        <title>Lookup method Injection</title>

        <para>Lookup method injection refers to the ability of the container
        to override abstract or concrete methods on managed beans in the
        container, to return the result of looking up another named bean in
        the container. The lookup will typically be of a non-singleton bean as
        per the scenario described above (although it can also be a
        singleton). Spring implements this through a dynamically generated
        subclass overriding the method, using bytecode generation via the
        CGLIB library.</para>

        <para>In the client class containing the method to be injected, the
        method definition must be an abstract (or concrete) definition in this
        form:</para>

        <para><programlisting>protected abstract SingleShotHelper createSingleShotHelper();</programlisting></para>

        <para>If the method is not abstract, Spring will simply override the
        existing implementation. In the XmlBeanFactory case, you instruct
        Spring to inject/override this method to return a particular bean from
        the container, by using the <literal>lookup-method</literal> element
        inside the bean definition. For example:<programlisting>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id="singleShotHelper class="..." singleton="false"&gt;
&lt;/bean&gt;

&lt;!-- myBean uses singleShotHelper --&gt;
&lt;bean id="myBean" class="..."&gt;
  &lt;lookup-method name="createSingleShotHelper"
                 bean="singleShotHelper"/&gt;
  &lt;property&gt;
    ...
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para>The bean identified as <emphasis>myBean</emphasis> will call its
        own method <literal>createSingleShotHelper</literal> whenever it needs
        a new instance of the <emphasis>singleShotHelper</emphasis> bean. It
        is important to note that the person deploying the beans must be
        careful to deploy <emphasis>singleShotHelper</emphasis> as a
        non-singleton (if that is actually what is needed). If it is deployed
        as a singleton (either explicitly, or relying on the default
        <emphasis>true</emphasis> setting for this flag), the same instance of
        singleShotHelper will be returned each time!</para>

        <para>Note that lookup method injection can be combined with
        Constructor Injection (supplying optional constructor arguments to the
        bean being constructed), and also with Setter Injection (settings
        properties on the bean being constructed).</para>
      </sect3>

      <sect3>
        <title>Arbitrary method replacement</title>

        <para>A less commonly useful form of method injection than Lookup
        Method Injection is the ability to replace arbitrary methods in a
        managed bean with another method implementation. Users may safely skip
        the rest of this section (which describes this somewhat advanced
        feature), until this functionality is actually needed.</para>

        <para>In an XmlBeanFactory, the <literal>replaced-method</literal>
        element may be used to replace an existing method implementation with
        another, for a deployed bean. Consider the following class, with a
        method computeValue, which we want to override:<programlisting>...
public class MyValueCalculator {
  public String computeValue(String input) {
    ... some real code
  }

  ... some other methods
}</programlisting></para>

        <para>A class implementing the
        <literal>org.springframework.beans.factory.support.MethodReplacer</literal>
        interface is needed to provide the new method
        definition.<programlisting>/** meant to be used to override the existing computeValue
    implementation in MyValueCalculator */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ... 
        return ...;
}</programlisting></para>

        <para>The BeanFactory deployment definition to deploy the original
        class and specify the method override would look like:<programlisting>&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplaceMentComputeValue"&gt;
&lt;/bean&gt;</programlisting>One or more contained
        <literal>arg-type</literal> elements within the
        <literal>replaced-method</literal> element may be used to indicate the
        method signature of the method being overridden. Note that the
        signature for the arguments is actually only needed in the case that
        the method is actually overloaded and there are multiple variants
        within the class. For convenience, the type string for an argument may
        be a substring of the fully qualified type name. For example, all the
        following would match
        <emphasis>java.lang.String</emphasis>.<programlisting>    java.lang.String
    String
    Str</programlisting>Since the number of arguments is often enough to
        distinguish between each possible choice, this shortcut can save a lot
        of typing, by just using the shortest string which will match an
        argument.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-dependson">
      <title>Using <literal>depends-on</literal></title>

      <para>For most situations, the fact that a bean is a dependency of
      another is expressed simply by the fact that one bean is set as a
      property of another. This is typically done with the
      <literal>ref</literal> element in the XmlBeanFactory. In a variation of
      this, sometimes a bean which is aware of the container is simply given
      the id of its dependency (using a string value or alternately the
      <literal>idref</literal> element, which evaluates the same as a string
      value). The first bean then programmatically asks the container for its
      dependency. In either case, the dependency is properly initialized
      before the dependent bean.</para>

      <para>For the relatively infrequent situations where dependencies
      between beans are less direct (for example, when a static initializer in
      a class needs to be triggered, such as database driver registration),
      the <literal>depends-on</literal> element may be used to explicitly
      force one or more beans to be initialized before the bean using this
      element is initialized.</para>

      <para>Following is an example configuration:<programlisting>&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"&gt;
    &lt;property name="manager"&gt;&lt;ref local="manager"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean"/&gt;</programlisting></para>
    </sect2>

    <sect2 id="beans-factory-autowire">
      <title>Autowiring collaborators</title>

      <para>A BeanFactory is able to <emphasis>autowire</emphasis>
      relationships between collaborating beans. This means it's possible to
      automatically let Spring resolve collaborators (other beans) for your
      bean by inspecting the contents of the BeanFactory. The autowiring
      functionality has five modes. Autowiring is specified
      <emphasis>per</emphasis> bean and can thus be enabled for some beans,
      while other beans won't be autowired. Using autowiring, it is possible
      to reduce or eliminate the need to specify properties or constructor
      arguments, saving a significant amount of typing.<footnote>
          <para>See <xref linkend="beans-factory-collaborators" /></para>
        </footnote>In an XmlBeanFactory, the autowire mode for a bean
      definition is specified by using the <literal>autowire</literal>
      attribute of the bean element. The following values are allowed.<table
          frame="all">
          <title>Autowiring modes</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="1*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Mode</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>no</entry>

                <entry>No autowiring at all. Bean references must be defined
                via a <literal>ref</literal> element. This is the default, and
                changing this is discouraged for larger deployments, since
                explicitly specifying collaborators gives greater control and
                clarity. To some extent, it is a form of documentation about
                the structure of a system.</entry>
              </row>

              <row>
                <entry>byName</entry>

                <entry>Autowiring by property name. This option will inspect
                the BeanFactory and look for a bean named exactly the same as
                the property which needs to be autowired. For example, if you
                have a bean definition which is set to autowire by name, and
                it contains a <emphasis>master</emphasis> property (that is,
                it has a <emphasis>setMaster</emphasis>(...) method), Spring
                will look for a bean definition named master, and use it to
                set the property.</entry>
              </row>

              <row>
                <entry>byType</entry>

                <entry>Allows a property to be autowired if there is exactly
                one bean of the property type in the BeanFactory. If there is
                more than one, a fatal exception is thrown, and this indicates
                that you may not use <emphasis>byType</emphasis> autowiring
                for that bean. If there are no matching beans, nothing
                happens; the property is not set. If this is not desirable,
                setting the <literal>dependency-check="objects"</literal>
                attribute value specifies that an error should be thrown in
                this case.</entry>
              </row>

              <row>
                <entry>constructor</entry>

                <entry>This is analogous to <emphasis>byType</emphasis>, but
                applies to constructor arguments. If there isn't exactly one
                bean of the constructor argument type in the bean factory, a
                fatal error is raised.</entry>
              </row>

              <row>
                <entry>autodetect</entry>

                <entry>Chooses <emphasis>constructor</emphasis> or
                <emphasis>byType</emphasis> through introspection of the bean
                class. If a default constructor is found, byType gets
                applied.</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Note that explicit dependencies in <literal>property</literal> and
      <literal>constructor-arg</literal> elements always override autowiring.
      Autowire behavior can be combined with dependency checking, which will
      be performed after all autowiring has been
      completed.<emphasis></emphasis></para>

      <para>It's important to understand the pros and cons around autowiring.
      Some advantages of autowiring:</para>

      <itemizedlist>
        <listitem>
          <para>It can significantly reduce the volume of configuration
          required. (However, mechanisms such as the use of a configuration
          "template," discussed elsewhere in this chapter, are also valuable
          here.)</para>
        </listitem>

        <listitem>
          <para>It can cause configuration to keep itself up to date as your
          objects evolve. For example, if you need to add an additional
          dependency to a class, that dependency can be satisfied
          automatically without the need to modify configuration. Thus there
          may be a strong case for autowiring during development, without
          ruling out the option of switching to explicit wiring when the code
          base becomes more stable.</para>
        </listitem>
      </itemizedlist>

      <para>Some disadvantages of autowiring:</para>

      <itemizedlist>
        <listitem>
          <para>It's more magical than explicit wiring. Although, as noted in
          the above table, Spring is careful to avoid guessing in case of
          ambiguity which might have unexpected results, the relationships
          between your Spring-managed objects is no longer explicitly
          documented.</para>
        </listitem>

        <listitem>
          <para>Wiring information may not be available to tools that may
          generate documentation from a Spring application context.</para>
        </listitem>

        <listitem>
          <para>Autowiring by type will only work when there is a single bean
          definition of the type specified by the setter method or constructor
          argument. You need to use explicit wiring if there is any potential
          ambiguity.</para>
        </listitem>
      </itemizedlist>

      <para>There is no "wrong" or "right" answer in all cases. We recommend a
      degree of consistency across a project. For example, if autowiring is
      not used in general, it might be confusing to developers to use it just
      to one or two bean definitions.</para>
    </sect2>

    <sect2 id="beans-factory-dependencies">
      <title>Checking for dependencies</title>

      <para>Spring has the ability to try to check for the existence of
      unresolved dependencies of a bean deployed into the BeanFactory. These
      are JavaBeans properties of the bean, which do not have actual values
      set for them in the bean definition, or alternately provided
      automatically by the autowiring feature.</para>

      <para>This feature is sometimes useful when you want to ensure that all
      properties (or all properties of a certain type) are set on a bean. Of
      course, in many cases a bean class will have default values for many
      properties, or some properties do not apply to all usage scenarios, so
      this feature is of limited use. Dependency checking can also be enabled
      and disabled per bean, just as with the autowiring functionality. The
      default is to <emphasis>not</emphasis> check dependencies. Dependency
      checking can be handled in several different modes. In an
      XmlBeanFactory, this is specified via the
      <literal>dependency-check</literal> attribute in a bean definition,
      which may have the following values.<table frame="all">
          <title>Dependency checking modes</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="1*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Mode</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>none</entry>

                <entry>No dependency checking. Properties of the bean which
                have no value specified for them are simply not set.</entry>
              </row>

              <row>
                <entry>simple</entry>

                <entry>Dependency checking is performed for primitive types
                and collections (everything except collaborators, i.e. other
                beans)</entry>
              </row>

              <row>
                <entry>object</entry>

                <entry>Dependency checking is performed for
                collaborators</entry>
              </row>

              <row>
                <entry>all</entry>

                <entry>Dependency checking is done for collaborators,
                primitive types and collections</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>
  </sect1>

  <sect1 id="beans-factory-nature">
    <title>Customizing the nature of a bean</title>

    <sect2 id="beans-factory-lifecycle">
      <title>Lifecycle interfaces</title>

      <para>Spring provides several marker interfaces to change the behavior
      of your bean in the BeanFactory. They include
      <literal>InitializingBean</literal> and
      <literal>DisposableBean</literal>. Implementing these interfaces will
      result in the BeanFactory calling
      <literal>afterPropertiesSet()</literal> for the former and
      <literal>destroy()</literal> for the latter to allow the bean to perform
      certain actions upon initialization and destruction.</para>

      <para>Internally, Spring uses <literal>BeanPostProcessors</literal> to
      process any marker interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <literal>BeanPostProcessor</literal> yourself. More information about
      this can be found in <xref
      linkend="beans-factory-customizing" />.</para>

      <para>All the different lifecycle marker interfaces are described below.
      In one of the appendices, you can find diagram that show how Spring
      manages beans and how those lifecycle features change the nature of your
      beans and how they are managed.</para>

      <sect3 id="beans-factory-lifecycle-initializingbean">
        <title>InitializingBean / <literal>init-method</literal></title>

        <para>Implementing the
        <literal>org.springframework.beans.factory.InitializingBean</literal>
        allows a bean to perform initialization work after all necessary
        properties on the bean are set by the BeanFactory. The
        InitializingBean interface specifies exactly one
        method:<programlisting>    * Invoked by a BeanFactory after it has set all bean properties supplied
    * (and satisfied BeanFactoryAware and ApplicationContextAware).
    * &lt;p&gt;This method allows the bean instance to perform initialization only
    * possible when all bean properties have been set and to throw an
    * exception in the event of misconfiguration.
    * @throws Exception in the event of misconfiguration (such
    * as failure to set an essential property) or if initialization fails.
    */
    void afterPropertiesSet() throws Exception;</programlisting></para>

        <para><emphasis>Note: generally, the use of the
        <literal>InitializingBean</literal> marker interface can be avoided
        (and is discouraged since it unnecessarily couples the code to
        Spring). A bean definition provides support for a generic
        initialization method to be specified. In the case of the
        XmlBeanFactory, this is done via the <literal>init-method</literal>
        attribute. For example, the following definition:</emphasis></para>

        <para><programlisting>&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;

public class ExampleBean {
    public void init() {
        // do some initialization work
    }
}</programlisting>Is exactly the same as: <programlisting>&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements InitializingBean {
    public void afterPropertiesSet() {
        // do some initialization work
    }
}</programlisting>but does not couple the code to Spring.</para>
      </sect3>

      <sect3 id="beans-factory-lifecycle-disposablebean">
        <title>DisposableBean / <literal>destroy-method</literal></title>

        <para>Implementing the
        <literal>org.springframework.beans.factory.DisposableBean</literal>
        interface allows a bean to get a callback when the BeanFactory
        containing it is destroyed. The DisposableBean interface specifies one
        method: <programlisting>    /**
    * Invoked by a BeanFactory on destruction of a singleton.
    * @throws Exception in case of shutdown errors.
    * Exceptions will get logged but not re-thrown to allow
    * other beans to release their resources too.
    */
    void destroy() throws Exception;
</programlisting></para>

        <para><emphasis>Note: generally, the use of the
        <literal>DisposableBean</literal> marker interface can be avoided (and
        is discouraged since it unnecessarily couples the code to Spring). A
        bean definition provides support for a generic destroy method to be
        specified. In the case of the XmlBeanFactory, this is done via the
        <literal>destroy-method</literal> attribute. For example, the
        following definition: </emphasis></para>

        <para><programlisting>&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;

public class ExampleBean {
    public void cleanup() {
        // do some destruction work (like closing connection)
    }
}</programlisting> Is exactly the same as: <programlisting>&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements DisposableBean {
    public void destroy() {
        // do some destruction work
    }
}</programlisting>but does not couple the code to Spring.</para>

        <para><emphasis>Important note: when deploying a bean in the prototype
        mode, the lifecycle of the bean changes slightly. By definition,
        Spring cannot manage the complete lifecycle of a
        non-singleton/prototype bean, since after it is created, it is given
        to the client and the container does not keep track of it at all any
        longer. You can think of Spring's role when talking about a
        non-singleton/prototype bean as a replacement for the 'new' operator.
        Any lifecycle aspects past that point have to be handled by the
        client. The lifecycle of a bean in the BeanFactory is further
        described in <xref
        linkend="beans-factory-lifecycle" /></emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-aware">
      <title>Knowing who you are</title>

      <sect3 id="beans-factory-aware-beanfactoryaware">
        <title>BeanFactoryAware</title>

        <para>A class which implements the
        <literal>org.springframework.beans.factory.BeanFactoryAware</literal>
        interface is provided with a reference to the BeanFactory that created
        it, when it is created by that BeanFactory.<programlisting>public interface BeanFactoryAware {
   /**
    * Callback that supplies the owning factory to a bean instance.
    * &lt;p&gt;Invoked after population of normal bean properties but before an init
    * callback like InitializingBean's afterPropertiesSet or a custom init-method.
    * @param beanFactory owning BeanFactory (may not be null).
    * The bean can immediately call methods on the factory.
    * @throws BeansException in case of initialization errors
    * @see BeanInitializationException
    */
    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</programlisting></para>

        <para>This allows beans to manipulate the BeanFactory that created
        them programmatically, through the
        <literal>org.springframework.beans.factory.BeanFactory</literal>
        interface, or by casting the reference to a known subclass of this
        which exposes additional functionality. Primarily this would consist
        of programmatic retrieval of other beans. While there are cases when
        this capability is useful, it should generally be avoided, since it
        couples the code to Spring, and does not follow the Inversion of
        Control style, where collaborators are provided to beans as
        properties.</para>
      </sect3>

      <sect3 id="beans-factory-aware-beannameaware">
        <title>BeanNameAware</title>

        <para>If a bean implements the
        <literal>org.springframework.beans.factory.BeanNameAware</literal>
        interface and is deployed in a BeanFactory, the BeanFactory will call
        the bean through this interface to inform the bean of the
        <emphasis>id</emphasis> it was deployed under. The callback will be
        Invoked after population of normal bean properties but before an init
        callback like <literal>InitializingBean</literal>'s
        <emphasis>afterPropertiesSet</emphasis> or a custom
        init-method.</para>
      </sect3>
    </sect2>

    <sect2 id="beans-factory-lifecycle-factorybean">
      <title>FactoryBean</title>

      <para>The
      <literal>org.springframework.beans.factory.FactoryBean</literal>
      interface is to be implemented by objects that <emphasis>are themselves
      factories</emphasis>. The BeanFactory interface provides three method:
      <itemizedlist spacing="compact">
          <listitem>
            <para><literal>Object getObject()</literal>: has to return an
            instance of the object this factory creates. The instance can
            possibly be shared (depending on whether this factory returns
            singletons or prototypes).</para>
          </listitem>

          <listitem>
            <para><literal>boolean isSingleton()</literal>: has to return
            <emphasis>true</emphasis> if this FactoryBean returns singletons,
            <emphasis>false</emphasis> otherwise</para>
          </listitem>

          <listitem>
            <para><literal>Class getObjectType()</literal>: has to return
            either the object type returned by the
            <literal>getObject()</literal> method or <literal>null</literal>
            if the type isn't known in advance</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
  </sect1>

  <sect1 id="beans-child-bean-definitions">
    <title>Abstract and child bean definitions</title>

    <para>A bean definition potentially contains a large amount of
    configuration information, including container specific information (i.e.
    initialization method, static factory method name, etc.) and constructor
    arguments and property values. A child bean definition is a bean
    definition which inherits configuration data from a parent definition. It
    is then able to override some values, or add others, as needed. Using
    parent and child bean definitions can potentially save a lot of typing.
    Effectively, this is a form of templating.</para>

    <para>When working with a BeanFactory programmatically, child bean
    definitions are represented by the <literal>ChildBeanDefinition</literal>
    class. Most users will never work with them on this level, instead
    configuring bean definitions declaratively in something like the
    XmlBeanFactory. In an XmlBeanFactory bean definition, a child bean
    definition is indicated simply by using the <literal>parent</literal>
    attribute, specifying the parent bean as the value of this
    attribute.<programlisting>&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
    &lt;property name="name"&gt;&lt;value&gt;parent&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean"
      parent="inheritedTestBean" init-method="initialize"&gt;
    &lt;property name="name"&gt;&lt;value&gt;override&lt;/value&gt;&lt;/property&gt;
    &lt;!-- age should inherit value of 1 from parent --&gt;
  &lt;/bean&gt;</programlisting></para>

    <para>A child bean definition will use the bean class from the parent
    definition if none is specified, but can also override it. In the latter
    case, the child bean class must be compatible with the parent, i.e. it
    must accept the parent's property values.</para>

    <para>A child bean definition will inherit constructor argument values,
    property values and method overrides from the parent, with the option to
    add new values. If init method, destroy method and/or static factory
    method are specified, they will override the corresponding parent
    settings.</para>

    <para>The remaining settings will <emphasis>always</emphasis> be taken
    from the child definition: <emphasis>depends on</emphasis>,
    <emphasis>autowire mode</emphasis>, <emphasis>dependency check</emphasis>,
    <emphasis>singleton</emphasis>, <emphasis>lazy init</emphasis>.</para>

    <para>Note that in the example above, we have explicitly marked the parent
    bean definition as <emphasis>abstract</emphasis> by using the
    <emphasis>abstract</emphasis> attribute. In the case that the parent
    definition does not specify a class:<programlisting>&lt;bean id="inheritedTestBeanWithoutClass"&gt;
    &lt;property name="name"&gt;&lt;value&gt;parent&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
      parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
    &lt;property name="name"&gt;&lt;value&gt;override&lt;/value&gt;&lt;/property&gt;
    &lt;!-- age should inherit value of 1 from parent --&gt;
&lt;/bean&gt;</programlisting></para>

    <para>the parent bean cannot get instantiated on its own since it is
    incomplete, and it's also considered abstract. When a definition is
    considered abstract like this (explicitly or implicitly), it's usable just
    as a pure template or abstract bean definition that will serve as parent
    definition for child definitions. Trying to use such an abstract parent
    bean on its own (by referring to it as a ref property of another bean, or
    doing an explicit getBean() call with the parent bean id, will result in
    an error. Similarly, the container's internal
    <emphasis>preInstantiateSingletons</emphasis> method will completely
    ignore bean definitions which are considered abstract.</para>

    <para><emphasis>Important Note</emphasis>: Application contexts (but not
    simple bean factories) will by default pre-instantiate all singletons.
    Therefore it is important (at least for singleton beans) that if you have
    a (parent) bean definition which you intend to use only as a template, and
    this definition specifies a class, you must make sure to set the
    <emphasis>abstract</emphasis> attribute to <emphasis>true</emphasis>,
    otherwise the application context will actually pre-instantiate it.</para>
  </sect1>

  <sect1 id="beans-factory-client">
    <title>Interacting with the BeanFactory</title>

    <para>A BeanFactory is essentially nothing more than the interface for an
    advanced factory capable of maintaining a registry of different beans and
    their dependencies. The BeanFactory enables you to read bean definitions
    and access them using the bean factory. When using just the BeanFactory
    you would create one and read in some bean definitions in the XML format
    as follows: <programlisting>InputStream is = new FileInputStream("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);</programlisting></para>

    <para>Basically that's all there is to it. Using
    <literal>getBean(String)</literal> you can retrieve instances of your
    beans. You'll get a reference to the same bean if you defined it as a
    singleton (the default) or you'll get a new instance each time if you set
    <literal>singleton</literal> to <emphasis>false</emphasis>. The
    client-side view of the BeanFactory is surprisingly simple. The
    <literal>BeanFactory</literal> interface has only five methods for clients
    to call: <itemizedlist spacing="compact">
        <listitem>
          <para><literal>boolean containsBean(String)</literal>: returns true
          if the BeanFactory contains a bean definition or bean instance that
          matches the given name</para>
        </listitem>

        <listitem>
          <para><literal>Object getBean(String)</literal>: returns an instance
          of the bean registered under the given name. Depending on how the
          bean was configured by the BeanFactory configuration, either a
          singleton and thus shared instance or a newly created bean will be
          returned. A <literal>BeansException</literal> will be thrown when
          either the bean could not be found (in which case it'll be a
          <literal>NoSuchBeanDefinitionException</literal>), or an exception
          occurred while instantiating and preparing the bean</para>
        </listitem>

        <listitem>
          <para><literal>Object getBean(String,Class)</literal>: returns a
          bean, registered under the given name. The bean returned will be
          cast to the given Class. If the bean could not be cast,
          corresponding exceptions will be thrown
          (<literal>BeanNotOfRequiredTypeException</literal>). Furthermore,
          all rules of the getBean(String) method apply (see above)</para>
        </listitem>

        <listitem>
          <para><literal>boolean isSingleton(String)</literal>: determines
          whether or not the bean definition or bean instance registered under
          the given name is a singleton or a prototype. If no bean
          corresponding to the given name could not be found, an exception
          will be thrown
          (<literal>NoSuchBeanDefinitionException</literal>)</para>
        </listitem>

        <listitem>
          <para><literal>String[] getAliases(String)</literal>: Return the
          aliases for the given bean name, if any were defined in the bean
          definition</para>
        </listitem>
      </itemizedlist></para>

    <sect2>
      <title>Obtaining a FactoryBean, not its product</title>

      <para>Sometimes there is a need to ask a BeanFactory for an actual
      FactoryBean instance itself, not the bean it produces. This may be done
      by prepending the bean id with <literal>&amp;</literal> when calling the
      <methodname>getBean</methodname> method of BeanFactory (including
      ApplicationContext). So for a given FactoryBean with an id
      <literal>myBean</literal>, invoking <literal>getBean("myBean")</literal>
      on the BeanFactory will return the product of the FactoryBean, but
      invoking <literal>getBean("&amp;myBean")</literal> will return the
      FactoryBean instance itself.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-factory-customizing">
    <title>Customizing beans with BeanPostprocessors</title>

    <para>A bean post-processor is a java class which implements the
    <literal>org.springframework.beans.factory.config.BeanPostProcessor</literal>
    interface, which consists of two callback methods. When such a class is
    registered as a post-processor with the BeanFactory, for each bean
    instance that is created by the BeanFactory, the post-processor will get a
    callback from the BeanFactory before any initialization methods
    (<emphasis>afterPropertiesSet</emphasis> and any declared init method) are
    called, and also afterwords. The post-processor is free to do what it
    wishes with the bean, including ignoring the callback completely. A bean
    post-processor will typically check for marker interfaces, or do something
    such as wrap a bean with a proxy. Some Spring helper classes are
    implemented as bean post-processors.</para>

    <para>It is important to know that a BeanFactory treats bean
    post-processors slightly differently than an ApplicationContext. An
    ApplicationContext will automatically detect any beans which are deployed
    into it which implement the <literal>BeanPostProcessor</literal>
    interface, and register them as post-processors, to be then called
    appropriately by the factory on bean creation. Nothing else needs to be
    done other than deploying the post-processor in a similar fashion to any
    other bean. On the other hand, when using plain BeanFactories, bean
    post-processors have to manually be <emphasis>explicitly</emphasis>
    registered, with a code sequence such as the following:<programlisting>ConfigurableBeanFactory bf = new .....;     // create BeanFactory
   ...                       // now register some beans
// now register any needed BeanPostProcessors
MyBeanPostProcessor pp = new MyBeanPostProcessor();
bf.addBeanPostProcessor(pp);

// now start using the factory
  ...</programlisting></para>

    <para>Since this manual registration step is not convenient, and
    ApplictionContexts are functionally supersets of BeanFactories, it is
    generally recommended that ApplicationContext variants are used when bean
    post-processors are needed.</para>
  </sect1>

  <sect1 id="beans-factory-customizing-factory-postprocessors">
    <title>Customizing bean factories with BeanFactoryPostprocessors</title>

    <para>A bean factory post-processor is a java class which implements the
    <literal>org.springframework.beans.factory.config.BeanFactoryPostProcessor</literal>
    interface. It is executed manually (in the case of the BeanFactory) or
    automatically (in the case of the ApplicationContext) to apply changes of
    some sort to an entire BeanFactory, after it has been constructed. Spring
    includes a number of pre-existing bean factory post-processors, such as
    <literal>PropertyResourceConfigurer</literal> and
    <literal>PropertyPlaceHolderConfigurer</literal>, both described below,
    and <literal>BeanNameAutoProxyCreator</literal>, very useful for wrapping
    other beans transactionally or with any other kind of proxy, as described
    later in this manual. The BeanFactoryPostProcessor can be used to add
    custom editors (as also mentioned in <xref
    linkend="beans-beanfactory-customeditors" />).</para>

    <para>In a BeanFactory, the process of applying a BeanFactoryPostProcessor
    is manual, and will be similar to this:</para>

    <para><programlisting>XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
// create placeholderconfigurer to bring in some property
// values from a Properties file
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
// now actually do the replacement
cfg.postProcessBeanFactory(factory);</programlisting></para>

    <para><anchor id="beans-factory-autodetect-beanfactorypostprocessors" />An
    ApplicationContext will detect any beans which are deployed into it which
    implement the <literal>BeanFactoryPostProcessor</literal> interface, and
    automatically use them as bean factory post-processors, at the appropriate
    time. Nothing else needs to be done other than deploying these
    post-processor in a similar fashion to any other bean.</para>

    <para>Since this manual step is not convenient, and ApplictionContexts are
    functionally supersets of BeanFactories, it is generally recommended that
    ApplicationContext variants are used when bean factory post-processors are
    needed.</para>

    <sect2 id="beans-factory-placeholderconfigurer">
      <title>The <literal>PropertyPlaceholderConfigurer</literal></title>

      <para>The <literal>PropertyPlaceholderConfigurer</literal>, implemented
      as a bean factory post-processor, is used to externalize some property
      values from a BeanFactory definition, into another separate file in Java
      Properties format. This is useful to allow the person deploying an
      application to customize some key properties (for example database URLs,
      usernames and passwords), without the complexity or risk of modifying
      the main XML definition file or files for the BeanFactory.</para>

      <para>Consider a fragment from a BeanFactory definition, where a
      DataSource with placeholder values is defined:</para>

      <para>In the example below, a datasource is defined, and we will
      configure some properties from an external Properties file. At runtime,
      we will apply a <literal>PropertyPlaceholderConfigurer</literal> to the
      BeanFactory which will replace some properties of the datasource:</para>

      <programlisting>&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName"&gt;&lt;value&gt;${jdbc.driverClassName}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="url"&gt;&lt;value&gt;${jdbc.url}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="username"&gt;&lt;value&gt;${jdbc.username}&lt;/value&gt;&lt;/property&gt;
    &lt;property name="password"&gt;&lt;value&gt;${jdbc.password}&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>The actual values come from another file in Properties
      format:</para>

      <programlisting>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</programlisting>

      <para>To use this with a BeanFactory, the bean factory post-processor is
      manually executed on it:</para>

      <programlisting>XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
cfg.postProcessBeanFactory(factory);</programlisting>

      <para>Note that ApplicationContexts are able to automatically recognize
      and apply beans deployed in them which implement
      BeanFactoryPostProcessor. This means that as described here, applying
      PropertyPlaceholderConfiguer is much more convenient when using an
      ApplicationContext. For this reason, it is recommended that users
      wishing to use this or other bean factory postprocessors use an
      ApplicationContext instead of a BeanFactory.</para>

      <para>The <literal>PropertyPlaceHolderConfigurer</literal> doesn't only
      look for properties in the Properties file you specify, but also checks
      against the Java System properties if it cannot find a property you are
      trying to use. This behavior can be customized by setting the
      <literal>systemPropertiesMode</literal> property of the configurer. It
      has three values, one to tell the configurer to always override, one to
      let it <emphasis>never</emphasis> override and one to let it override
      only if the property cannot be found in the properties file specified.
      Please consult the JavaDoc for the PropertiesPlaceholderConfigurer for
      more information.</para>
    </sect2>

    <sect2 id="beans-factory-overrideconfigurer">
      <title>The <literal>PropertyOverrideConfigurer</literal></title>

      <para>The <literal>PropertyOverrideConfigurer</literal>, another bean
      factory post-processor, is similar to the
      <literal>PropertyPlaceholderConfigurer</literal>, but in contrast to the
      latter, the original definitions can have default values or no values at
      all for bean properties. If an overriding Properties file does not have
      an entry for a certain bean property, the default context definition is
      used.</para>

      <para>Note that the bean factory definition is <emphasis>not</emphasis>
      aware of being overridden, so it is not immediately obvious when looking
      at the XML definition file that the override configurer is being used.
      In case that there are multiple PropertyOverrideConfigurers that define
      different values for the same bean property, the last one will win (due
      to the overriding mechanism).</para>

      <para>Properties file configuration lines are expected to be in the
      format:<programlisting><emphasis>beanName.property=value</emphasis></programlisting></para>

      <para>An example properties file could look like:<programlisting>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</programlisting></para>

      <para>This example file would be usable against a BeanFactory definition
      which contains a bean in it called <emphasis>dataSource</emphasis>,
      which has <emphasis>driver</emphasis> and <emphasis>url</emphasis>
      properties.</para>

      <para>Note that compound property names are also supported, as long as
      every component of the path except the final property being overriden is
      already non-null (presumably initialized by the constructors). In this
      example:</para>

      <para><programlisting>foo.fred.bob.sammy=123</programlisting>the
      <literal>sammy</literal> property of the <literal>bob</literal> property
      of the <literal>fred</literal> property of the <literal>foo</literal>
      bean is being set to the scalar value 123.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-beanfactory-customeditors">
    <title>Registering additional custom PropertyEditors</title>

    <para>When setting bean properties as a string value, a BeanFactory
    ultimately uses standard JavaBeans PropertyEditors to convert these
    Strings to the complex type of the property. Spring pre-registers a number
    of custom PropertyEditors (for example, to convert a classname expressed
    as a string into a real Class object). Additionally, Java's standard
    JavaBeans PropertyEditor lookup mechanism allows a PropertyEditor for a
    class to be simply named appropriately and placed in the same package as
    the class it provides support for, to be found automatically.</para>

    <para>If there is a need to register other custom PropertyEditors, there
    are several mechanisms available.</para>

    <para>The most manual approach, which is not normally convenient or
    recommended, is to simply use the
    <literal>registerCustomEditor()</literal> method of the
    <literal>ConfigurableBeanFactory</literal> interface, assuming you have a
    BeanFactory reference.</para>

    <para>The more convenient mechanism is to use a special bean factory
    post-processor called <literal>CustomEditorConfigurer</literal>. Although
    bean factory post-processors can be used semi-manually with BeanFactories,
    this one has a nested property setup, so it is strongly recommended that,
    as described <link
    linkend="beans-applicationcontext-customeditors">here</link>, it is used
    with the ApplicationContext, where it may be deployed in similar fashion
    to any other bean, and automatically detected and applied.</para>

    <para>Note that all bean factories and application contexts automatically
    use a number of built-in property editors, through their use of something
    called a <literal>BeanWrapper</literal> to handle property conversions.
    The standard property editors that the BeanWrapper registers are listed in
    the next chapter. Additionally, ApplicationContexts also override or add
    an additional 3 editors to handle resource lookups in a manner appropriate
    to the specific application context type. Thee are:
    <literal>InputStreamEditor</literal>, <literal>ResourceEditor</literal>
    and <literal>URLEditor</literal>.</para>
  </sect1>

  <sect1 id="beans-beanfactory-alias">
    <title>Using the alias element to add aliases for existing beans</title>

    <para>In a bean definition itself, you may supply more than one name for
    the bean, by using a combination of up to one name spcified via the
    <literal>id</literal> attribute, and any number of other names via the
    <literal>alias</literal> attribute. All these names can be considered
    equivalent aliases to the same bean, and are useful for some situations,
    such as allowing each component used in an application to refer to a
    common dependency using a bean name that is specific to that component
    itslef.</para>

    <para>Having to specify all alias when the bean is actually defined is not
    always adequate however. It is sometimes desirable to introduce an alias
    for a bean which is define elsewhere. This may be done via a standalone
    <literal>alias</literal> element.</para>

    <para><literal> &lt;alias name="fromName"
    alias="toName"/&gt;</literal></para>

    <para>In this case, a bean in the same context which is named
    <literal>fromName</literal>, may also after the use of this alias
    definition, be referred to as <literal>toName</literal>.</para>

    <para>As a concrete example, consider the case where component A defines a
    DataSource bean called componentA-dataSource, in its XML fragment.
    Component B would however like to refer to the DataSource as
    componentB-dataSource in its XML fragment. And the main application,
    MyApp, defines its own XML fragment and assembles the final application
    context from all three fragments, and would like to refer to the
    DataSource as myApp-dataSource. This scenario can be easily handled by
    adding to the MyApp XML fragement the following standalone aliases:</para>

    <para><literal> </literal><literal>&lt;alias name="componentA-dataSource"
    alias="componentB-dataSource"/&gt; &lt;alias name="componentA-dataSource"
    alias="myApp-dataSource"/&gt;</literal></para>

    <para>Now each component and the main app can refer to the dataSource via
    a name that is unique and guaranteed not to clash with any other
    definition (effectively there is a namespace), yet they refer to the same
    bean.</para>
  </sect1>

  <sect1 id="context-introduction">
    <title>Introduction to the <literal>ApplicationContext</literal></title>

    <para>While the <literal>beans</literal> package provides basic
    functionality for managing and manipulating beans, often in a programmatic
    way, the <literal>context</literal> package adds <literal><ulink
    url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html">ApplicationContext</ulink></literal>,
    which enhances BeanFactory functionality in a more
    <emphasis>framework-oriented style</emphasis>. Many users will use
    ApplicationContext in a completely declarative fashion, not even having to
    create it manually, but instead relying on support classes such as
    ContextLoader to automatically start an ApplicationContext as part of the
    normal startup process of a J2EE web-app. Of course, it is still possible
    to programmatically create an ApplicationContext.</para>

    <para>The basis for the context package is the
    <literal>ApplicationContext</literal> interface, located in the
    <literal>org.springframework.context</literal> package. Deriving from the
    BeanFactory interface, it provides all the functionality of BeanFactory.
    To allow working in a more framework-oriented fashion, using layering and
    hierarchical contexts, the context package also provides the following:
    <itemizedlist spacing="compact">
        <listitem>
          <para><emphasis>MessageSource</emphasis>, providing access to
          messages in, i18n-style</para>
        </listitem>

        <listitem>
          <para><emphasis>Access to resources</emphasis>, such as URLs and
          files</para>
        </listitem>

        <listitem>
          <para><emphasis>Event propagation</emphasis> to beans implementing
          the <literal>ApplicationListener</literal> interface</para>
        </listitem>

        <listitem>
          <para><emphasis>Loading of multiple (hierarchical)
          contexts</emphasis>, allowing each to be focused on one particular
          layer, for example the web layer of an application</para>
        </listitem>
      </itemizedlist></para>

    <para>As the ApplicationContext includes all functionality of the
    BeanFactory, it is generally recommended that it be used over the
    BeanFactory, except for a few limited situations such as perhaps in an
    Applet, where memory consumption might be critical, and a few extra
    kilobytes might make a difference. The following sections described
    functionality which ApplicationContext adds to basic BeanFactory
    capabilities.</para>
  </sect1>

  <sect1 id="context-functionality">
    <title>Added functionality of the
    <literal>ApplicationContext</literal></title>

    <para>As already stated in the previous section, the ApplicationContext
    has a couple of features that distinguish it from the BeanFactory. Let us
    review them one-by-one.</para>

    <sect2 id="context-functionality-messagesource">
      <title>Using the <literal>MessageSource</literal></title>

      <para>The ApplicationContext interface extends an interface called
      <literal>MessageSource</literal>, and therefore provides messaging (i18n
      or internationalization) functionality. Together with the
      <literal>NestingMessageSource</literal>, capable of resolving
      hierarchical messages, these are the basic interfaces Spring provides to
      do message resolution. Let's quickly review the methods defined there:
      <itemizedlist spacing="compact">
          <listitem>
            <para><literal>String getMessage (String code, Object[] args,
            String default, Locale loc)</literal>: the basic method used to
            retrieve a message from the MessageSource. When no message is
            found for the specified locale, the default message is used. Any
            arguments passed in are used as replacement values, using the
            <literal>MessageFormat</literal> functionality provided by the
            standard library.</para>
          </listitem>

          <listitem>
            <para><literal>String getMessage (String code, Object[] args,
            Locale loc)</literal>: essentially the same as the previous
            method, but with one difference: no default message can be
            specified; if the message cannot be found, a
            <literal>NoSuchMessageException</literal> is thrown.</para>
          </listitem>

          <listitem>
            <para><literal>String getMessage(MessageSourceResolvable
            resolvable, Locale locale)</literal>: all properties used in the
            methods above are also wrapped in a class named
            <literal>MessageSourceResolvable</literal>, which you can use via
            this method.</para>
          </listitem>
        </itemizedlist></para>

      <para>When an ApplicationContext gets loaded, it automatically searches
      for a MessageSource bean defined in the context. The bean has to have
      the name <literal>messageSource</literal>. If such a bean is found, all
      calls to the methods described above will be delegated to the message
      source that was found. If no message source was found, the
      ApplicationContext attempts to see if it has a parent containing a bean
      with the same name. If so, it uses that bean as the MessageSource. If it
      can't find any source for messages, an empty
      <literal>StaticMessageSource</literal> will be instantiated in order to
      be able to accept calls to the methods defined above.</para>

      <para>Spring currently provides two <literal>MessageSource</literal>
      implementations. These are the
      <literal>ResourceBundleMessageSource</literal> and the
      <literal>StaticMessageSource</literal>. Both implement
      <literal>NestingMessageSource</literal> in order to do nested messaging.
      The StaticMessageSource is hardly ever used but provides programmatic
      ways to add messages to the source. The ResourceBundleMessageSource is
      more interesting and is the one we will provides an example for:
      <programlisting>&lt;beans&gt;
    &lt;bean id="messageSource" 
            class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;format&lt;/value&gt;
                &lt;value&gt;exceptions&lt;/value&gt;
                &lt;value&gt;windows&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt; </programlisting></para>

      <para>This assumes you have three resource bundles defined on your
      classpath called <literal>format</literal>,
      <literal>exceptions</literal> and <literal>windows</literal>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. TODO: SHOW AN
      EXAMPLE</para>
    </sect2>

    <sect2 id="context-functionality-events">
      <title>Propagating events</title>

      <para>Event handling in the ApplicationContext is provided through the
      <literal>ApplicationEvent</literal> class and
      <literal>ApplicationListener</literal> interface. If a bean which
      implements the <literal>ApplicationListener</literal> interface is
      deployed into the context, every time an
      <literal>ApplicationEvent</literal> gets published to the
      ApplicationContext, that bean will be notified. Essentially, this is the
      standard <emphasis>Observer</emphasis> design pattern. Spring provides
      three standard events: <table frame="all">
          <title>Built-in Events</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="2*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Event</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>ContextRefreshedEvent</literal></entry>

                <entry>Event published when the ApplicationContext is
                initialized or refreshed. Initialized here means that all
                beans are loaded, singletons are pre-instantiated and the
                ApplicationContext is ready for use</entry>
              </row>

              <row>
                <entry><literal>ContextClosedEvent</literal></entry>

                <entry>Event published when the ApplicationContext is closed,
                using the <literal>close()</literal> method on the
                ApplicationContext. Closed here means that singletons are
                destroyed</entry>
              </row>

              <row>
                <entry><literal>RequestHandledEvent</literal></entry>

                <entry>A web-specific event telling all beans that a HTTP
                request has been serviced (i.e. this will be published
                <emphasis>after</emphasis> the request has been finished).
                Note that this event is only applicable for web applications
                using Spring's DispatcherServlet</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>Implementing custom events can be done as well. Simply call the
      <literal>publishEvent()</literal> method on the ApplicationContext,
      specifying a parameter which is an instance of your custom event class
      implementing ApplicationEvent. Event listeners receive events
      synchronously. This means the publishEvent() method blocks until all
      listeners have finished processing the event. Furthermore, when a
      listener receives an event it operates inside the transaction context of
      the publisher, if a transaction context is available.</para>

      <para>Let's look at an example. First, the ApplicationContext:
      <programlisting>&lt;bean id="emailer" class="example.EmailBean"&gt;
    &lt;property name="blackList"&gt;
        &lt;list&gt;
            &lt;value&gt;black@list.org&lt;/value&gt;
            &lt;value&gt;white@list.org&lt;/value&gt;
            &lt;value&gt;john@doe.org&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListListener" class="example.BlackListNotifier"&gt;
    &lt;property name="notificationAddress"&gt;
        &lt;value&gt;spam@list.org&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>and then, the actual beans: <programlisting>public class EmailBean implements ApplicationContextAware {

    /** the blacklist */
    private List blackList;
    
    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }
    
    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }
    
    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent evt = new BlackListEvent(address, text);
            ctx.publishEvent(evt);
            return;
        }
        // send email
    }
}

public class BlackListNotifier implement ApplicationListener {

    /** notification address */
    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent evt) {
        if (evt instanceof BlackListEvent) {
            // notify appropriate person
        }
    }
}</programlisting>Of course, this particular example could probably be
      implemented in better ways (perhaps by using AOP features), but it
      should be sufficient to illustrate the basic event mechanism.</para>
    </sect2>

    <sect2 id="context-functionality-resources">
      <title>Using resources within Spring</title>

      <para>Many applications need to access resources. Resources could
      include files, but also things like web pages or NNTP newsfeeds. Spring
      provides a clean and transparent way of accessing resources in a
      protocol independent way. The ApplicationContext interface includes a
      method (<literal>getResource(String)</literal>) to take care of
      this.</para>

      <para>The Resource class defines a couple of methods that are shared
      across all Resource implementations: <table frame="all">
          <title>Resource functionality</title>

          <tgroup cols="2">
            <colspec colname="c1" colwidth="2*" />

            <colspec colname="c2" colwidth="5*" />

            <thead>
              <row>
                <entry>Method</entry>

                <entry>Explanation</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>getInputStream()</literal></entry>

                <entry>Opens an InputStream on the resource and returns
                it</entry>
              </row>

              <row>
                <entry><literal>exists()</literal></entry>

                <entry>Checks if the resource exists, returning false if it
                doesn't</entry>
              </row>

              <row>
                <entry><literal>isOpen()</literal></entry>

                <entry>Will return true is multiple streams cannot be opened
                for this resource. This will be false for some resources, but
                file-based resources for instance, cannot be read multiple
                times concurrently</entry>
              </row>

              <row>
                <entry><literal>getDescription()</literal></entry>

                <entry>Returns a description of the resource, often the fully
                qualified file name or the actual URL</entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>

      <para>A couple of Resource implementations are provided by Spring. They
      all need a String representing the actual location of the resource.
      Based upon that String, Spring will automatically choose the right
      Resource implementation for you. When asking an ApplicationContext for a
      resource first of all Spring will inspect the resource location you're
      specifying and look for any prefixes. Depending on the implementation of
      the ApplicationContext more or less Resource implementations are
      available. Resources can best be configured by using the ResourceEditor
      and for example the XmlBeanFactory.</para>
    </sect2>
  </sect1>

  <sect1 id="beans-context-customization">
    <title>Customized behavior in the ApplicationContext</title>

    <para>The BeanFactory already offers a number of mechanisms to control the
    lifecycle of beans deployed in it (such as marker interfaces like
    <literal>InitializingBean</literal> or <literal>DisposableBean</literal>,
    their configuration only equivalents such as the
    <literal>init-method</literal> and <literal>destroy-method</literal>
    attributes in an XmlBeanFactory config, and bean post-processors. In an
    ApplicationContext, all of these still work, but additional mechanisms are
    added for customizing behavior of beans and the container.</para>

    <sect2 id="beans-context-applicationcontextaware">
      <title><literal>ApplicationContextAware</literal> marker
      interface</title>

      <para>All marker interfaces available with BeanFactories still work. The
      ApplicationContext does add one extra marker interface which beans may
      implement,
      <literal>org.springframework.context.ApplicationContextAware</literal>.
      A bean which implements this interface and is deployed into the context
      will be called back on creation of the bean, using the interface's
      <literal>setApplicationContext()</literal> method, and provided with a
      reference to the context, which may be stored for later interaction with
      the context.</para>
    </sect2>

    <sect2 id="beans-context-beanpostprocessor">
      <title>The <literal>BeanPostProcessor</literal></title>

      <para>Bean post-processors, java classes which implement the
      <literal>org.springframework.beans.factory.config.BeanPostProcessor</literal>
      interface, have <link linkend="beans-factory-customizing">already</link>
      been mentioned. It is worth mentioning again here though, that
      post-processors are much more convenient to use in ApplicationContexts
      than in plain BeanFactories. In an ApplicationContext, any deployed bean
      which implements the above marker interface is automatically detected
      and registered as a bean post-processor, to be called appropriately at
      creation time for each bean in the factory.</para>
    </sect2>

    <sect2 id="beans-context-beanfactorypostprocessor">
      <title>The <literal>BeanFactoryPostProcessor</literal></title>

      <para>Bean factory post-processors, java classes which implement the
      <literal>org.springframework.beans.factory.config.BeanFactoryPostProcessor</literal>
      interface, have <link
      linkend="beans-factory-customizing-factory-postprocessors">already</link>
      been mentioned. It is worth mentioning again here though, that bean
      factory post-processors are much more convenient to use in
      ApplicationContexts than in plain BeanFactories. In an
      ApplicationContext, any deployed bean which implements the above marker
      interface is automatically detected as a bean factory post-processor, to
      be called at the appropriate time.</para>
    </sect2>

    <sect2 id="beans-context-placeholderconfigurer">
      <title>The <literal>PropertyPlaceholderConfigurer</literal></title>

      <para>The <literal>PropertyPlaceholderConfigurer</literal> has <link
      linkend="beans-factory-placeholderconfigurer">already</link> been
      described, as used with a BeanFactory. It is worth mentioning here
      though, that it is generally more convenient to use it with an
      ApplicationContext, since the context will automatically recognize and
      apply any bean factory post-processors, such as this one, when they are
      simply deployed into it like any other bean. There is no need for a
      manual step to execute it.</para>

      <programlisting>&lt;!-- property placeholder post-processor --&gt;
&lt;bean id="placeholderConfig"
      class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="location"&gt;&lt;value&gt;jdbc.properties&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>
    </sect2>
  </sect1>

  <sect1 id="beans-applicationcontext-customeditors">
    <title>Registering additional custom PropertyEditors</title>

    <para>As <link linkend="beans-beanfactory-customeditors">previously</link>
    mentioned, standard JavaBeans PropertyEditors are used to convert property
    values expressed as strings to the actual complex type of the property.
    <literal>CustomEditorConfigurer</literal>, a bean factory post-processor,
    may be used to conveniently add support for additional PropertyEditors to
    an ApplicationContext.</para>

    <para>Consider a user class <emphasis>ExoticType</emphasis>, and another
    class <emphasis>DependsOnExoticType</emphasis> which needs ExoticType set
    as a property:<programlisting>public class ExoticType {
    private String name;
    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {    
    private ExoticType type;
    public void setType(ExoticType type) {
        this.type = type;
    }
}</programlisting>When things are properly set up, we want to be able to
    assign the type property as a string, which a PropertyEditor will behind
    the scenes convert into a real ExoticType object.: <programlisting>&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type"&gt;&lt;value&gt;aNameForExoticType&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>The PropertyEditor could look similar to this:
    <programlisting>// converts string representation to ExoticType object
public class ExoticTypeEditor extends PropertyEditorSupport {

    private String format;

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setAsText(String text) {
        if (format != null &amp;&amp; format.equals("upperCase")) {
            text = text.toUpperCase();
        }
        ExoticType type = new ExoticType(text);
        setValue(type);
    }
}</programlisting>Finally, we use <literal>CustomEditorConfigurer</literal> to
    register the new PropertyEditor with the ApplicationContext, which will
    then be able to use it as needed.: <programlisting>&lt;bean id="customEditorConfigurer" 
    class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="customEditors"&gt;
        &lt;map&gt;
            &lt;entry key="example.ExoticType"&gt;
                &lt;bean class="example.ExoticTypeEditor"&gt;
                    &lt;property name="format"&gt;
                        &lt;value&gt;upperCase&lt;/value&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
  </sect1>

  <sect1>
    <title>Setting a bean property or constructor arg from a property
    expression</title>

    <para><literal>PropertyPathFactoryBean</literal> is a
    <literal>FactoryBean</literal> that evaluates a property path on a given
    target object. The target object can be specified directly or via a bean
    name. This value may then be used in another bean definition as a property
    value or constructor argument.</para>

    <para>Here's an example where a path is used against another bean, by
    name:<programlisting>// target bean to be referenced by name
&lt;bean id="person" class="org.springframework.beans.TestBean" singleton="false"&gt;
  &lt;property name="age"&gt;&lt;value&gt;10&lt;/value&gt;&lt;/property&gt;
  &lt;property name="spouse"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age"&gt;&lt;value&gt;11&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

// will result in 11, which is the value of property 'spouse.age' of bean 'person'
&lt;bean id="theAge" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetBeanName"&gt;&lt;value&gt;person&lt;/value&gt;&lt;/property&gt;
  &lt;property name="propertyPath"&gt;&lt;value&gt;spouse.age&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>In this example, a path is evaluated against an inner bean:</para>

    <para><programlisting>// will result in 12, which is the value of property 'age' of the inner bean
&lt;bean id="theAge" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetObject"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age"&gt;&lt;value&gt;12&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
   &lt;property name="propertyPath"&gt;&lt;value&gt;age&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting> There is also a shortcut form, where the bean
    name is the property path.<programlisting>// will result in 10, which is the value of property 'age' of bean 'person'
&lt;bean id="person.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</programlisting></para>

    <para>This form does mean that there is no choice in the name of the bean,
    any reference to it will also have to use the same id, which is the path.
    Of curse, if used as an inner bean, there is no need to refer to it at
    all:</para>

    <para><programlisting>&lt;bean id="..." class="..."&gt;
  &lt;proprty name="age"&gt;
    &lt;bean id="person.age"
          class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>The result type may be specifically set in the
    actual definition. This is not necessary for most use cases, but can be of
    use for some. Please see the JavaDocs for more info on this
    feature.</para>
  </sect1>

  <sect1>
    <title>Setting a bean property or constructor arg from a field
    value</title>

    <para>FieldRetrievingFactoryBean is a FactoryBean which retrieves a static
    or non-static field value. It is typically used for retrieving public
    static final constants, which may then be used to set a property value or
    constructor arg for another bean.</para>

    <para>Here's an example which shows how a static field is exposed, by
    using the staticField property:</para>

    <para><programlisting>&lt;bean id="myField"
      class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"&gt;
  &lt;property name="staticField"&gt;&lt;value&gt;java.sql.Connection.TRANSACTION_SERIALIZABLE&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>There's also a convenience usage form where the static field is
    specified as a bean name:</para>

    <para><programlisting>&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
      class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;</programlisting></para>

    <para>This means there is no longer any choice in what the bean id is (so
    any other bean that refers to it will also have to use this longer name),
    but this form is very concise to define, and very convenient to use as an
    inner bean since the id doesn't have to be specified for the bean
    reference:<programlisting>&lt;bean id="..." class="..."&gt;
  &lt;proprty name="isolation"&gt;
    &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
      class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>It's also possible to access a non-static field
    of another bean, as described in the JavaDocs.</para>
  </sect1>

  <sect1>
    <title>Invoking another method and optionally using the return
    value.</title>

    <para>it is sometimes necessary to call a static or non-static method in
    one class, just to perform some sort of initialization, before some other
    class is used. Additionally, it is sometimes necessary to set a property
    on a bean, as the result of a method call on another bean in the
    container, or a static method call on any arbitrary class. For both of
    these purposes, a helper class called
    <classname>MethodInvokingFactoryBean</classname> may be used. This is a
    <literal><classname>FactoryBean</classname></literal> which returns a
    value which is the result of a static or instance method
    invocation.</para>

    <para>We would however recommend that for the second use case,
    factory-methods, described previously, are a better all around
    choice.</para>

    <para>An example (in an XML based BeanFactory definition) of a bean
    definition which uses this class to force some sort of static
    initialization:</para>

    <para><programlisting>&lt;bean id="force-init" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="staticMethod"&gt;&lt;value&gt;com.example.MyClass.initialize&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="bean1" class="..." depends-on="force-init"&gt;
  ...
&lt;/bean&gt;</programlisting>Note that the definition for
    <literal>bean1</literal> has used the <literal>depends-on</literal>
    attribute to refer to the <literal>force-init</literal> bean, which will
    trigger initializing <literal>force-init</literal> first, and thus calling
    the static initializer method, when <literal>bean1</literal> is first
    initialized.</para>

    <para>Here's an example of a bean definition which uses this class to call
    a static factory method:</para>

    <para><programlisting>&lt;bean id="myClass" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="staticMethod"&gt;&lt;value&gt;com.whatever.MyClassFactory.getInstance&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>An example of calling a static method then an instance method to get
    at a Java System property. Somewhat verbose, but it works.</para>

    <para><programlisting>&lt;bean id="sysProps" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetClass"&gt;&lt;value&gt;java.lang.System&lt;/value&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperties&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="javaVersion" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject"&gt;&lt;ref local="sysProps"/&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperty&lt;/value&gt;&lt;/property&gt;
  &lt;property name="arguments"&gt;
    &lt;list&gt;
      &lt;value&gt;java.version&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

    <para>Note that as it is expected to be used mostly for accessing factory
    methods, MethodInvokingFactoryBean by default operates in a
    <emphasis>singleton</emphasis> fashion. The first request by the container
    for the factory to produce an object will cause the specified method
    invocation, whose return value will be cached and returned for the current
    and subsequent requests. An internal <literal>singleton</literal> property
    of the factory may be set to false, to cause it to invoke the target
    method each time it is asked for an object.</para>

    <para>A static target method may be specified by setting the
    <literal>targetMethod</literal> property to a String representing the
    static method name, with <literal>targetClass</literal> specifying the
    Class that the static method is defined on. Alternatively, a target
    instance method may be specified, by setting the
    <literal>targetObject</literal> property as the target object, and the
    <literal>targetMethod</literal> property as the name of the method to call
    on that target object. Arguments for the method invocation may be
    specified by setting the <literal>arguments</literal> property.</para>
  </sect1>

  <sect1 id="context-import">
    <title>Importing Bean Definitions from One File Into Another</title>

    <para>It's often useful to split up container definitions into multiple
    XML files. One way to then load an application context which is configured
    from all these XML fragments is to use the application context constructor
    which takes multiple Resource locations. With a bean factory, a bean
    definition reader can be used multiple times to read definitions from each
    file in turn.</para>

    <para>Generally, the Spring team prefers the above approach, since it
    keeps container configurations files unaware of the fact that they are
    being combined with others. However, an alternate approach is to from one
    XML bean definition file, use one or more instances of the
    <literal>import</literal> element to load definitions from one or more
    other files. Any <literal>import</literal> elements must be placed before
    <literal>bean</literal> elements in the file doing the importing. Let's
    look at a sample:</para>

    <para><programlisting>&lt;beans&gt;

  &lt;import resource="services.xml"/&gt;

  &lt;import resource="resources/messageSource.xml"/&gt;

  &lt;import resource="/resources/themeSource.xml"/&gt;

  &lt;bean id="bean1" class="..."/&gt;

  &lt;bean id="bean2" class="..."/&gt;
  . . .</programlisting></para>

    <para>In this example, external bean definitions are being loaded from 3
    files, <literal>services.xml</literal>,
    <literal>messageSource.xml</literal>, and
    <literal>themeSource.xml</literal>. All location paths are considered
    relative to the definition file doing the importing, so
    <literal>services.xml</literal> in this case must be in the same directory
    or classpath location as the file doing the importing, while
    <literal>messageSource.xml</literal> and
    <literal>themeSource.xml</literal> must be in a
    <literal>resources</literal> location below the location of the importing
    file. As you can see, a leading slash is actually ignored, but given that
    these are considered relative paths, it is probably better form not to use
    the slash at all.</para>

    <para>The contents of the files being imported must be fully valid XML
    bean definition files according to the DTD, including the top level
    <literal>beans</literal> element.</para>
  </sect1>

  <sect1 id="context-create">
    <title>Creating an ApplicationContext from a web application</title>

    <para>As opposed to the BeanFactory, which will often be created
    programmatically, ApplicationContexts can be created declaratively using
    for example a <literal>ContextLoader</literal>. Of course you can also
    create ApplicationContexts programmatically using one of the
    ApplicationContext implementations. First, let's examine the ContextLoader
    and its implementations.</para>

    <para>The ContextLoader has two implementations: the
    <literal>ContextLoaderListener</literal> and the
    <literal>ContextLoaderServlet</literal>. They both have the same
    functionality but differ in that the listener cannot be used in Servlet
    2.2 compatible containers. Since the Servlet 2.4 specification, listeners
    are required to initialize after startup of a web application. A lot of
    2.3 compatible containers already implement this feature. It is up to you
    as to which one you use, but all things being equal you should probably
    prefer <literal>ContextLoaderListener</literal>; for more information on
    compatibility, have a look at the JavaDoc for the
    <literal>ContextLoaderServlet</literal>.</para>

    <para>You can register an ApplicationContext using the
    <literal>ContextLoaderListener</literal> as follows: <programlisting>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- OR USE THE CONTEXTLOADERSERVLET INSTEAD OF THE LISTENER
&lt;servlet&gt;
    &lt;servlet-name&gt;context&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--&gt;</programlisting> The listener inspects the
    <literal>contextConfigLocation</literal> parameter. If it doesn't exist,
    it'll use <literal>/WEB-INF/applicationContext.xml</literal> as a default.
    When it <emphasis>does</emphasis> exist, it'll separate the String using
    predefined delimiters (comma, semi-colon and space) and use the values as
    locations where application contexts will be searched for. The
    ContextLoaderServlet can - as said - be used instead of the
    ContextLoaderListener. The servlet will use the contextConfigLocation
    parameter just as the listener does.</para>
  </sect1>

  <sect1>
    <title>Glue code and the evil singleton</title>

    <para>The majority of the code inside an application is best written in a
    Dependency Injection (Inversion of Control) style, where that code is
    served out of a BeanFactory or ApplicationContext container, has its own
    dependencies supplied by the container when it is created, and is
    completely unaware of the container. However, for the small glue layers of
    code that are sometimes needed to tie other code together, there is
    sometimes a need for singleton (or quasi-singleton) style access to a
    BeanFactory or ApplicationContext. For example, third party code may try
    to construct new objects directly (<literal>Class.forName()</literal>
    style), without the ability to force it to get these objects out of a
    BeanFactory. If the object constructed by the third party code is just a
    small stub or proxy, which then uses a singleton style access to a
    BeanFactory/ApplicationContext to get a real object to delegate to, then
    inversion of control has still been achieved for the majority of the code
    (the object coming out of the BeanFactory); thus most code is still
    unaware of the container or how it is accessed, and remains uncoupled from
    other code, with all ensuing benefits. EJBs may also use this stub/proxy
    approach to delegate to a plain java implementation object, coming out of
    a BeanFactory. While the BeanFactory ideally does not have to be a
    singleton, it may be unrealistic in terms of memory usage or
    initialization times (when using beans in the BeanFactory such as a
    Hibernate SessionFactory) for each bean to use its own, non-singleton
    BeanFactory.</para>

    <para>As another example, in a complex J2EE apps with multiple layers
    (i.e. various JAR files, EJBs, and WAR files packaged as an EAR), with
    each layer having its own ApplicationContext definition (effectively
    forming a hierarchy), the preferred approach when there is only one
    web-app (WAR) in the top hierarchy is to simply create one composite
    ApplicationContext from the multiple XML definition files from each layer.
    All the ApplicationContext variants may be constructed from multiple
    definition files in this fashion. However, if there are multiple sibling
    web-apps at the top of the hierarchy, it is problematic to create an
    ApplicationContext for each web-app which consists of mostly identical
    bean definitions from lower layers, as there may be issues due to
    increased memory usage, issues with creating multiple copies of beans
    which take a long time to initialize (i.e. a Hibernate SessionFactory),
    and possible issues due to side-effects. As an alternative, classes such
    as <literal><ulink
    url="???">ContextSingletonBeanFactoryLocator</ulink></literal> or
    <literal><ulink
    url="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html">SingletonBeanFactoryLocator</ulink></literal>
    may be used to demand load multiple hierarchical (i.e. one is a parent of
    another) BeanFactories or ApplicationContexts in an effectively singleton
    fashion, which may then be used as the parents of the web-app
    ApplicationContexts. The result is that bean definitions for lower layers
    are loaded only as needed, and loaded only once.</para>

    <sect2>
      <title>Using SingletonBeanFactoryLocator and
      ContextSingletonBeanFactoryLocator</title>

      <para>You can see a detailed example of using <literal><ulink
      url="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html">SingletonBeanFactoryLocator</ulink></literal>
      and <literal><ulink
      url="???">ContextSingletonBeanFactoryLocator</ulink></literal> by
      viewing their respective JavaDocs.</para>

      <para>As mentioned in the chapter on EJBs, the Spring convenience base
      classes for EJBs normally use a non-singleton
      <literal>BeanFactoryLocator</literal> implementation, which is easily
      replaced by the use of <literal>SingletonBeanFactoryLocator</literal>
      and <literal>ContextSingletonBeanFactoryLocator</literal> if there is a
      need.</para>
    </sect2>
  </sect1>
</chapter>