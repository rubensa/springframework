<chapter id="integration">

    <title>Integrating third-party software</title>
    
	<sect1 id="integration-introduction">	
		
		<title>Introduction</title>

		<para> 
            Spring is an application framework for all layers: It offers a
			bean configuration foundation, AOP support, a JDBC abstraction
			framework, abstract transaction support, etc. It is a very
			non-intrusive effort: Your application classes do not need to
			depend on any Spring classes if not necessary, and you can reuse
			every part on its own if you like to. From its very design, the
			framework encourages clean separation of tiers, most importantly
			web tier and business logic: e.g. the validation framework does
			not depend on web controllers. Major goals are reusability and
			testability: Unnecessary container or framework dependencies can
			be considered avoidable evils.  
        </para>

		<para>
			Spring is potentially a one-stop shop, addressing most
			infrastructure concerns of typical applications. It also goes
			places other frameworks don't. However, if you like to use other
			technologies for certain layers in your application (e.g. the web
			layer or the persistence layer), Spring allows you to replace
			whatever solution it has for that specific layer, with any other
			solution. Spring provides a couple of pre-integrated
			technologies. These are described in this chapter.  
        </para>
		
	</sect1>
	
	<sect1 id="integration-velocity">
	
		<title>Integrating Velocity</title>
		
		<para>
		    Velocity is a view technology developed the Jakarta Project. More
		    information about Velocity can be found at
		    http://jakarta.apache.org/velocity. This chapter describes how to
		    integrate the Velocity view technology for use with Spring.
		</para>
		
		<sect2 id="integration-velocity-dependencies">
		
			<title>Dependencies</title> 

            <para>

                There is one dependency that your web application will need to
     			satisfy before working with Velocity, namely that
     			<literal>velocity-1.x.x.jar</literal> needs to be
     			available. Typically this is included in the
     			<literal>WEB-INF/lib</literal> folder where it is guaranteed
     			to be found by a J2EE server and added to the classpath for
     			your application. It is of course assumed that you already
     			have the spring.jar in your <literal>WEB-INF/lib</literal>
     			folder too! The latest stable velocity jar is supplied with
     			the Spring framework and can be copied from the
     			<literal>/lib/velocity</literal> directory.

            </para>
			
		</sect2>
		
		<sect2 id="integration-velocity-configuration-dispatcher">

			<title>Dispatcher Servlet Context</title>
			<para>	
			
                The configuration file for your Spring dispatcher servlet
			    (usually <literal>WEB-INF/[servletname]-servlet.xml</literal>)
			    should already contain a bean definition for the view
			    resolver. We'll also add a bean here to configure the Velocity
			    environment. I've chosen to call my dispatcher
			    'frontcontroller' so my config file names reflect this.
  
            </para>

			<para>
				The following code examples show the various configuration
			    files with appropriate comments.
            </para>

			<programlisting><![CDATA[		        
<!-- ===========================================================-->
<!-- View resolver. Required by web framework.                  -->
<!-- ===========================================================-->
<!--
  View resolvers can be configured with ResourceBundles or XML files.  If you need
  different view resolving based on Locale, you have to use the resource bundle resolver, 
  otherwise it makes no difference.  I simply prefer to keep the Spring configs and 
  contexts in XML.  See Spring documentation for more info.
-->
<bean id="viewResolver" class="org.springframework.web.servlet.view.XmlViewResolver">
  <property name="cache"><value>true</value></property>
  <property name="location"><value>/WEB-INF/frontcontroller-views.xml</value></property>
</bean>

<!-- ===========================================================-->
<!-- Velocity configurer.                                       -->
<!-- ===========================================================-->
<!--
  The next bean sets up the Velocity environment for us based on a properties file, the 
  location of which is supplied here and set on the bean in the normal way.  My example shows
  that the bean will expect to find our velocity.properties file in the root of the 
  WEB-INF folder.  In fact, since this is the default location, it's not necessary for me
  to supply it here.  Another possibility would be to specify all of the velocity
  properties here in a property set called "velocityProperties" and dispense with the
  actual velocity.properties file altogether.
-->
<bean 
  id="velocityConfig" 
  class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"
  singleton="true">
  <property name="configLocation"><value>/WEB-INF/velocity.properties</value></property>          
</bean>
				]]></programlisting>
		</sect2>
			
		<sect2 id="integration-velocity-configuration-velocityprops">
			
			<title>Velocity.properties</title>

			<para>
				This file contains the values that are passed to the Velocity
			    runtime in order to configure velocity itself. Only a few
			    properties are actually required, but many more optional
			    properties are available - see the Velocity docs for more
			    information. Here, I'm just demonstrating the bare minimum to
			    get Velocity up and running in your Spring MVC application.
			</para>

			<para>

				The main property values concern the location of the Velocity
			    templates themselves. Velocity templates can be loaded from
			    the classpath or the file system and there are pros and cons
			    for both. Loading from the classpath is entirely portable and
			    will work on all target servers, but you may find that the
			    templates clutter your java packages (unless you create a new
			    source tree for them). A further downside of classpath storage
			    is that during development, changing anything in the source
			    tree often causes a refresh of the resource in the
			    <literal>WEB-INF/classes</literal> tree and this in turn may
			    cause your development server to restart the application
			    (hot-deploying of code). This can be irritating. Once most of
			    the development is complete though, you could store the
			    templates in a jar file which would make them available to the
			    application if this were placed in
			    <literal>WEB-INF/lib</literal>

            </para>

			<para> 

                This example stores velocity templates on the file system
                somewhere under <literal>WEB-INF</literal> so that they are
                not directly available to the client browsers, but don't cause
                an application restart in development every time you change
                one. The downside is that the target server may not be able to
                resolve the path to these files correctly, particularly if the
                target server doesn't explode WAR modules on the file
                system. The file method works fine for Tomcat 4.1.x/5.x,
                WebSphere 4.x and WebSphere 5.x. Your mileage may vary.

            </para>

			<programlisting><![CDATA[
#
# velocity.properties - example configuration
#


# uncomment the next two lines to load templates from the 
# classpath (i.e. WEB-INF/classes)
#resource.loader=class
#class.resource.loader.class=org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader

# comment the next two lines to stop loading templates from the
# file system
resource.loader=file
file.resource.loader.class=org.apache.velocity.runtime.resource.loader.FileResourceLoader


# additional config for file system loader only.. tell Velocity where the root
# directory is for template loading.  You can define multiple root directories
# if you wish, I just use the one here.  See the text below for a note about
# the ${webapp.root}
file.resource.loader.path=${webapp.root}/WEB-INF/velocity


# caching should be 'true' in production systems, 'false' is a development
# setting only.  Change to 'class.resource.loader.cache=false' for classpath
# loading
file.resource.loader.cache=false

# override default logging to direct velocity messages
# to our application log for example.  Assumes you have 
# defined a log4j.properties file
runtime.log.logsystem.log4j.category=com.mycompany.myapplication 
			]]></programlisting>		
		        
			<para>

				The file resource loader configuration above uses a marker to
			    denote the root of the web application on the file system
			    <literal>${webapp.root}</literal>. This marker will be
			    translated into the actual OS-specific path by the Spring code
			    prior to supplying the properties to Velocity. This is what
			    makes the file resource loader non-portable in some
			    servers. The actual name of the marker itself can be changed
			    if you consider it important by defining a different
			    "appRootMarker" for VelocityConfigurer. See the Spring
			    documentation for details on how to do this.

            </para>

            <para>

			    Alternatively, you can specify velocity properties directly in
				the bean definition for the Velocity config bean by replacing
				the "configLocation" property with the following inline
				properties..

			</para>

			<programlisting><![CDATA[
<property name="velocityProperties">
  <props>
    <prop key="resource.loader">file</prop>
    <prop key="file.resource.loader.class">org.apache.velocity.runtime.resource.loader.FileResourceLoader</prop>
    <prop key="file.resource.loader.path">${webapp.root}/WEB-INF/velocity</prop>
   	<prop key="file.resource.loader.cache">false</prop>
  </props>
</property>
			]]></programlisting>		

            <para>

                Note that as of Spring version 1.0-m4 you can avoid using a
                properties file or inline properties to define file system
                loading of templates by putting the following property in the
                Velocity config bean which will cause the other values to be 
				figured out.

            </para>

			<programlisting><![CDATA[
<property name="resourceLoaderPath"><value>/WEB-INF/velocity/</value></property>
			]]></programlisting>		
            
        </sect2>
			
		<sect2 id="integration-velocity-configuration-viewconfig">
			
			<title>View configuration</title>

			<para>
				The last step in configuration is to define some views that
			    will be rendered with velocity templates. Views are always
			    defined in a consistent manner in Spring context files. As
			    noted earlier, this example uses an XML file to define view
			    beans, but a properties file (ResourceBundle) can also be
			    used. The name of the view definition file was defined earlier
			    in the ViewResolver bean - part of the
			    <literal>WEB-INF/frontcontroller-servlet.xml</literal> file.

		    </para>

			<programlisting><![CDATA[
<!--
  Views can be hierarchical, here's an example of a parent view that 
  simply defines the class to use and sets a default template which
  will normally be overridden in child definitions.
-->
<bean id="parentVelocityView" class="org.springframework.web.servlet.view.velocity.VelocityView">
  <property name="templateName"><value>mainTemplate.vm</value></property>        
</bean>

<!--
  - The main view for the home page.  Since we don't set a template name, the value
  from the parent is used.
-->
<bean id="welcomeView" parent="parentVelocityView">
  <property name="attributes">
    <props>
      <prop key="title">My Velocity Home Page</prop>
    </props>
  </property>     
</bean>  

<!--
  - Another view - this one defines a different velocity template.
-->
<bean id="secondaryView" parent="parentVelocityView">
  <property name="templateName"><value>secondaryTemplate.vm</value></property>  
  <property name="attributes">
    <props>
      <prop key="title">My Velocity Secondary Page</prop>
    </props>
  </property>    
</bean>   
			]]></programlisting>
		</sect2>

		<sect2 id="integration-velocity-templates">
			<title>Create templates and test</title>

			<para>

				Finally, you simply need to create the actual velocity
				templates. We have defined views that reference two templates,
				mainTemplate.vm and secondaryTemplate.vm Both of these files
				will live in <literal>WEB-INF/velocity/</literal> as noted in
				the velocity.properties file above. If you chose a classpath
				loader in velocity.properties, these files would live in the
				default package (<literal>WEB-INF/classes</literal>), or in a
				jar file under <literal>WEB-INF/lib</literal>.  Here's what
				our 'secondaryView' might look like (simplified HTML)

            </para>

			<programlisting><![CDATA[
## $title is set in the view definition file for this view.
<html>
  <head><title>$title</title></head>
  <body>
    <h1>This is $title!!</h1>
  </body>
</html>
			]]></programlisting>

                <para>
				    Now, when your controllers return a ModelAndView with the
				    "secondaryView" set as the view to render, Velocity should
				    kick in with the above page.
                </para>

		</sect2>
		
		<sect2 id="integration-velocity-forms">

		    <title>Form Handling</title>

			<para>
			
			    Spring provides a tag library for use in JSP's that contains
			    (amongst other things) a
			    <literal><![CDATA[<spring:bind>]]></literal> tag.  This tag
			    primarily enables forms to display the results of failed
			    validations from a <literal>Validator</literal> in the web or
			    business tier.  This behaviour can be simulated with a
			    Velocity macro and some additional Spring functionality.

			</para>

			<para>
			
			    The error messages that are actually produced from the
			    validation of a form submission can be read from a properties
			    file to make them easily maintainable or internationalised.
			    Spring handles this elegantly in its own way and you should
			    refer to the MVC tutorial or relevant parts of the javadocs
			    for details on how this works.  In order to gain access to the
			    messages, the <literal>RequestContext</literal> object needs
			    to be exposed to your Velocity templates in the
			    <literal>VelocityContext</literal>.  Amend your template
			    definition in views.properties or views.xml file to give a
			    name to this attribute (giving it a name is what causes it to
			    be exposed)

			</para>

			<programlisting><![CDATA[
<bean id="welcomeView" parent="parentVelocityView">
  <property name="requestContextAttribute"><value>rc</value></property>  
  <property name="attributes">
    <props>
      <prop key="title">My Velocity Home Page</prop>
    </props>
  </property>     
</bean>
			]]></programlisting>

			<para>

			    The example above is based on our earlier example and sets the
			    RequestContext attribute name to be rc.  All Velocity views
			    that inherit from this parent view will now have an additional
			    object available to them via the reference
			    <literal>$rc</literal>

			</para>

			<para>

			    Next, a velocity macro needs to be defined.  It makes sense to
			    create this macro in a global macro file since it will be
			    reusable across many Velocity templates (html forms).  Refer
			    to the Velocity documentation for more information on creating
			    macros.  

			</para>

			<para>

			    The code below should go into the file VM_global_library.vm in
			    the root directory of your Velocity template location..

			</para>

			<programlisting><![CDATA[
#*
 * showerror
 *
 * display an error for the field name supplied if one exists
 * in the supplied errors object.
 *
 * param $errors the object obtained from RequestContext.getErrors( "formBeanName" )
 * param $field the field name you want to display errors for (if any)
 *
 *#
#macro( showerror $errors $field )
  #if( $errors )
    #if( $errors.getFieldErrors( $field ))
      #foreach($err in $errors.getFieldErrors( $field ))
        <span class="fieldErrorText">$rc.getMessage($err)</span><br />
      #end
    #end
  #end
#end
            ]]></programlisting>

			<para>

			    Finally, in your html forms, you can use code similar to the
			    following to display bound error messages for each input
			    field.

			</para>

			<programlisting><![CDATA[
## set the following variable once somewhere at the top of
## the velocity template
#set ($errors=$rc.getErrors("commandBean"))
<html>
...
<form ...>
  <input name="query" value="$!commandBean.query"><br>
  #showerror($errors "query")
</form>
...
</html>
            ]]></programlisting>

		</sect2>		
		
   		<sect2 id="integration-velocity-summary">
			<title>Summary</title> 

            <para>

                To summarize, this is the tree structure of files discussed in
			    the example above. Only a partial tree is shown, some required
			    directories are not highlighted here. Incorrect file locations
			    are probably the major reason for velocity views not working,
			    with incorrect properties in the view definitions a close
			    second.

            </para>

			<programlisting><![CDATA[
ProjectRoot
	|
	+- WebContent
		|
		+- WEB-INF
			  |
			  +- lib
			  |    |
			  |    +- velocity-1.3.1.jar
			  |    +- spring.jar
			  |
			  +- velocity
			  |    |
			  |    +- VM_global_library.vm
			  |    +- mainTemplate.vm
			  |    +- secondaryTemplate.vm
			  |
			  +- frontcontroller-servlet.xml
			  +- frontcontroller-views.xml
			  +- velocity.properties
			]]></programlisting>
			
		</sect2>
	</sect1>
		
</chapter>


