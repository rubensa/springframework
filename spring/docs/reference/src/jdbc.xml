<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="jdbc">
	<title>Data access using JDBC</title>
	<section id="jdbc-introduction">
		<title>Introduction</title>
		<para>
			The value-add provided by the Spring Framework's JDBC abstraction
			framework is perhaps best shown by the following list (note that only
			the italicized lines need to be coded by an application developer):
		</para>
		<orderedlist numeration="arabic">
			<listitem>
				<para>Define connection parameters</para>
			</listitem>
			<listitem>
				<para>Open the connection</para>
			</listitem>
			<listitem>
				<para><emphasis>Specify the statement</emphasis></para>
			</listitem>
			<listitem>
				<para>Prepare and execute the statement</para>
			</listitem>
			<listitem>
				<para>Set up the loop to iterate through the results (if any)</para>
			</listitem>
			<listitem>
				<para><emphasis>Do the work for each iteration</emphasis></para>
			</listitem>
			<listitem>
				<para>Process any exception</para>
			</listitem>
			<listitem>
				<para>Handle transactions</para>
			</listitem>
			<listitem>
				<para>Close the connection</para>
			</listitem>
		</orderedlist>
		<para>
			The Spring Framework takes care of all the grungy, low-level details
			that can make JDBC such a tedious API to develop with.
		</para>
		<section id="jdbc-packages">
			<title>The package hierarchy</title>
			<para>
				The Spring Framework's JDBC abstraction framework consists of four
				different packages, namely <literal>core</literal>,
				<literal>dataSource</literal>, <literal>object</literal>, and
				<literal>support</literal>.
			</para>
			<para>
				The <literal>org.springframework.jdbc.core</literal> package
				contains the <classname>JdbcTemplate</classname> class and its various 
				callback interfaces, plus a variety of related classes.
			</para>
			<para>
				The <literal>org.springframework.jdbc.datasource</literal> package
				contains a utility class for easy <interfacename>DataSource</interfacename>
				access, and various simple <interfacename>DataSource</interfacename>
				implementations that can be used for testing and running
				unmodified JDBC code outside of a J2EE container. The utility class
				provides static methods to obtain connections from JNDI and to close
				connections if necessary. It has support for thread-bound connections,
				e.g. for use with <classname>DataSourceTransactionManager</classname>.
			</para>
			<para>
				Next, the <literal>org.springframework.jdbc.object</literal> package
				contains classes that represent RDBMS queries, updates, and stored
				procedures as thread safe, reusable objects. This approach is modeled by
				JDO, although of course objects returned by queries are
				<quote>disconnected</quote> from the database. This higher level of JDBC
				abstraction depends on the lower-level abstraction in the
				<literal>org.springframework.jdbc.core</literal> package.
			</para>
			<para>
				Finally the <literal>org.springframework.jdbc.support</literal>
				package is where you find the <classname>SQLException</classname> translation
				functionality and some utility classes.
			</para>
			<para>
				Exceptions thrown during JDBC processing are translated to
				exceptions defined in the <literal>org.springframework.dao</literal>
				package. This means that code using the Spring JDBC abstraction layer does
				not need to implement JDBC or RDBMS-specific error handling. All
				translated exceptions are unchecked giving you the option of catching the
				exceptions that you can recover from while allowing other exceptions to be
				propagated to the caller.
			</para>
		</section>
	</section>
	<section id="jdbc-core">
		<title>Using the JDBC Core classes to control basic JDBC processing and error handling</title>
		<section id="jdbc-JdbcTemplate">
			<title><classname>JdbcTemplate</classname></title>
			<para>
				The <classname>JdbcTemplate</classname> class is the central class in
				the JDBC core package. It simplifies the use of JDBC since it handles the
				creation and release of resources. This helps to avoid common errors such
				as forgetting to always close the connection. It executes the core JDBC
				workflow like statement creation and execution, leaving application code
				to provide SQL and extract results. This class executes SQL queries, update
				statements or stored procedure calls, imitating iteration over
				<interfacename>ResultSet</interfacename>s and extraction of returned
				parameter values. It also catches JDBC exceptions and
				translates them to the generic, more informative, exception hierarchy
				defined in the <literal>org.springframework.dao</literal> package.
			</para>
			<para>
				Code using the <classname>JdbcTemplate</classname> only need to implement
				callback interfaces, giving them a clearly defined contract. The
				<interfacename>PreparedStatementCreator</interfacename> callback
				interface creates a	prepared statement given a
				<interfacename>Connection</interfacename> provided by this class,
				providing SQL and any necessary parameters. The same is true for the
				<interfacename>CallableStatementCreator</interfacename> interface
				which creates callable statement. The
				<interfacename>RowCallbackHandler</interfacename> interface extracts
				values from each row of a <interfacename>ResultSet</interfacename>.
			</para>
			<para>
				The <classname>JdbcTemplate</classname> can be used within a DAO
				implementation via direct instantiation with a <interfacename>DataSource</interfacename>
				reference, or be configured in a Spring IOC container and given to DAOs as a
				bean reference. Note: the <interfacename>DataSource</interfacename> should
				always be configured as a bean in the Spring IoC container, in the first
				case given to the service directly, in the second case to the prepared
				template.
			</para>
			<para>
				Finally, all of the SQL issued by this class is logged at the
				<literal>'DEBUG'</literal> level under the category corresponding
				to the fully qualified class name of the template instance (typically
				<classname>JdbcTemplate</classname>, but it may be different if a custom
				subclass of the <classname>JdbcTemplate</classname> class is being used).
			</para>
			<section id="jdbc-JdbcTemplate-examples">
				<title>Examples</title>
				<para>Find below some examples of using the <classname>JdbcTemplate</classname>
				class. (These examples are not an exhaustive list of all of the functionality
				exposed by the <classname>JdbcTemplate</classname>; see the attendant Javadocs for that).</para>
				<section id="jdbc-JdbcTemplate-examples-query">
					<title>Querying (SELECT)</title>
					<para>A simple query for getting the number of rows in a relation.</para>
					<programlisting><![CDATA[int rowCount = this.jdbcTemplate.queryForInt("select count(0) from t_accrual");]]></programlisting>
					<para>A simple query using a bind variable.</para>
					<programlisting><![CDATA[int countOfActorsNamedJoe
    = this.jdbcTemplate.queryForInt("select count(0) from t_actors where first_name = ?", new Object[]{"Joe"});]]></programlisting>
					<para>Querying for a <classname>String</classname>.</para>
					<programlisting><![CDATA[String surname = (String) this.jdbcTemplate
    .queryForObject("select surname from t_actor where id = ?", new Object[]{new Long(1212)}, String.class);]]></programlisting>
					<para>Querying and populating a <emphasis>single</emphasis> domain object.</para>
					<programlisting><![CDATA[Actor actor = (Actor) this.jdbcTemplate.queryForObject(
    "select first_name, surname from t_actor where id = ?",
    new Object[]{new Long(1212)},
    new RowMapper() {

        public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setFirstName(rs.getString("first_name"));
            actor.setSurname(rs.getString("surname"));
            return actor;
        }
    });]]></programlisting>
					<para>Querying and populating a number of domain objects.</para>
					<programlisting><![CDATA[Collection actors = this.jdbcTemplate.query(
    "select first_name, surname from t_actor",
    new RowMapper() {

        public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setFirstName(rs.getString("first_name"));
            actor.setSurname(rs.getString("surname"));
            return actor;
        }
    });]]></programlisting>
					<para>If the last two snippets of code actually existed in the same application,
					it would make sense to remove the duplication present in the two
					<interfacename>RowMapper</interfacename> anonymous inner classes,
					and extract them out into a single class (typically a <literal>static</literal>
					inner class) that can then be referenced by DAO methods as needed. For example,
					the last code snippet might be better off written like so:</para>
					<programlisting><![CDATA[public Collection findAllActors() {
    return this.jdbcTemplate.query( "select first_name, surname from t_actor", new ActorMapper());
}

private static final class ActorMapper implements RowMapper {

    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
        Actor actor = new Actor();
        actor.setFirstName(rs.getString("first_name"));
        actor.setSurname(rs.getString("surname"));
        return actor;
    }
}]]></programlisting>
				</section>
				<section id="jdbc-JdbcTemplate-examples-update">
					<title>Updating (INSERT/UPDATE/DELETE)</title>
					<programlisting><![CDATA[this.jdbcTemplate.update("insert into t_actor (first_name, surname) values (?, ?)", new Object[] {"Leonor", "Watling"});]]></programlisting>
					<programlisting><![CDATA[this.jdbcTemplate.update("update t_actor set weapon = ? where id = ?", new Object[] {"Banjo", new Long(5276)});]]></programlisting>
					<programlisting><![CDATA[this.jdbcTemplate.update("delete from orders");]]><lineannotation> // :)</lineannotation></programlisting>
				</section>
				<section id="jdbc-JdbcTemplate-examples-other">
					<title>Other operations (DDL)</title>
					<para>The <methodname>execute(..)</methodname> method can be used to execute any
					arbitrary SQL, and as such is often used for DDL statements. It is heavily overloaded
					with variants taking callback interfaces, bind variable arrays, and suchlike.</para>
					<programlisting><![CDATA[this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");]]></programlisting>
				</section>
			</section>
			<section id="jdbc-JdbcTemplate-idioms">
				<title><classname>JdbcTemplate</classname> idioms (best practices)</title>
				<para>Instances of the <classname>JdbcTemplate</classname> class are
				<emphasis>threadsafe once configured</emphasis>. This is important because it
				means that you can configure a single instance of a <classname>JdbcTemplate</classname>
				and then safely inject this <emphasis>shared</emphasis> reference into multiple
				DAOs (or repositories). To be clear, the <classname>JdbcTemplate</classname>
				is stateful, in that it maintains a reference to a <interfacename>DataSource</interfacename>,
				but this state is <emphasis>not</emphasis> conversational state.</para>
				<para>A common idiom when using the <classname>JdbcTemplate</classname> class
				(and the associated <link linkend="jdbc-SimpleJdbcTemplate"><classname>SimpleJdbcTemplate</classname></link>
				and <link linkend="jdbc-NamedParameterJdbcTemplate"><classname>NamedParameterJdbcTemplate</classname></link> classes)
				is to configure a <interfacename>DataSource</interfacename> in your Spring configuration file,
				and then dependency inject that shared <interfacename>DataSource</interfacename> bean
				into your DAO classes; the <classname>JdbcTemplate</classname> is created in the setter
				for the <interfacename>DataSource</interfacename>. This leads to DAOs that look
				in part like this:</para>
				<programlisting><![CDATA[public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        ]]><emphasis role="bold">this.jdbcTemplate = new JdbcTemplate(dataSource);</emphasis><![CDATA[
    }

    ]]><lineannotation>// JDBC-backed implementations of the methods on the <interfacename>CorporateEventDao</interfacename> follow...</lineannotation><![CDATA[
}]]></programlisting>
				<para>The attendant configuration might look like this.</para>
				<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans/spring-beans-2.0.xsd">

    <bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    ]]><lineannotation>&lt;!-- the <interfacename>DataSource</interfacename> (parameterized for configuration via a <link linkend="beans-factory-placeholderconfigurer"><classname>PropertyPlaceHolderConfigurer</classname></link>) --&gt;</lineannotation><![CDATA[
    <bean id="dataSource" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>

</beans>]]></programlisting>
				<para>If you are using Spring's <classname>JdbcDaoSupport</classname> class, and
				your various JDBC-backed DAO classes extend from it, then you inherit a
				<methodname>setDataSource(..)</methodname> method for free from said superclass. It is
				totally up to you as to whether or not you inherit from said class, you certainly are
				not forced to. If you look at the source for the <classname>JdbcDaoSupport</classname>
				class you will see that there is not a whole lot to it... it is provided as a convenience
				only.</para>
				<para>Regardless of which of the above template initialization styles you choose
				to use (or not), there is (almost) certainly no need to create a brand new
				instance of a <classname>JdbcTemplate</classname> class each and every time you wish
				to execute some SQL... remember, once configured, a <classname>JdbcTemplate</classname>
				instance is threadsafe. A reason for wanting multiple <classname>JdbcTemplate</classname>
				instances would be when you have an application that accesses multiple databases, which
				requires multiple <interfacename>DataSources</interfacename>, and subsequently
				multiple differently configured <classname>JdbcTemplates</classname>.</para>
			</section>
		</section>
		<section id="jdbc-NamedParameterJdbcTemplate">
			<title><classname>NamedParameterJdbcTemplate</classname></title>
			<para>
				The <classname>NamedParameterJdbcTemplate</classname> class adds support
				for programming JDBC statements using named parameters (as opposed to
				programming JDBC statements using only classic placeholder
				(<literal>'?'</literal>) arguments. The <classname>NamedParameterJdbcTemplate</classname> class wraps
				a <classname>JdbcTemplate</classname>, and delegates to the
				wrapped <classname>JdbcTemplate</classname> to do much of its work.
				This section will describe only those areas of the
				<classname>NamedParameterJdbcTemplate</classname> class that differ from
				the <classname>JdbcTemplate</classname> itself; namely, programming
				JDBC statements using named parameters.
			</para>
			<programlisting><lineannotation>// some JDBC-backed DAO class...</lineannotation><![CDATA[
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(0) from T_ACTOR where first_name = :first_name";

    SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

    return namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}]]></programlisting>
			<para>
				Notice the use of the named parameter notation in the value assigned
				to the <literal>'sql'</literal> variable, and the corresponding value
				that is plugged into the <literal>'namedParameters'</literal> variable
				(of type <classname>MapSqlParameterSource</classname>).
			</para>
			<para>
				If you like, you can also pass along named parameters (and their
				corresponding values) to a <classname>NamedParameterJdbcTemplate</classname>
				instance using the (perhaps more familiar)
				<interfacename>Map</interfacename>-based style.
				(The rest of the methods exposed by the
				<interfacename>NamedParameterJdbcOperations</interfacename> - and implemented by the <classname>NamedParameterJdbcTemplate</classname> class)
				follow a similar pattern and will not be covered here.)
			</para>
<programlisting><lineannotation>// some JDBC-backed DAO class...</lineannotation><![CDATA[
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(0) from T_ACTOR where first_name = :first_name";

    Map namedParameters = Collections.singletonMap("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}]]></programlisting>
			<para>
				Another nice feature related to the <classname>NamedParameterJdbcTemplate</classname>
				(and existing in the same Java package) is the <interfacename>SqlParameterSource</interfacename>
				interface. You have already seen an example of an implementation of this
				interface in one of the preceding code snippets (the <classname>MapSqlParameterSource</classname>
				class). The entire point of the <interfacename>SqlParameterSource</interfacename> is to serve as
				a source of named parameter values to a <classname>NamedParameterJdbcTemplate</classname>.
				The <classname>MapSqlParameterSource</classname> class is a very simple implementation, that
				is simply an adapter around a <interfacename>java.util.Map</interfacename>, where the keys
				are the paramter names and the values are the parameter values.
			</para>
			<para>
				Another <interfacename>SqlParameterSource</interfacename> implementation is the
				<classname>BeanPropertySqlParameterSource</classname> class. This class wraps an arbitrary
				JavaBean (that is, an instance of a class that adheres to
				<ulink url="http://java.sun.com/products/javabeans/docs/spec.html">the JavaBean conventions</ulink>),
				and uses the properties of the wrapped JavaBean as the source of named parameter values.
			</para>
			<programlisting><![CDATA[public class Actor {

    private Long id;
    private String firstName;
    private String lastName;
    
    public String getFirstName() {
        return this.firstName;
    }
    
    public String getLastName() {
        return this.lastName;
    }
    
    public Long getId() {
        return this.id;
    }
    
    ]]><lineannotation>// setters omitted...</lineannotation><![CDATA[

}]]></programlisting>
			<programlisting><lineannotation>// some JDBC-backed DAO class...</lineannotation><![CDATA[
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {

    ]]><lineannotation>// notice how the named parameters match the properties of the above '<classname>Actor</classname>' class</lineannotation><![CDATA[
    String sql = "select count(0) from T_ACTOR where first_name = :firstName and last_name = :lastName";

    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

    return this.namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}]]></programlisting>
			<para>
				Remember that the <classname>NamedParameterJdbcTemplate</classname> class
				<emphasis>wraps</emphasis> a classic <classname>JdbcTemplate</classname>
				template; if you need access to the wrapped <classname>JdbcTemplate</classname> instance
				(to access some of the functionality only present in the <classname>JdbcTemplate</classname>
				class), then you can use the <methodname>getJdbcOperations()</methodname>
				method to access the wrapped <classname>JdbcTemplate</classname>
				<emphasis>via the <interfacename>JdbcOperations</interfacename> interface</emphasis>.
			</para>
			<para>
				See also the section entitled <xref linkend="jdbc-JdbcTemplate-idioms"/> for some
				advice on how to best use the <classname>NamedParameterJdbcTemplate</classname> class
				in the context of an application.
			</para>
		</section>
		<section id="jdbc-SimpleJdbcTemplate">
			<title><classname>SimpleJdbcTemplate</classname></title>
			<note>
				<para>
					<emphasis>The functionality offered by the <classname>SimpleJdbcTemplate</classname>
					is only available to you if you are using Java 5 (Tiger).</emphasis>
				</para>
			</note>
			<para>
				The <classname>SimpleJdbcTemplate</classname> class is a wrapper around
				the classic <classname>JdbcTemplate</classname> that takes advantage
				of Java 5 language features such as varargs and autoboxing. The
				<classname>SimpleJdbcTemplate</classname> class is somewhat of a sop
				to the syntactic-sugar-like features of Java 5, but as anyone who has
				developed on Java 5 and then had to move back to developing on a
				previous version of the JDK will know, those syntactic-sugar-like features sure are nice.
			</para>
			<para>
				The value-add of the <classname>SimpleJdbcTemplate</classname> class
				in the area of syntactic-sugar is best illustrated with a
				<emphasis>'before and after'</emphasis> example. The following code
				snippet shows first some data access code using the classic
				<classname>JdbcTemplate</classname>, followed immediately thereafter
				by a code snippet that does the same job, only this time using the
				<classname>SimpleJdbcTemplate</classname>.
			</para>
			<programlisting><lineannotation>// classic <classname>JdbcTemplate</classname>-style...</lineannotation><![CDATA[
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public Actor findActor(long id) {
    String sql = "select id, first_name, last_name from T_ACTOR where id = ?";
    
    RowMapper mapper = new RowMapper() {
    
        public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setId(rs.getLong("id"));
            actor.setFirstName(rs.getString("first_name"));
            actor.setLastName(rs.getString("last_name"));
            return actor;
        }
    };
    
    ]]><lineannotation>// notice the cast, the wrapping up of the 'id' argument
    // in an array, and the boxing of the 'id' argument as a reference type</lineannotation><![CDATA[
    return (Actor) jdbcTemplate.queryForObject(sql, mapper, new Object[] {Long.valueOf(id)});
}]]></programlisting>
			<para>Here is the same method, only this time using the	<classname>SimpleJdbcTemplate</classname>;
			notice how much 'cleaner'the code is.</para>
			<programlisting><lineannotation>// <classname>SimpleJdbcTemplate</classname>-style...</lineannotation><![CDATA[
private SimpleJdbcTemplate simpleJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
}
public Actor findActor(long id) {
    String sql = "select id, first_name, last_name from T_ACTOR where id = ?";

    ParameterizedRowMapper<Actor> mapper = new ParameterizedRowMapper<Actor>() {
    
        ]]><lineannotation>// notice the return type with respect to Java 5 covariant return types</lineannotation><![CDATA[
        public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setId(rs.getLong("id"));
            actor.setFirstName(rs.getString("first_name"));
            actor.setLastName(rs.getString("last_name"));
            return actor;
        }
    };

    return this.simpleJdbcTemplate.queryForObject(sql, mapper, id);
}]]></programlisting>
			<para>
				See also the section entitled <xref linkend="jdbc-JdbcTemplate-idioms"/> for some
				advice on how to best use the <classname>SimpleJdbcTemplate</classname> class
				in the context of an application.
			</para>
			<note>
				<para>
					The <classname>SimpleJdbcTemplate</classname> class only offers
					a much smaller subset of the methods exposed on the <classname>JdbcTemplate</classname>
					class. If you need to use a method from the <classname>JdbcTemplate</classname> that
					is not defined on the <classname>SimpleJdbcTemplate</classname>, you can always
					access the underlying <classname>JdbcTemplate</classname> by calling the
					<methodname>getJdbcOperations()</methodname> method on the <classname>SimpleJdbcTemplate</classname>,
					which will then allow you to invoke the method that you want. The only
					downside is that the methods on the <interfacename>JdbcOperations</interfacename>
					interface are not generified, so you are back to casting and such again.
				</para>
			</note>
		</section>
		<section id="jdbc-datasource">
			<title><interfacename>DataSource</interfacename></title>
			<para>
				In order to work with data from a database, one needs to obtain a
				connection to the database. The way Spring does this is through a
				<interfacename>DataSource</interfacename>. A
				<interfacename>DataSource</interfacename> is part
				of the JDBC specification and can be seen as a generalized connection
				factory. It allows a container or a framework to hide connection pooling
				and transaction management issues from the application code. As a
				developer, you don not need to know any details about how to connect to
				the database, that is the responsibility for the administrator that sets
				up the datasource. You will most likely have to fulfill both roles while
				you are developing and testing you code though, but you will not
				necessarily have to know how the production data source is configured.
			</para>
			<para>
				When using Spring's JDBC layer, you can either obtain a data
				source from JNDI or you can configure your own, using an implementation
				that is provided in the Spring distribution. The latter comes in handy
				for unit testing outside of a web container. We will use the
				<classname>DriverManagerDataSource</classname> implementation for this
				section but there are several additional implementations that will be
				covered later on. The <classname>DriverManagerDataSource</classname> works
				the same way that you probably are used to work when you obtain a JDBC
				connection. You have to specify the fully qualified class name of the
				JDBC driver that you are using so that the
				<classname>DriverManager</classname> can load the driver class. Then you
				have to provide a url that varies between JDBC drivers. You have to
				consult the documentation for your driver for the correct value to use
				here. Finally you must provide a username and a password that will be
				used to connect to the database. Here is an example of how to configure
				a <classname>DriverManagerDataSource</classname>:
			</para>
			<programlisting><![CDATA[DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername("sa");
dataSource.setPassword("");]]></programlisting>
		</section>
		<section id="jdbc-SQLExceptionTranslator">
			<title><interfacename>SQLExceptionTranslator</interfacename></title>
			<para>
				<interfacename>SQLExceptionTranslator</interfacename> is an interface to be
				implemented by classes that can translate between <classname>SQLExceptions</classname>
				and Spring's own data-access-strategy-agnostic
				<classname>org.springframework.dao.DataAccessException</classname>. Implementations can
				be generic (for example, using SQLState codes for JDBC) or proprietary (for example,
				using Oracle error codes) for greater precision.
			</para>
			<para>
				<classname>SQLErrorCodeSQLExceptionTranslator</classname> is the
				implementation of <interfacename>SQLExceptionTranslator</interfacename> that is used by default. This
				implementation uses specific vendor codes. More precise than
				<literal>SQLState</literal> implementation, but vendor specific. The
				error code translations are based on codes held in a JavaBean type class
				named <classname>SQLErrorCodes</classname>. This class is created and
				populated by an <classname>SQLErrorCodesFactory</classname> which as the
				name suggests is a factory for creating <classname>SQLErrorCodes</classname>
				based on the contents of a configuration file named
				<filename class="libraryfile">'sql-error-codes.xml'</filename>. This file is populated
				with vendor codes and based on the DatabaseProductName taken from the
				<interfacename>DatabaseMetaData</interfacename>, the codes for the current database are used.
			</para>
			<para>
				The <classname>SQLErrorCodeSQLExceptionTranslator</classname> applies
				the following matching rules:
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Try custom translation implemented by any subclass. Note
							that this class is concrete and is typically used itself, in which
							case this rule does not apply.
						</para>
					</listitem>
					<listitem>
						<para>
							Apply error code matching. Error codes are obtained from the
							<classname>SQLErrorCodesFactory</classname> by default. This looks
							up error codes from	the classpath and keys into them from the
							database name from the database metadata.
						</para>
					</listitem>
					<listitem>
						<para>
							Use the fallback translator. <classname>SQLStateSQLExceptionTranslator</classname>
							is the default fallback translator.
						</para>
					</listitem>
				</itemizedlist>
			</para>
			<para>
				<classname>SQLErrorCodeSQLExceptionTranslator</classname> can be extended the following way:
			</para>
			<programlisting><![CDATA[public class MySQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

    protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) {
        if (sqlex.getErrorCode() == -12345) {
            return new DeadlockLoserDataAccessException(task, sqlex);
        }
        return null;
    }
}]]></programlisting>
			<para>
				In this example the specific error code <literal>'-12345'</literal> is
				translated and any other errors are simply left to be translated by the
				default translator implementation. To use this custom translator, it is
				necessary to pass it to the <classname>JdbcTemplate</classname> using the
				method <literal>setExceptionTranslator</literal> and to use this
				<classname>JdbcTemplate</classname> for all of the data access processing
				where this translator is needed. Here is an example of how this custom
				translator can be used:
			</para>
            <programlisting><lineannotation>// create a <classname>JdbcTemplate</classname> and set data source</lineannotation><![CDATA[ 
JdbcTemplate jt = new JdbcTemplate(); 
jt.setDataSource(dataSource); 
]]><lineannotation>// create a custom translator and set the <interfacename>DataSource</interfacename> for the default translation lookup</lineannotation><![CDATA[ 
MySQLErrorCodesTransalator tr = new MySQLErrorCodesTransalator(); 
tr.setDataSource(dataSource); 
jt.setExceptionTranslator(tr); 
]]><lineannotation>// use the <classname>JdbcTemplate</classname> for this <classname>SqlUpdate</classname></lineannotation><![CDATA[
SqlUpdate su = new SqlUpdate(); 
su.setJdbcTemplate(jt); 
su.setSql("update orders set shipping_charge = shipping_charge * 1.05"); 
su.compile(); 
su.update();]]></programlisting>
			<para>
				The custom translator is passed a data source because we still want
				the default translation to look up the error codes in
				<literal>sql-error-codes.xml</literal>.
			</para>
		</section>
		<section id="jdbc-statements-executing">
			<title>Executing statements</title>
			<para>
				To execute an SQL statement, there is very little code needed. All
				you need is a <interfacename>DataSource</interfacename> and a
				<classname>JdbcTemplate</classname>. Once you have that, you can use a
				number of convenience methods that are provided with the
				<classname>JdbcTemplate</classname>. Here is a short example showing what
				you need to include for a minimal but fully functional class that
				creates a new table.
			</para>
			<programlisting><![CDATA[import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void doExecute() {
        this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
    }
}]]></programlisting>
		</section>
		<section id="jdbc-statements-querying">
			<title>Running Queries</title>
			<para>
				In addition to the execute methods, there is a large number of
				query methods. Some of these methods are intended to be used for queries
				that return a single value. Maybe you want to retrieve a count or a
				specific value from one row. If that is the case then you can use
				<methodname>queryForInt(..)</methodname>, <methodname>queryForLong(..)</methodname> or
				<methodname>queryForObject(..)</methodname>. The latter will convert the returned
				JDBC <classname>Type</classname> to the Java class that is passed in as an argument. If the
				type conversion is invalid, then an
				<exceptionname>InvalidDataAccessApiUsageException</exceptionname> will be thrown.
				Here is an example that contains two query methods, one for an
				<classname>int</classname> and one that queries for a <classname>String</classname>.
			</para>
			<programlisting><![CDATA[import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
  
    public int getCount() {
        return this.jdbcTemplate.queryForInt("select count(*) from mytable");
    }

    public String getName() {
        return (String) this.jdbcTemplate.queryForObject("select name from mytable", String.class);
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}]]></programlisting>
			<para>
				In addition to the single results query methods there are several
				methods that return a List with an entry for each row that the query
				returned. The most generic method is <methodname>queryForList(..)</methodname> which
				returns a <interfacename>List</interfacename> where each entry is a
				<interfacename>Map</interfacename> with each entry in the map representing the
				column value for that row. If we add a method to the above example to
				retrieve a list of all the rows, it would look like this:
			</para>
			<programlisting><![CDATA[
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public List getList() {
    return this.jdbcTemplate.queryForList("select * from mytable");
}]]></programlisting>
			<para>
				The list returned would look something like this:
			</para>
			<programlisting><![CDATA[[{name=Bob, id=1}, {name=Mary, id=2}]]]></programlisting>
		</section>
		<section id="jdbc-updates">
			<title>Updating the database</title>
			<para> There are also a number of update methods that you can use. Find below an
				example where a column is updated for a certain primary key. In this example
				an SQL statement is used that has placeholders for row parameters. Note that
				the parameter values are passed in as an array of objects (and thus
				primitives have to be wrapped in the primitive wrapper classes). </para>
			
			<programlisting><![CDATA[import javax.sql.DataSource;

import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void setName(int id, String name) {
        this.jdbcTemplate.update("update mytable set name = ? where id = ?", new Object[] {name, new Integer(id)});
    }
}]]></programlisting>
			<para> 
				One of the <methodname>update</methodname> convenience methods provides support
				for acquiring the primary keys generated by the database (part of the JDBC 3.0 standard
				- see chapter 13.6 of the specification for details).
				The method takes a <classname>PreparedStatementCreator</classname> as its first argument,
				and this is the way the required insert statement is specified.  The other argument is a
				<classname>KeyHolder</classname>, which will contain the generated key on successful
				return from the update.  There is not a standard single way to create an 
				appropriate <classname>PreparedStatement</classname> (which explains why the method
				signature is the way it is).  An example that works on Oracle and may work on other
				platforms is:
			</para>
			<programlisting><![CDATA[final String INSERT_SQL = "insert into my_test (name) values(?)";
final String name = "Rob";

KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(
    new PreparedStatementCreator() {
        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
            PreparedStatement ps =
                connection.prepareStatement(INSERT_SQL, new String[] {"id"});
            ps.setString(1, name);
            return ps;
        }
    },
    keyHolder);

]]><lineannotation>// keyHolder.getKey() now contains the generated key</lineannotation></programlisting>
		</section>
	</section>
	<section id="jdbc-connections">
		<title>Controlling database connections</title>
		<section id="jdbc-DataSourceUtils">
			<title><classname>DataSourceUtils</classname></title>
			<para>
				The <classname>DataSourceUtils</classname> class is a convenient and
				powerful helper class that provides <literal>static</literal> methods to
				obtain connections from JNDI and close connections if necessary. It has
				support for thread-bound connections, for example for use with
				<classname>DataSourceTransactionManager</classname>.
			</para>
			<note>
				<para>The <methodname>getDataSourceFromJndi(..)</methodname> methods are
				targeted at applications that do not use the Spring Framework's IoC container.
				With the latter, it is preferable to preconfigure one's beans or
				even <classname>JdbcTemplate</classname> instances in the
				container itself: a <classname>JndiObjectFactoryBean</classname> instance
				can be used to fetch a <interfacename>DataSource</interfacename> from JNDI and give the
				<interfacename>DataSource</interfacename> bean reference to other
				beans. Switching to another <interfacename>DataSource</interfacename>
				then becomes just a matter of configuration; one can even replace the definition
				of the <interfacename>FactoryBean</interfacename> with a non-JNDI
				<interfacename>DataSource</interfacename>!</para>
			</note>
		</section>
		<section id="jdbc-SmartDataSource">
			<title><interfacename>SmartDataSource</interfacename></title>
			<para>
				The <interfacename>SmartDataSource</interfacename> interface is to 
				be implemented by classes that can provide a connection to a relational
				database. Extends the <interfacename>DataSource</interfacename> interface to
				allow classes using it to query whether or not the connection should be
				closed after a given operation. This can sometimes be useful for efficiency,
				in the cases where one knows that one wants to reuse a connection.
			</para>
		</section>
		<section id="jdbc-AbstractDataSource">
			<title><classname>AbstractDataSource</classname></title>
			<para>
				This is an <literal>abstract</literal> base class for Spring's
				<interfacename>DataSource</interfacename> implementations, that takes
				care of the "uninteresting" glue. This is the class one would extend if
				one was writing one's own <interfacename>DataSource</interfacename>
				implementation.
			</para>
		</section>
		<section id="jdbc-SingleConnectionDataSource">
			<title><classname>SingleConnectionDataSource</classname></title>
			<para>
				The <classname>SingleConnectionDataSource</classname> class is an
				implementation of the <interfacename>SmartDataSource</interfacename>
				interface that wraps a <emphasis>single</emphasis>
				<interfacename>Connection</interfacename> that is <emphasis>not</emphasis>
				closed after use. Obviously, this is not multi-threading capable.
			</para>
			<para>
				If client code will call close in the assumption of a pooled
				connection, like when using persistence tools, set
				<literal>suppressClose</literal> to <literal>true</literal>. This will
				return a close-suppressing proxy instead of the physical connection.
				Be aware that you will not be able to cast this to a native Oracle
				<interfacename>Connection</interfacename> or the like anymore.
			</para>
			<para>
				This is primarily a test class. For example, it enables easy
				testing of code outside an application server, in conjunction with a
				simple JNDI environment. In contrast to
				<classname>DriverManagerDataSource</classname>, it reuses the same
				connection all the time, avoiding excessive creation of physical
				connections.
			</para>
		</section>
		<section id="jdbc-DriverManagerDataSource">
			<title><classname>DriverManagerDataSource</classname></title>
			<para>
				The <classname>DriverManagerDataSource</classname> class is an
				implementation of the <interfacename>SmartDataSource</interfacename>
				interface that  configures a plain old JDBC Driver via bean properties,
				and returns a new connection every time.
			</para>
			<para>
				This is potentially useful for test or standalone environments
				outside of a J2EE container, either as a <interfacename>DataSource</interfacename>
				bean in a Spring IoC container, or in conjunction with a simple
				JNDI environment. Pool-assuming <literal>Connection.close()</literal>
				calls will simply close the connection, so any <interfacename>DataSource</interfacename>-aware
				persistence code should work. However, using JavaBean style connection
				pools such as commons-dbcp is so easy, even in a test environment, that
				it is almost always preferable to use such a connection pool over
				<classname>DriverManagerDataSource</classname>.
			</para>
		</section>
		<section id="jdbc-TransactionAwareDataSourceProxy">
			<title><classname>TransactionAwareDataSourceProxy</classname></title>
			<para>
				<classname>TransactionAwareDataSourceProxy</classname> is a proxy for a target
				<interfacename>DataSource</interfacename>, which wraps that target
				<interfacename>DataSource</interfacename> to add awareness of
				Spring-managed transactions. In this respect it is similar to a
				transactional JNDI <interfacename>DataSource</interfacename> as provided by a J2EE
				server.
			</para>
			<note>
				<para>It should almost never be necessary or desireable to use this
				class, except when existing code exists which must be called and passed
				a standard JDBC <interfacename>DataSource</interfacename> interface implementation.
				In this case, it's possible to still have this code be usable, but
				participating in Spring managed transactions. It is generally preferable
				to write your own new code using the higher level abstractions for
				resource management, such as <classname>JdbcTemplate</classname> or
				<classname>DataSourceUtils</classname>.</para>
			</note>
			<para>
				<emphasis>(See the <classname>TransactionAwareDataSourceProxy</classname>
				Javadocs for more details.)</emphasis>
			</para>
		</section>
		<section id="jdbc-DataSourceTransactionManager">
			<title><classname>DataSourceTransactionManager</classname></title>
			<para>
				The <classname>DataSourceTransactionManager</classname> class is a
				<interfacename>PlatformTransactionManager</interfacename> implementation
				for single JDBC datasources. It binds a JDBC connection from the specified
				data source to the currently executing thread, potentially allowing for
				one thread connection per data source.
			</para>
			<para>
				Application code is required to retrieve the JDBC connection via
				<literal>DataSourceUtils.getConnection(DataSource)</literal> instead of
				J2EE's standard <literal>DataSource.getConnection</literal>. This is
				recommended anyway, as it throws unchecked
				<literal>org.springframework.dao</literal> exceptions instead of checked
				<exceptionname>SQLExceptions</exceptionname>. All framework classes like
				<classname>JdbcTemplate</classname> use this strategy implicitly. If not
				used with this transaction manager, the lookup strategy behaves exactly
				like the common one - it can thus be used in any case.
			</para>
			<para>
				The <classname>DataSourceTransactionManager</classname> class supports
				custom isolation levels, and timeouts that get applied as
				appropriate JDBC statement query timeouts. To support the latter,
				application code must either use <classname>JdbcTemplate</classname> or call
				<literal>DataSourceUtils.applyTransactionTimeout(..)</literal> method for
				each created statement.
			</para>
			<para>
				This implementation can be used instead of
				<classname>JtaTransactionManager</classname> in the single resource case, as
				it does not require the container to support JTA. Switching between both
				is just a matter of configuration, if you stick to the required
				connection lookup pattern. Note that JTA does not support custom
				isolation levels!
			</para>
		</section>
	</section>
	<section id="jdbc-object">
		<title>Modeling JDBC operations as Java objects</title>
		<para>
			The <literal>org.springframework.jdbc.object</literal> package
			contains classes that allow one to access the database in a more
			object-oriented manner. By way of an example, one can execute queries
			and get the results back as a list containing business objects with
			the relational column data mapped to the properties of the business
			object. One can also execute stored procedures and run update, delete
			and insert statements.
		</para>
		<note>
			<para>
				There is a view borne from experience acquired in the field
				amongst some of the Spring developers that the various RDBMS
				operation classes described below (with the exception of the
				<link linkend="jdbc-StoredProcedure"><classname>StoredProcedure</classname></link>
				class) can often be replaced with straight <classname>JdbcTemplate</classname>
				calls... often it is simpler to use and plain easier to read a DAO method
				that simply calls a method on a <classname>JdbcTemplate</classname> direct
				(as opposed to encapsulating a query as a full-blown class).
			</para>
			<para>
				It must be stressed however that this is just a <emphasis>view</emphasis>...
				if you feel that you are getting measurable value from using the RDBMS
				operation classes, feel free to continue using these classes.
			</para>
		</note>
		<section id="jdbc-SqlQuery">
			<title><classname>SqlQuery</classname></title>
			<para>
				<classname>SqlQuery</classname> is a reusable, threadsafe class that
				encapsulates an SQL query. Subclasses must implement the
				<methodname>newRowMapper(..)</methodname> method to provide a
				<interfacename>RowMapper</interfacename> instance that
				can create one object per row obtained from iterating over the
				<interfacename>ResultSet</interfacename> that is created during the
				execution of the query. The <classname>SqlQuery</classname> class is
				rarely used directly since the <classname>MappingSqlQuery</classname>
				subclass provides a much more convenient implementation for mapping
				rows to Java classes. Other	implementations that extend
				<classname>SqlQuery</classname> are
				<classname>MappingSqlQueryWithParameters</classname> and
				<classname>UpdatableSqlQuery</classname>.
			</para>
		</section>
		<section id="jdbc-MappingSqlQuery">
			<title><classname>MappingSqlQuery</classname></title>
			<para><classname>MappingSqlQuery</classname> is a reusable query in which
			concrete subclasses must implement the abstract
			<methodname>mapRow(..)</methodname> method to convert each row of
			the supplied <interfacename>ResultSet</interfacename> into an object.
			Find below a brief example of a custom query that maps the data from the customer
			relation to an instance of the <classname>Customer</classname> class.</para>
			<programlisting><![CDATA[private class CustomerMappingQuery extends MappingSqlQuery {

    public CustomerMappingQuery(DataSource ds) {
        super(ds, "SELECT id, name FROM customer WHERE id = ?");
        super.declareParameter(new SqlParameter("id", Types.INTEGER));
        compile();
    }

    public Object mapRow(ResultSet rs, int rowNumber) throws SQLException {
        Customer cust = new Customer();
        cust.setId((Integer) rs.getObject("id"));
        cust.setName(rs.getString("name"));
        return cust;
    } 
}]]></programlisting>
			<para>
				We provide a constructor for this customer query that takes the
				<interfacename>DataSource</interfacename> as the only parameter. In this constructor
				we call the constructor on the superclass with the
				<interfacename>DataSource</interfacename> and the SQL that should be executed to
				retrieve the rows for this query. This SQL will be used to create a
				<interfacename>PreparedStatement</interfacename> so it may contain place holders for
				any parameters to be passed in during execution. Each parameter must be
				declared using the <literal>declareParameter</literal> method passing in
				an <classname>SqlParameter</classname>. The <classname>SqlParameter</classname>
				takes a name and the JDBC type as defined in
				<classname>java.sql.Types</classname>. After all parameters have been
				defined we call the <literal>compile()</literal> method so the statement
				can be prepared and later be executed.
			</para>
			<programlisting><![CDATA[public Customer getCustomer(Integer id) {
    CustomerMappingQuery custQry = new CustomerMappingQuery(dataSource); 
    Object[] parms = new Object[1];
    parms[0] = id;
    List customers = custQry.execute(parms);
    if (customers.size() > 0) {
        return (Customer) customers.get(0);
    }
    else {
        return null;
    }
}]]></programlisting>
			<para>
				The method in this example retrieves the customer with the id that
				is passed in as the only parameter. After creating an instance of the
				<classname>CustomerMappingQuery</classname> class we create an array of
				objects that will contain all parameters that are passed in. In this
				case there is only one parameter and it is passed in as an
				<classname>Integer</classname>. Now we are ready to execute the query using
				this array of parameters and we get a <literal>List</literal> that
				contains a <classname>Customer</classname> object for each row that was
				returned for our query. In this case it will only be one entry if there
				was a match.
			</para>
		</section>
		<section id="jdbc-SqlUpdate">
			<title><classname>SqlUpdate</classname></title>
			<para>The <classname>SqlUpdate</classname> class encapsulates an SQL update.
			Like a query, an update object is reusable, and like all
			<classname>RdbmsOperation</classname> classes, an update
			can have parameters and is defined in SQL. This class provides a number of
			<methodname>update(..)</methodname> methods analogous to the
			<methodname>execute(..)</methodname> methods of query objects.
			This class is concrete. Although it can be subclassed (for example
			to add a custom update method) it can easily be parameterized by setting
			SQL and declaring parameters.</para>
			<programlisting><![CDATA[import java.sql.Types;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.SqlUpdate;

public class UpdateCreditRating extends SqlUpdate {

    public UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql("update customer set credit_rating = ? where id = ?");
        declareParameter(new SqlParameter(Types.NUMERIC));
        declareParameter(new SqlParameter(Types.NUMERIC));
        compile();
    }

    ]]><lineannotation>/**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */</lineannotation><![CDATA[
    public int run(int id, int rating) {
        Object[] params =
            new Object[] {
                new Integer(rating),
                new Integer(id)};
        return update(params);
    }
}]]></programlisting>
		</section>
		<section id="jdbc-StoredProcedure">
			<title><classname>StoredProcedure</classname></title>
			<para>
				The <classname>StoredProcedure</classname> class is a superclass for object
				abstractions of RDBMS stored procedures. This class is <literal>abstract</literal>,
				and its various <literal>execute(..)</literal> methods have
				<literal>protected</literal> access, preventing use other than through a
				subclass that offers tighter typing.
			</para>
			<para>
				The inherited <literal>sql</literal> property will be the name of the
				stored procedure in the RDBMS. Note that JDBC 3.0 introduces named
				parameters, although the other features provided by this class are
				still necessary in JDBC 3.0.
			</para>
			<para>
				Here is an example of a program that calls a function, <literal>sysdate()</literal>,
				that comes with any Oracle database. To use the stored procedure
				functionality one has to create a class that extends
				<classname>StoredProcedure</classname>. There are no input parameters, but
				there is an output parameter that is declared as a date type using the class
				<classname>SqlOutParameter</classname>. The <literal>execute()</literal>
				method returns a map with an entry for each declared output parameter
				using the parameter name as the key.
			</para>
			<programlisting><![CDATA[import java.sql.Types;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.datasource.*;
import org.springframework.jdbc.object.StoredProcedure;

public class TestStoredProcedure {

    public static void main(String[] args)  {
        TestStoredProcedure t = new TestStoredProcedure();
        t.test();
        System.out.println("Done!");
    }
    
    void test() {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName("oracle.jdbc.OracleDriver");
        ds.setUrl("jdbc:oracle:thin:@localhost:1521:mydb");
        ds.setUsername("scott");
        ds.setPassword("tiger");

        MyStoredProcedure sproc = new MyStoredProcedure(ds);
        Map results = sproc.execute();
        printMap(results);
    }

    private class MyStoredProcedure extends StoredProcedure {
        
        private static final String SQL = "sysdate";

        public MyStoredProcedure(DataSource ds) {
            setDataSource(ds);
            setFunction(true);
            setSql(SQL);
            declareParameter(new SqlOutParameter("date", Types.DATE));
            compile();
        }

        public Map execute() {
            ]]><lineannotation>// the 'sysdate' sproc has no input parameters, so an empty Map is supplied...</lineannotation><![CDATA[
            return execute(new HashMap());
        }
    }

    private static void printMap(Map results) {
        for (Iterator it = results.entrySet().iterator(); it.hasNext(); ) {
            System.out.println(it.next());  
        }
    }
}]]></programlisting>
		<para>
	        Find below an example of a <classname>StoredProcedure</classname> that
	        has two output parameters (in this case Oracle cursors).
		</para>
		<programlisting><![CDATA[import oracle.jdbc.driver.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

public class TitlesAndGenresStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "AllTitlesAndGenres";

    public TitlesAndGenresStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        declareParameter(new SqlOutParameter("genres", OracleTypes.CURSOR, new GenreMapper()));
        compile();
    }

    public Map execute() {
        ]]><lineannotation>// again, this sproc has no input parameters, so an empty Map is supplied...</lineannotation><![CDATA[
        return super.execute(new HashMap());
    }
}]]></programlisting>
			<para>
				Notice how the overloaded variants of the <literal>declareParameter(..)</literal>
				method that have been used in the <classname>TitlesAndGenresStoredProcedure</classname>
				constructor are passed <interfacename>RowMapper</interfacename> implementation
				instances; this is a very convenient and powerful way to reuse existing
				functionality. (The code for the two <interfacename>RowMapper</interfacename>
				implementations is provided below in the interest of completeness.)
			</para>
			<para>
				Firstly the <classname>TitleMapper</classname> class, which simply
				maps a <interfacename>ResultSet</interfacename> to a <classname>Title</classname>
				domain object for each row in the supplied <interfacename>ResultSet</interfacename>.
			</para>
			<programlisting><![CDATA[import com.foo.sprocs.domain.Title;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public final class TitleMapper implements RowMapper {
    
    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
        Title title = new Title();
        title.setId(rs.getLong("id"));
        title.setName(rs.getString("name"));
        return title;
    }
}]]></programlisting>
			<para>Secondly, the <classname>GenreMapper</classname> class, which again simply
			maps a <interfacename>ResultSet</interfacename> to a <classname>Genre</classname>
			domain object for each row in the supplied <interfacename>ResultSet</interfacename>.</para>
			<programlisting><![CDATA[import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

import com.foo.domain.Genre;

public final class GenreMapper implements RowMapper {
    
    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Genre(rs.getString("name"));
    }
}]]></programlisting>
			<para>
				If one needs to pass parameters to a stored procedure (that is
				the stored procedure has been declared as having one or more input
				parameters in its definition in the RDBMS), one would code a
				strongly typed <literal>execute(..)</literal> method which would delegate
				to the superclass' (untyped) <literal>execute(Map parameters)</literal>
				(which has <literal>protected</literal> access); for example:</para>
		<programlisting><![CDATA[import oracle.jdbc.driver.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

public class TitlesAfterDateStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "TitlesAfterDate";
    private static final String CUTOFF_DATE_PARAM = "cutoffDate";

    public TitlesAfterDateStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        compile();
    }

    public Map execute(Date cutoffDate) {
        Map inputs = new HashMap();
        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
        return super.execute(inputs);
    }
}]]></programlisting>
		</section>
		<section id="jdbc-SqlFunction">
			<title><classname>SqlFunction</classname></title>
			<para>
				The <classname>SqlFunction</classname> RDBMS operation class encapsulates an
				SQL "function" wrapper for a query that returns a single row of
				results. The default behavior is to return an <literal>int</literal>, but that
				can be overridden by using the methods with an extra return type parameter.
				This is similar to using the <literal>queryForXxx</literal> methods of
				the <classname>JdbcTemplate</classname>. The advantage with
				<classname>SqlFunction</classname> is that you don't have to create the
				<classname>JdbcTemplate</classname>, it is done behind the scenes.
			</para>
			<para>
				This class is intended to use to call SQL functions that return a
				single result using a query like "select user()" or "select sysdate from
				dual". It is not intended for calling more complex stored functions or
				for using a <classname>CallableStatement</classname> to invoke a stored
				procedure or stored function. (Use the <classname>StoredProcedure</classname> or
				<classname>SqlCall</classname> classes for this type of processing).
			</para>
			<para>
				<classname>SqlFunction</classname> is a concrete class, and there is typically
				no need to subclass it. Code using this package can create an object of this type,
				declaring SQL and parameters, and then invoke the appropriate run method
				repeatedly to execute the function. Here is an example of retrieving the
				count of rows from a table:
			</para>
			<programlisting><![CDATA[public int countRows() {
    SqlFunction sf = new SqlFunction(dataSource, "select count(*) from mytable");
    sf.compile();
    return sf.run();
}]]></programlisting>
		</section>
	</section>
</chapter>