<?xml version="1.0" encoding="UTF-8"?>

<chapter>
  <title>JMS</title>
  <sect1>
    <title>Introduction</title>
    <para>Spring provides a JMS abstraction framework that simplifies
    the use of the JMS API and shields the user from differences between
    the JMS 1.0.2 and 1.1 API.
    </para>


    <para>JMS can be roughly divided into two areas of
    functionality, production and consumption of messages.  In an
    J2EE environment, the ability to consume messages 
    asynchronously is provided for by MessageDriven beans while in a
    standalone application this is provided for by the creation 
    of MessageListeners or ConnectionConsumers.  The functionality 
    in JmsTemplate is focused on producing messages.  Future releases
    of Spring will address asynchronous message consumers in a standalone 
    environment.
    </para>

    <para>The package <literal>org.springframework.jms.core</literal> provides 
    the core funtionality for using JMS.  It contains the JMS 1.1 based
    class <literal>JmsTemplate</literal> and a JMS 1.0.2 subclass
    <literal>JmsTemplate102</literal>.  The JMS template classes simplify 
    the use of the JMS by handling the creation and release of resources, 
    much like the <literal>JdbcTemplate</literal> does for JDBC.  
    The design principal common to Spring template classes is to
    provide helper methods to perform common operations and for more
    sophisticated usage, delegate the essence of the processing 
    task to user implemented callback interfaces.  The JMS template
    follows the same design.  The classes offer various convience methods 
    for the sending of messages, consuming a message synchronously, and 
    exposing the JMS session and message producer to the user.
    </para>

    <para>
    The package <literal>org.springframework.jms.support</literal>
    provides JMSException translation functionality.  The translation
    is converts to the check JMSException hierarchy to a  mirrored hierarchy 
    of unchecked exceptions.  If there are any provider specific subclasses 
    of the checked javax.jms.JMSException, this exception is wrapped in the 
    unchecked JmsException.
    The package <literal>org.springframework.jms.support.converter</literal>
    provides a MessageConverter abstraction to convert between
    Java objects and JMS messages.  The package 
    <literal>org.springframework.jms.support.destination</literal> provides
    various stategies for managing JMS destinations, such as providing
    a service locator for destinations stored in JNDI.
    </para>

    <para>Finally, the package
    <literal>org.springframework.jms.connection</literal>
    provides implemenations of the ConnectionFactory suitable for use
    in stand alone applications and also a PlatformTransactionManager
    for JMS.  This allows for reuse of transactional JMS code across both 
    a J2EE and a standalone environment.
    </para>

  </sect1>    

  <sect1>
    <title>Domain unification</title>
    <para>There are two major releases of the JMS specification, 1.0.2 
    and 1.1.  JMS 1.0.2 defined two types of messaging domains, 
    point-to-point (Queues) and publish/subscribe (Topics).
    The 1.0.2 API reflected these two
    messaging domains by providing a parallel class hierarcy for each domain.
    Consequentially, a client application was domain specific in the use of
    the JMS API.  JMS 1.1 introduced the concept of domain unification 
    that minimized both the functional differences and client API 
    differences between the two domains.  As an example of a functional 
    difference that was removed, if you use a JMS 1.1 provider you can 
    transactionally consume a message from one domain and produce a message
    on the other, unlike JMS 1.0.2
    </para>

    <para>The JMS 1.1 specification is part of J2EE 1.4 and is 
    required by EJB 2.1 and is therefore not yet in widespread use. 
    The JmsTemplate inteface was designed with 
    domain unification in mind in order to provide an easy transition from
    using 1.0.2 to a 1.1 provider.
    </para>
  </sect1>

  <sect1>
    <title>JmsTemplate</title>

    <!-- TODO see if sendRequestReply makes it into 1.1 -->
    <para>Code that uses the the JmsTemplate only needs to implement callback
    interfaces giving them a clearly defined contract.  The 
    <literal>MessageCreator</literal> callback interface creates a message
    given a Session provided by the calling code in JmsTemplate.
    In order to allow
    for more complex usage of the JMS API, the callback  
    <literal>SessionCallback</literal> provides the user with the JMS
    session and the callback <literal>ProducerCallback</literal> exposes
    a Session and MessageProducer pair.
    </para>

    <para>
    The JMS API exposes two types of send methods, one that takes 
    delivery mode, priority, and time-to-live as quality of service 
    (QOS) parameters and one that takes no QOS parameters and uses
    default values.  Since there are many send methods in JmsTemplate, 
    the setting of the QOS parameters has been exposed in the 
    JmsTemplate as bean properties to avoid duplication in the number 
    of send methods.  Similarly, the the timeout value for
    synchronous receive calls is set using the property
    <literal>setReceiveTimeout</literal>.
    </para>
    <para>
    Some JMS providers allow the setting of default QOS
    values administratively through the configuration of the 
    ConnectionFactory.
    This has the effect that a call to MessageProducer's send method
    <literal>send(Destination destination, Message message)</literal>
    will use QOS different default values than those specified in the
    JMS specification.   Therefore, in order to to provide consistent
    managment of the QOS values, the JmsTemplate must be specifically
    enabled to use its own QOS values by setting the boolean property
    <literal>isExplicitQosEnabled</literal> to true.  
    </para>    


    <sect2>
      <title>ConnectionFactory</title>
      <para>The implementations of the JmsTemplate require a reference 
      to a ConnectionFactory.  The ConnectionFactory is part of the JMS
      specification and serves as the entry point for working with JMS.
      It is used by the client application as a factory to 
      create connections with the JMS provider and encapsulaes various 
      configuration parameters, many of which are vendor specific such 
      as SSL configuration options.
      </para>
      <para>
      The ConnectionFactory interface allows the container or a framework
      to provide a managed implementation that provides pooling of
      connection/sessions and participation in declarative transaction
      management.  In order to obtain these features, 
      J2EE containers typically require that you declare a 
      JMS connection factory as a <literal>resource-ref</literal>
      inside the EJB or servlet deployment descriptors.  To ensure
      the use of these features with the JmsTemplate, the client
      application should ensure that it references the managed 
      implementation of the ConnectionFactory. 
      <!-- TODO give examples -->
      </para>
      
      <para>Spring provides an implementation of the ConnectionFactory
      interface, <literal>SingleConnectionFactory</literal>, that 
      will return the same Connection on all
      <literal>createConnection</literal> calls and ignore calls
      to <literal>close.</literal>  This is useful for testing and
      standalone environments to keep the same connection for
      multiple JmsTemplate calls that may span any number of
      transactions.  SingleConnectionFactory takes a reference to
      a standard ConnectionFactory that would typically comes from JNDI.
      </para>
    </sect2>
    <sect2>
      <title>Transaction Management</title>
      <para>Using JMS API inside an managed environment
      when creating a <literal>Session</literal> from a Connection can
      be confusing because the JMS API only has only one factory method to
      create a Session and it requires values for the transaction and
      acknolwegement modes.  In a managed environment, setting these
      values in the responsibility of the container, so these values
      are ignored by the vendors wrapper to the JMS Connection.
      When using the <literal>JmsTemplate</literal> in an unmanaged
      environment you can specify these values
      though the use of the properties <literal>SessionTransacted</literal>
      and <literal>SessionAcknowledgeMode</literal>.
      </para>
      <para>Spring provides a JmsTransactionManager to demarcate
      transactions at a higher level in the application. 
      TODO...
      </para>
    </sect2>
    <sect2>
      <title>Destination Management</title>
      <para>Destinations, like ConnectionFactories, are JMS administered
      objects that can be stored and retrieved in JNDI.  When
      configuring a Spring application context one can use the
      JNDI factory class <literal>JndiObjectFactoryBean</literal> to
      perform dependency injection on your objects references to
      JMS destinations.  However, often this strategy is cumbersome if
      there are a large number of destinations in the application, there
      is a need ot user destination that are created dynamically, or
      when the vendor supports hierarchical destinations that contain
      wildcards in the destination name.
      The interface <literal>DestinationResolver</literal> is used
      to encapsulate various look up stategies.  JmsTemplate contains a 
      reference to an instance of this interface and is used to 
      resolve teh string value of a destination name to a JMS destination
      object.  <literal>DynamicDestinationResolver</literal> is the
      default implementation that accomodates resolving dynamic destinations,
      while the <literal>JndiDestinationResolver</literal> acts as a 
      service locator for destinations contained in JNDI and optionally 
      falls back to the behavior contained in 
      <literal>DynamicDestinationResolver</literal>. 
      </para>
      <para>Quite often the destinations used in a JMS application are only 
      known at runtime and therefore can not be administratively created 
      when the application is deployed.  This is often because there is 
      shared application logic between interacting system components that 
      create destinations at runtime according to a well known naming 
      convention.  While not explicity mentioned 
      in the JMS specification, vendors have provided functionality to 
      create destinations at runtime.   Dynamic destinations are created with
      a name defined by the user which differentiates them from temporary
      destinations and are often not registered in JNDI.  
      The API used to create dynamic destinations varies from provider to
      provider since the properties associated with the destination are
      vendor specific.  However, a simple implementation choice that is
      sometimes made by vendors is to disregard the warnings in the JMS
      specification and to use the <literal>TopicSession</literal> method 
      <literal>createTopic(String topicName)</literal> or the 
      <literal>QueueSession</literal> method 
      <literal>createQueue(String queueName)</literal>
      to create a new destination with default destination properties.
      Depending on the vendor implementation, 
      <literal>DynamicDestinationResolver</literal> may then also 
      create a physical destination instead of only resolving one.
      </para>

      <para>The boolean property <literal>PubSubDomain</literal> is used 
      to configure the implementation
      with knowledge of what JMS domain is being used.  By default the
      value of this property is false, indicating that the point-to-point
      domain, Queues, will be used.  In the 1.0.2 implementation the value
      of this property determines if the JmsTemplate's send operations will
      send a message to a Queue or to a Topic.  This flag has no effect on send
      operations for the 1.1 implementation.  However, in both implementations,
      if this property determines the behavior of resolving dynamic 
      destination in the implementations of 
      <literal>DestinationResolver</literal>.
      </para>

      <para>You can also configure the JmsTemplate with a default destination
      via the proprety <literal>DefaultDestination</literal>.  The default
      destination will be used with send operations that do not refer to a 
      specific destination.
      </para>
    </sect2> 
  </sect1>  



  <sect1>
    <title>Using the JmsTemplate</title>
    <para>To get started using the JmsTemplate you need to select either the
    JMS 1.0.2 implementation <literal>JmsTemplate102</literal> or the
    JMS 1.1 implementation <literal>JmsTemplate11</literal>.  Check your
    JMS provider to determine what version is supported.  When using the
    1.0.2 implementation it is important to configure the boolean
    <literal>PubSubDomain</literal> property to indicate if you want to
    send to Queues or Topics.
    </para>

    <sect2>
      <title>Sending a message</title>
      <para>The JmsTemplate contains many convience methods to send a message.
      There are send methods that specify the destination using a 
      <literal>javax.jms.Destination</literal> object and those that
      specify the destination using a string for use in a JNDI lookup.
      The send method that takes no destination argument uses the
      default destination.  Here is an example that sends a message to 
      a queue using the 1.0.2 implementation.
      </para>
      <programlisting>import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
import org.springframework.jms.core.MessageCreator;

public class JmsQueueSender {

  private JmsTemplate jt;

  private ConnectionFactory connFactory;

  private Queue queue;

  public void simpleSend() {
    jt = new JmsTemplate102(connFactory);
    jt.send(queue, new MessageCreator() {
      public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello queue world");
      }
    });
  }

  public void setConnectionFactory(ConnectionFactory cf) {
      connFactory = cf;
  }

  public void setQueue(Queue q) {
      queue = q;
  }

}
      </programlisting>
      <para>This example uses the <literal>MessageCreator</literal> callback 
      to create a text message from the supplied Session object and the
      JmsTemplate is constructed by passing a reference to a ConnectionFactory.
      A zero argument constuctor and a setConnectionFactory method are 
      also provided and can be used for constructing the instance using
      a BeanFactory.  The method simpleSend modified to send to a topic 
      instead of a queue is shown below
      </para>
    
      <programlisting>
public void simpleSend() {
  jt = new JmsTemplate102(connFactory);
  jt.setPubSubDomain(true);
  jt.send(topic, new MessageCreator() {
     public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello topic world");
     }
  });
}     
      </programlisting>  
      <para>If you created the JmsTemplate and specified a default 
      destination, the <literal>send(MessageCreator c)</literal>
      sends a message to that destination.
      </para>
      <para>The method 
      <literal>send(String destinationName, MessageCreator c)</literal>
      lets you send to a message using a destination registered in JNDI.
      As explained in the section on Destination Management, if 
      dynamic destinations are enabled, it will attempt to create a
      dynamic destination if not found in JNDI.  The method
      <literal>setJndiEnvironment(Properties p)</literal> can be used
      to specify the specific JNDI environment to use for the lookup.
      This provides an alternative to using the resource file jndi.properties
      or Java system properties for this purpose. 
      </para>
    </sect2>

    <sect2>
      <title>Using Message Converters</title>
      <para>Message converters provide you with the ability to marshal
      Java objects to/from a JMS Message.  If a JmsTemplate has a 
      conveter defined, then send operations
      that take a Java object as an argument will perform the conversion 
      from and object to a JMS message on your behalf.  
      Converters allow your application code
      to concentrate on what object is being sent or recieved via JMS and 
      not the details of how it is represented as a JMS message.
      The <literal>Converter</literal> interface interface encapsulates this
      functionality.  The <literal>MapMessageConverter</literal> is a
      provided implementation that converts from a JavaBean to a 
      MapMessage.  Other popular implementations choices for Converters
      are to leverage an existing XML marashalling packages, such as 
      JAXB, Castor, XMLBean, or XStream, to create a TextMessage 
      representing the object.
      </para>
      <para>A simple converter for the purposes of sending a message
      is show below</para>
      <programlisting>
package example.jms;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;

import org.springframework.jms.converter.ConversionException;
import org.springframework.jms.converter.Converter;

public class ToStringConverter implements Converter {

    public Message toMessage(Object object, Session session) {
        try {
            return session.createTextMessage(object.toString());
        } catch (JMSException e) {
            throw new ConversionException(
                "Could not convert object to mesage",
                e);
        }
    }

    public Object fromMessage(Message message) {
        return null;
    }

}
      </programlisting>
      <para>Incorporating this into the JmsQueueSender used previously with
      a Person class with an implementation of toString().
      </para>
      <programlisting>
public void simpleSendCoverter() {
  jt = new JmsTemplate102(connFactory);
  jt.setConverter(new ToStringConverter() );
      
  jt.send(queue, new Person(35.5, 1.829) );
}
      </programlisting>
      <para>To accomodate fine tuning of message properites, headers, and
      body that can not be encapsulated inside a converter class, the
      interface <literal>MessagePostProcessor</literal> gives you access
      to the message after it has been converted, but before it is sent.
      The example below shows how to modify a message header and 
      a property.
      </para>
      <programlisting>
public void sendObject() {
    jt.setConverter(new ToStringConverter());
    jt.send("testQueue", new Person(34.4, 173.2),
        new MessagePostProcessor() {
            
            public Message postProcess(Message message)
                throws JMSException {

                message.setIntProperty("AccountID", 1234);
                message.setJMSCorrelationID("123-00001");

                return message;
            }
        });
}
      </programlisting>      
    </sect2>
    <sect2>
        <title>SessionCallback and ProducerCallback</title>
        <para>
        While the send operations cover many common usage scenarios, there
        are cases when you want to perform multiple operations on a
        JMS Session or MessageProducer.  The <literal>SessionCallback</literal>
        and <literal>ProduerCallback</literal> expose the JMS Session
        and Session/MessageProducer pair respectfully.  The 
        <literal>execute()</literal> methods on JmsTemplate call these
        callback methods.  Here is an example of their use:
        </para>
    </sect2>
    <sect2>
      <title>Synchronous Receive</title>
      <para>
      </para>
    </sect2>
    </sect1>
    
        
</chapter>

