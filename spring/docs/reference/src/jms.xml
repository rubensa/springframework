<?xml version="1.0" encoding="UTF-8"?>
<chapter>
  <title>JMS</title>
  <sect1>
    <title>Introduction</title>
    <para>Spring provides a JMS abstraction framework that simplifies
    the use of the JMS API and shields the user from differences in the 
    JMS API between version 1.0.2 and 1.1.</para>

    <para>The package <literal>org.springframework.jms</literal> provides 
    the core funtionality for using JMS.  It contains the interface 
    <literal>JmsTemplate</literal> that executes the part of the JMS API 
    responsible for creation and release of JMS resources and delegates 
    the essence of the JMS processing task to user implemented callback 
    interfaces.  It also contains the interface <literal>JmsAdmin</literal> 
    for obtaining JMS destinations from JNDI and to create dynamic
    destinations.  Exceptions that are thrown during JMS processing 
    are converted to a mirrored hierarchy of unchecked exceptions.</para>

    <para>JMS functionality can be roughly divided into two areas of
    functionality, producing and consuming of messages.  In an
    J2EE environment, the ability to consume messages is provided for 
    by MessageDriven beans while in a stand-alone application this 
    ability is provided for by the creation of MessageListeners or 
    ConnectionConsumers.  With a few small caveats, producing messages 
    is similar in both a J2EE and stand-alone environment and the JmsTemplate
    can be used in either environment.  Spring also provides various factory 
    classes for use outside a J2EE containers for configuring connections,
    sessions, message producers and messgae consumers.
    </para>
  </sect1>    

  <sect1>
    <title>Domain unification</title>
    <para>There are two major releases of the JMS specification, 1.0.2 
    and 1.1.  JMS 1.0.2 defined two types of messaging domains, 
    point-to-point and publish/subscribe.  The 1.0.2 API reflected these two
    messaging domains by providing a parallel class hierarcy for each domain.
    Consequentially, a client application was domain specific in the use of
    the JMS API.  JMS 1.1 introduced the concept of domain unification 
    that minimized both the functional differences and client API 
    differences between the two domains.  As an example of a functional 
    difference that was removed, if you use the JMS 1.1 API you can 
    transactionally consume a message from one domain and produce a message
    on the other.
    </para>

    <para>The JMS 1.1 specification is part of J2EE 1.4 and is 
    required by EJB 2.1.  The JmsTemplate inteface was designed with 
    domain unification in mind, so that it will be easy to transition from
    using 1.0.2 to a 1.1 provider.</para>
  </sect1>

  <sect1>
    <title>JmsTemplate</title>

    <para>This interface simplifies the use of the JMS by handling the 
    creation and release of resources, much like the 
    <literal>JdbcTemplate</literal> does for JDBC.  The interface
    has implementations for both the JMS 1.0.2 and 1.1 APIs, namely
    <literal>JmsTemplate102</literal> and <literal>JmsTemplate11</literal>,
    and offers various convience methods for the sending of
    messages, consuming a message synchronously, and exposing the
    JMS session and message producer to the user.<para>
    <!-- TODO see if sendRequestReply makes it into 1.1 -->
    </para>
    <para>Code that uses the the JmsTemplate only needs to implement callback
    interfaces giving them a clearly defined contract.  The 
    <literal>MessageCreator</literal> callback interface creates a message
    given a Session provided by the JmsTemplate.  In order to allow
    for more complex usage of the JMS API, the callback  
    <literal>SessionCallback</literal> provides the user with the JMS
    session.  The callback <literal>ProducerCallback</literal> exposes
    the a Session and MessageProducer pair.
    
    <!-- TODO change name of JmsSenderCallback to ProducerCallback -->
    </para>
    <para>
    The JMS API exposes two types of send methods, one that takes 
    delivery mode, priority, and time-to-live as quality of service 
    (QOS) parameters and one that takes no QOS parameters and uses
    default values.  Since there are many send methods in JmsTemplate, 
    the setting of the QOS parameters has been exposed in the 
    JmsTemplate as bean properties to avoid duplication in the number 
    of send methods. 
    </para>
    <para>
    Some JMS providers allow the setting of these default 
    values administratively through the configuration of the 
    ConnectionFactory.
    This has the effect that a call to MessageProducer's send method
    <literal>send(Destination destination, Message message)</literal>
    will use QOS different default values than those specified in the
    JMS specification.   Therefore, in order to to provide consistent
    managment of the QOS values, the JmsTemplate must be specifically
    enabled to use QOS values by setting the boolean property
    <literal>isExplicitQosEnabled</literal> to true.  
    </para>    


    <sect2>
      <title>ConnectionFactory</title>
      <para>The implementations of the JmsTemplate require a reference 
      to a ConnectionFactory.  The ConnectionFactory is part of the JMS
      specification and serves as the entry point for working with JMS.
      It is used by the client application as a factory to 
      create connections with the JMS provider and encapsulaes various 
      configuration parameters, many of which are vendor specific such 
      as SSL configuration options.

      The ConnectionFactory interface allows the container or a framework
      to provide a managed implementation that provides pooling of
      connection/sessions and declarative transaction management.  
      In order to obtain these features, 
      J2EE providers will typically require that you declare a 
      JMS connection factory as a <literal>resource-ref</literal>
      inside the EJB or servlet deployment descriptors.  To ensure
      the use of these features with the JmsTemplate, the client
      application should ensure that it references the managed 
      implementation of the ConnectionFactory. 
      <!-- TODO give examples -->
      </para>
      <para>The use of a managed connection factory results in somewhat
      awkwared usage of the JMS API inside an EJB when creating a 
      <literal>Session</literal>.  This is because the values for 
      transaction enabled and session acknowlegment mode are ignored when
      calling the managed connection's
      <literal>createSession(boolean transacted, int acknowledgeMode)
      </literal> method.
      For use with an unmanaged JMS API, <literal>JmsTemplate102</literal>
      and <literal>JmsTemplate11</literal> allow you to specify these values
      though the use of the properties <literal>SessionTransacted</literal>
      and <literal>SessionAcknowledgeMode</literal>.
      </para>
    </sect2>
    <sect2>
      <title>Destination Management</title>
      <para>Quite often the destinations used in a JMS application are only 
      known at runtime and therefore can not be administratively created 
      when the application is deployed.  This is often because there is 
      shared application logic between interacting system components that 
      create destinations at runtime according to a well known naming 
      convention determined by the user.  While not explicity mentioned 
      in the JMS specification, vendors have provided functionality to 
      create destination at runtime.   Dynamic destinations are created with
      a name defined by the user, which differentiates them from temporary
      destinations, and are often not registered in JNDI.  When used for 
      sending messages, JmsTemplate can be configured to create a dynamic 
      destination if a destination of the given name is not already registered
      with JNDI.  Dynamic destination support is enabled by setting the
      boolen property <literal>DynamicDestinationEnabled</literal> to true.  
      Since this behavior is vendor dependent, the JmsTemplate delegates 
      the responsibility of creating dynamic destinations to implementations 
      of the <literal>JmsAdmin</literal> interface.  The default 
      implementation of JmsAdmin is <literal>DefaultJmsAdmin</literal> and 
      uses the <literal>TopicSession</literal> method 
      <literal>createTopic(String topicName)</literal> or the 
      <literal>QueueSession</literal> method 
      <literal>createQueue(String queueName)</literal> to create dynamic 
      destinations since this a common implementation choice made by JMS
      providers.  Other implementations of JmsAdmin can be created to 
      support the needs of your specific JMS provider.
      </para>

      <para>The boolean property <literal>PubSubDomain</literal> is used 
      to configure the implementation
      with knowledge of what JMS domain is being used.  By default the
      value of this property is false, indicating that the point-to-point
      domain, Queues, will be used.  In the 1.0.2 implementation the value
      of this property determines if the JmsTemplate's send operations will
      send a message to a Queue or to a Topic.  This flag has no effect on send
      operations for the 1.1 implementation.  However, in both implementations,
      if the property <literal>DynamicDestinationEnabled</literal> is true,
      when sending to a destination that does not yet exist in JNDI
      the value of <literal>PubSubDomain</literal> flag determines the 
      type of destination to create dynamically.
      </para>
      
      <para>The DefaultJmsAdmin class also acts as a service locator object 
      to abstract the JNDI lookup for destinations and to cache previously 
      resolved destinations.  Of course it is also possible to directly 
      configure a bean with a JMS destination though dependency injection 
      using the Spring application context.  The service locator acts as a 
      convience for the case when an applications uses many destinations,
      or when the vendor support as hierarchical destinations with
      support for wildcards in the destination name.
      </para>
      <para>You can also configure the JmsTemplate with a default destination
      via the proprety <literal>DefaultDestination</literal>.  The default
      destination will be used with send operations that do not refer to a 
      specific destination.
      </para>
    </sect2> 
  </sect1>  



  <sect1>
    <title>Using the JmsTemplate</title>
    <para>To get started using the JmsTemplate you need to select either the
    JMS 1.0.2 implementation <literal>JmsTemplate102</literal> or the
    JMS 1.1 implementation <literal>JmsTemplate11</literal>.  Check your
    JMS provider to determine what version is supported.  When using the
    1.0.2 implementation it is important to configure the boolean
    <literal>PubSubDomain</literal> property to indicate if you want to
    send to Queues or Topics.
    </para>

    <para>The JmsTemplate contains many convience methods to send a message.
    There are send methods that specify the destination using a 
    <literal>javax.jms.Destination</literal> object and those that
    specify the destination using a string for use in a JNDI lookup.
    The send method that takes no destination argument uses the
    default destination.  Here is an example that sends a message to 
    a queue using the 1.0.2 implementation of the template.
    </para>
    <programlisting>import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.JmsTemplate;
import org.springframework.jms.JmsTemplate102;
import org.springframework.jms.MessageCreator;

public class JmsQueueSender {

    private JmsTemplate jt;

    private ConnectionFactory connFactory;

    private Queue queue;

    public void simpleSend() {
        jt = new JmsTemplate102(connFactory);
        jt.send(queue, new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage("hello queue world");
            }
        });
    }

    public void setConnectionFactory(ConnectionFactory cf) {
        connFactory = cf;
    }

    public void setQueue(Queue q) {
                queue = q;
    }

}
    </programlisting>
    <para>This example uses the <literal>MessgaeCreator</literal> callback 
    to create a text message from the supplied Session object.  Also, the
    JmsTemplate is constructed passing a reference to the ConnectionFactory.
    A zero argument constuctor and a setConnectionFactory method are 
    also provided and can be used for constructing the instance using
    a BeanFactory.  The method simpleSend modified to send to a topic 
    instead of a queue is shown below
    </para>
    
    <programlisting>
        public void simpleSend() {
                jt = new JmsTemplate102(connFactory);
                jt.setPubSubDomain(true);
                jt.send(topic, new MessageCreator() {
                        public Message createMessage(Session session) throws JMSException {
                                return session.createTextMessage("hello topic world");
                        }
                });
        }     
    </programlisting>  
    </sect1>

  <sect1>
    <title>MessageConverters</title>
  </sect1>



        
</chapter>

