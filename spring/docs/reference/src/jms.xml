<?xml version="1.0" encoding="UTF-8"?>

<chapter>
  <title>JMS</title>
  <sect1>
    <title>Introduction</title>
    <para>Spring provides a JMS abstraction framework that simplifies
    the use of the JMS API and shields the user from differences in the 
    JMS API between versions 1.0.2 and 1.1.
    </para>

    <para>The package <literal>org.springframework.jms</literal> provides 
    the core funtionality for using JMS.  It contains the interface 
    <literal>JmsTemplate</literal> and implementations that execute the 
    part of the JMS API 
    responsible for creation and release of JMS resources and delegates 
    the essence of the JMS processing task to user implemented callback 
    interfaces.  It also contains the interface <literal>JmsAdmin</literal> 
    for obtaining JMS destinations from JNDI creating dynamic
    destinations.  Exceptions that are thrown during JMS processing 
    are converted to a mirrored hierarchy of unchecked exceptions.  If
    there are any provider specific subclasses of the checked 
    javax.jms.JMSException, then it is wrapped in the unchecked JmsException.
    </para>

    <para>JMS functionality can be roughly divided into two areas of
    functionality, producing and consuming of messages.  In an
    J2EE environment, the ability to consume messages is provided for 
    by MessageDriven beans while in a stand-alone application this 
    ability is provided for by the creation of MessageListeners or 
    ConnectionConsumers.  With a few small caveats, producing messages 
    is similar in both a J2EE and stand-alone environment and the JmsTemplate
    can be used in either environment.  Spring also provides various factory 
    classes for use outside a J2EE containers for configuring connections,
    sessions, message producers and messgae consumers.
    </para>
  </sect1>    

  <sect1>
    <title>Domain unification</title>
    <para>There are two major releases of the JMS specification, 1.0.2 
    and 1.1.  JMS 1.0.2 defined two types of messaging domains, 
    point-to-point (Queues) and publish/subscribe (Topics).
    The 1.0.2 API reflected these two
    messaging domains by providing a parallel class hierarcy for each domain.
    Consequentially, a client application was domain specific in the use of
    the JMS API.  JMS 1.1 introduced the concept of domain unification 
    that minimized both the functional differences and client API 
    differences between the two domains.  As an example of a functional 
    difference that was removed, if you use a JMS 1.1 provider you can 
    transactionally consume a message from one domain and produce a message
    on the other, unlike JMS 1.0.2
    </para>

    <para>The JMS 1.1 specification is part of J2EE 1.4 and is 
    required by EJB 2.1 however these is not yet in widespread use. 
    The JmsTemplate inteface was designed with 
    domain unification in mind in order to provide an easy transition from
    using 1.0.2 to a 1.1 provider.
    </para>
  </sect1>

  <sect1>
    <title>JmsTemplate</title>

    <para>This interface simplifies the use of the JMS by handling the 
    creation and release of resources, much like the 
    <literal>JdbcTemplate</literal> does for JDBC.  The interface
    has implementations for both the JMS 1.0.2 and 1.1 APIs, namely
    <literal>JmsTemplate102</literal> and <literal>JmsTemplate11</literal>,
    and offers various convience methods for the sending of
    messages, consuming a message synchronously, and exposing the
    JMS session and message producer to the user.
    </para>
    <!-- TODO see if sendRequestReply makes it into 1.1 -->
    <para>Code that uses the the JmsTemplate only needs to implement callback
    interfaces giving them a clearly defined contract.  The 
    <literal>MessageCreator</literal> callback interface creates a message
    given a Session provided by the calling code in JmsTemplate.
    In order to allow
    for more complex usage of the JMS API, the callback  
    <literal>SessionCallback</literal> provides the user with the JMS
    session and the callback <literal>ProducerCallback</literal> exposes
    a Session and MessageProducer pair.
    
    <!-- TODO change name of JmsSenderCallback to ProducerCallback -->
    </para>
    <para>
    The JMS API exposes two types of send methods, one that takes 
    delivery mode, priority, and time-to-live as quality of service 
    (QOS) parameters and one that takes no QOS parameters and uses
    default values.  Since there are many send methods in JmsTemplate, 
    the setting of the QOS parameters has been exposed in the 
    JmsTemplate as bean properties to avoid duplication in the number 
    of send methods. 
    </para>
    <para>
    Some JMS providers allow the setting of these default 
    values administratively through the configuration of the 
    ConnectionFactory.
    This has the effect that a call to MessageProducer's send method
    <literal>send(Destination destination, Message message)</literal>
    will use QOS different default values than those specified in the
    JMS specification.   Therefore, in order to to provide consistent
    managment of the QOS values, the JmsTemplate must be specifically
    enabled to use QOS values by setting the boolean property
    <literal>isExplicitQosEnabled</literal> to true.  
    </para>    


    <sect2>
      <title>ConnectionFactory</title>
      <para>The implementations of the JmsTemplate require a reference 
      to a ConnectionFactory.  The ConnectionFactory is part of the JMS
      specification and serves as the entry point for working with JMS.
      It is used by the client application as a factory to 
      create connections with the JMS provider and encapsulaes various 
      configuration parameters, many of which are vendor specific such 
      as SSL configuration options.

      The ConnectionFactory interface allows the container or a framework
      to provide a managed implementation that provides pooling of
      connection/sessions and participation in 
      declarative transaction management.  
      In order to obtain these features, 
      J2EE containers typically require that you declare a 
      JMS connection factory as a <literal>resource-ref</literal>
      inside the EJB or servlet deployment descriptors.  To ensure
      the use of these features with the JmsTemplate, the client
      application should ensure that it references the managed 
      implementation of the ConnectionFactory. 
      <!-- TODO give examples -->
      </para>
      <para>The use of a managed connection factory results in somewhat
      awkwared usage of the JMS API inside an EJB when creating a 
      <literal>Session</literal>.  This is because the values for 
      transaction enabled and session acknowlegment mode are ignored when
      calling the managed connection's
      <literal>createSession(boolean transacted, int acknowledgeMode)
      </literal> method.
      For use with an unmanaged JMS API, <literal>JmsTemplate102</literal>
      and <literal>JmsTemplate11</literal> allow you to specify these values
      though the use of the properties <literal>SessionTransacted</literal>
      and <literal>SessionAcknowledgeMode</literal>.
      </para>
    </sect2>
    <sect2>
      <title>Destination Management</title>
      <para>Quite often the destinations used in a JMS application are only 
      known at runtime and therefore can not be administratively created 
      when the application is deployed.  This is often because there is 
      shared application logic between interacting system components that 
      create destinations at runtime according to a well known naming 
      convention.  While not explicity mentioned 
      in the JMS specification, vendors have provided functionality to 
      create destinations at runtime.   Dynamic destinations are created with
      a name defined by the user, which differentiates them from temporary
      destinations, and are often not registered in JNDI.  When used for 
      sending messages, JmsTemplate can be configured to create a dynamic 
      destination if a destination of the given name is not already registered
      with JNDI.  Dynamic destination support is enabled by setting the
      boolen property <literal>DynamicDestinationEnabled</literal> to true.  
      Since this behavior is vendor dependent, the JmsTemplate delegates 
      the responsibility of creating dynamic destinations to implementations 
      of the <literal>JmsAdmin</literal> interface.  The default 
      implementation of JmsAdmin is <literal>DefaultJmsAdmin</literal> and 
      uses the <literal>TopicSession</literal> method 
      <literal>createTopic(String topicName)</literal> or the 
      <literal>QueueSession</literal> method 
      <literal>createQueue(String queueName)</literal> to create dynamic 
      destinations since this a common implementation choice made by JMS
      providers.  Other implementations of JmsAdmin can be created to 
      support the needs of your specific JMS provider, for example BEA
      uses a JmsHelper class for this purpose.  The property 
      <literal>JmsAdmin</literal> on JmsTemplate can be used to set 
      an implementation other than the 
      provided <literal>DefaultJmsAdmin</literal>.
      </para>

      <para>The boolean property <literal>PubSubDomain</literal> is used 
      to configure the implementation
      with knowledge of what JMS domain is being used.  By default the
      value of this property is false, indicating that the point-to-point
      domain, Queues, will be used.  In the 1.0.2 implementation the value
      of this property determines if the JmsTemplate's send operations will
      send a message to a Queue or to a Topic.  This flag has no effect on send
      operations for the 1.1 implementation.  However, in both implementations,
      if the property <literal>DynamicDestinationEnabled</literal> is true,
      when sending to a destination that does not yet exist in JNDI
      the value of <literal>PubSubDomain</literal> flag determines the 
      type of destination to create dynamically.
      </para>
      
      <para>The DefaultJmsAdmin class also acts as a service locator object 
      to abstract the JNDI lookup for destinations and to cache previously 
      resolved destinations.  Of course it is also possible to directly 
      configure a bean with a JMS destination though dependency injection 
      using the Spring application context.  The service locator acts as a 
      convience for the case when an application uses many destinations,
      or when the vendor supports hierarchical destinations that contain
      wildcards in the destination name.
      </para>
      <para>You can also configure the JmsTemplate with a default destination
      via the proprety <literal>DefaultDestination</literal>.  The default
      destination will be used with send operations that do not refer to a 
      specific destination.
      </para>
    </sect2> 
  </sect1>  



  <sect1>
    <title>Using the JmsTemplate</title>
    <para>To get started using the JmsTemplate you need to select either the
    JMS 1.0.2 implementation <literal>JmsTemplate102</literal> or the
    JMS 1.1 implementation <literal>JmsTemplate11</literal>.  Check your
    JMS provider to determine what version is supported.  When using the
    1.0.2 implementation it is important to configure the boolean
    <literal>PubSubDomain</literal> property to indicate if you want to
    send to Queues or Topics.
    </para>

    <sect2>
      <title>Sending a message</title>
      <para>The JmsTemplate contains many convience methods to send a message.
      There are send methods that specify the destination using a 
      <literal>javax.jms.Destination</literal> object and those that
      specify the destination using a string for use in a JNDI lookup.
      The send method that takes no destination argument uses the
      default destination.  Here is an example that sends a message to 
      a queue using the 1.0.2 implementation.
      </para>
      <programlisting>import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.JmsTemplate;
import org.springframework.jms.JmsTemplate102;
import org.springframework.jms.MessageCreator;

public class JmsQueueSender {

  private JmsTemplate jt;

  private ConnectionFactory connFactory;

  private Queue queue;

  public void simpleSend() {
    jt = new JmsTemplate102(connFactory);
    jt.send(queue, new MessageCreator() {
      public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello queue world");
      }
    });
  }

  public void setConnectionFactory(ConnectionFactory cf) {
      connFactory = cf;
  }

  public void setQueue(Queue q) {
      queue = q;
  }

}
      </programlisting>
      <para>This example uses the <literal>MessageCreator</literal> callback 
      to create a text message from the supplied Session object and the
      JmsTemplate is constructed by passing a reference to a ConnectionFactory.
      A zero argument constuctor and a setConnectionFactory method are 
      also provided and can be used for constructing the instance using
      a BeanFactory.  The method simpleSend modified to send to a topic 
      instead of a queue is shown below
      </para>
    
      <programlisting>
public void simpleSend() {
  jt = new JmsTemplate102(connFactory);
  jt.setPubSubDomain(true);
  jt.send(topic, new MessageCreator() {
     public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello topic world");
     }
  });
}     
      </programlisting>  
      <para>If you created the JmsTemplate and specified a default 
      destination, the <literal>send(MessageCreator c)</literal>
      sends a message to that destination.
      </para>
      <para>The method 
      <literal>send(String destinationName, MessageCreator c)</literal>
      lets you send to a message using a destination registered in JNDI.
      As explained in the section on Destination Management, if 
      dynamic destinations are enabled, it will attempt to create a
      dynamic destination if not found in JNDI.  The method
      <literal>setJndiEnvironment(Properties p)</literal> can be used
      to specify the specific JNDI environment to use for the lookup.
      This provides an alternative to using the resource file jndi.properties
      or Java system properties for this purpose. 
      </para>
    </sect2>

    <sect2>
      <title>Using Message Converters</title>
      <para>Message converters provide you with the ability to marshal
      Java objects to/from a JMS Message.  If a JmsTemplate has a 
      conveter defined, then send operations
      that take a Java object as an argument will perform the conversion 
      to a JMS message on your behalf.  Converters allow your application code
      to concentrate on what object is being sent or recieved via JMS and 
      not the details of how it is represented as a JMS message.
      The <literal>Converter</literal> interface interface encapsulates this
      functionality.  The <literal>MapMessageConverter</literal> is a
      provided implementation that converts from a JavaBean to a 
      MapMessage.
      </para>
      <para>A simple converter for the purposes of sending a message
      is show below</para>
      <programlisting>
package example.jms;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;

import org.springframework.jms.converter.ConversionException;
import org.springframework.jms.converter.Converter;

public class ToStringConverter implements Converter {

    public Message toMessage(Object object, Session session) {
        try {
            return session.createTextMessage(object.toString());
        } catch (JMSException e) {
            throw new ConversionException(
                "Could not convert object to mesage",
                e);
        }
    }

    public Object fromMessage(Message message) {
        return null;
    }

}
      </programlisting>
      <para>Incorporating this into the JmsQueueSender used previously with
      a Person class with an implementation of toString().
      </para>
      <programlisting>
public void simpleSendCoverter() {
  jt = new JmsTemplate102(connFactory);
  jt.setConverter(new ToStringConverter() );
      
  jt.send(queue, new Person(35.5, 1.829) );
}
      </programlisting>
      <para>To accomodate fine tuning of message properites, headers, and
      body that can not be encapsulated inside a converter class, the
      interface <literal>MessagePostProcessor</literal> gives you access
      to the message after it has been converted, but before it is sent.
      </para>
    </sect2>
    <sect2>
        <title>SessionCallback and ProducerCallback</title>
        <para>
        While the send operations cover many common usage scenarios, there
        are cases when you want to perform multiple operations on a
        JMS Session or MessageProducer.  The <literal>SessionCallback</literal>
        and <literal>ProduerCallback</literal> expose the JMS Session
        and Session/MessageProducer pair respectfully.  The 
        <literal>exeucte()</literal> methods on JmsTemplate call these
        callback methods.
        </para>
    </sect2>
    <sect2>
      <title>Synchronous Receive</title>
      <para>
      </para>
    </sect2>
    </sect1>
    


  <sect1>
    <title>Factory Classes</title>
    <para>A collection of factory classes are provided to that you can
    create instances of a JMS Connection, Session, MessageProducer, and 
    MessageConsumer and expose them inside an application context.  
    This can be an effective means for configuring a 
    JMS based application.
    </para>
    <para>
    The factories are for use only with JMS 1.1 providers.
    The <literal>JmsConnectionFactoryBean</literal> will return
    a singleton/non-prototype connection and requires a reference to a 
    ConnectionFactory. (There is an unfortunate naming convention clash
    since Spring uses '&lt;type&gt;FactoryBean' to indicate creation of object
    of a given type and JMS contains an interface named ConnectionFactory).
    Setting the <literal>ClientID</literal> property of the connection
    should only be done if it is not configured in a client-specific
    ConnectionFactory implementation.
    The <literal>JmsSessionFactoryBean</literal> will return
    a singleton/non-prototype session and requires a reference 
    to a Connection. 
    The <literal>JmsProducerFactoryBean</literal> creates a new prototype
    instance of MessageProducer.
    You can specify the destination, all the various QOS properties, 
    disable message ID and timestamp creation.
    The <literal>JmsConsumerFactoryBean</literal> creates a new
    prototype instance of a MessageConsumer and requires a reference
    to a session and destination.  You can also create a durable subscriber
    to a topic.
    </para> 
    <para>
    The following application context listing shows how you can use
    the factory classes to send a message.
    </para>
    <programlisting>
&lt;beans&gt;
                
    &lt;bean id="jmsSendExample" class="example.jms.JmsSendExample"&gt;
            &lt;property name="session"&gt;&lt;ref bean="jmsSession"/&gt;&lt;/property&gt;
            &lt;property name="producer"&gt;&lt;ref bean="jmsProducer"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;bean id="jmsProducer" class="org.springframework.jms.JmsProducerFactoryBean"&gt;
            &lt;property name="session"&gt;&lt;ref bean="jmsSession"/&gt;&lt;/property&gt;                  
            &lt;property name="destination"&gt;&lt;ref bean="queue"/&gt;&lt;/property&gt;
            &lt;property name="priority"&gt;&lt;value&gt;6&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;bean id="queue" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
            &lt;property name="jndiName"&gt;&lt;value&gt;testQueueJndi&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;bean id="jmsSession" class="org.springframework.jms.JmsSessionFactoryBean"&gt;
            &lt;property name="transacted"&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;
            &lt;property name="connection"&gt;&lt;ref bean="jmsConnection"/&gt;&lt;/property&gt;            
    &lt;/bean&gt;
    
    &lt;bean id="jmsConnection" class="org.springframework.jms.JmsConnectionFactoryBean"&gt;
            &lt;property name="connectionFactory"&gt;&lt;ref bean="jmsConnFactory"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;bean id="jmsConnFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
            &lt;property name="jndiName"&gt;&lt;value&gt;QueueConnectionFactory&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;    
    </programlisting>
    <para>And here is an application that uses this configuration file:
    </para>
    <programlisting>
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageProducer;
import javax.jms.Session;


public class JmsSendExample
{
    
    private Session session;
    
    private MessageProducer producer;

    public void setProducer(MessageProducer producer)
    {
        this.producer = producer;
    }

    public void setSession(Session s)
    {
        session = s;
    }

    public void sendMessage() throws JMSException
    {
        Message m = session.createTextMessage("Hello World!");
        producer.send(m);
        System.out.println("Sent message = " + m);
    }
    
    public static void main(String[] args) throws JMSException
    {
        String ctxFile = "/example/jms/appContext.xml";
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(ctxFile);
        JmsSendExample sendExample = (JmsSendExample) ctx.getBean("jmsSendExample");
        sendExample.sendMessage();
        ctx.getBeanFactory().destroySingletons();
    }
    
}
    </programlisting>
    <para>Similarly, to recieve a message add the following to the 
    application context description
    </para>
    <programlisting>
&lt;bean id="jmsConsumer" class="org.springframework.jms.JmsConsumerFactoryBean"&gt;
        &lt;property name="session"&gt;&lt;ref bean="jmsSession"/&gt;&lt;/property&gt;
        &lt;property name="destination"&gt;&lt;ref bean="queue"/&gt;&lt;/property&gt;
        &lt;property name="messageListener"&gt;&lt;ref bean="msgListener"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="msgListener" class="example.jms.JmsMsgListener"&gt;
&lt;/bean&gt;    
    </programlisting>
    <para>
    The java code to receive the message is then
    </para>
    <programlisting>
public static void main(String[] args) throws Exception {
  String ctxFile = "/example/jms/appContext.xml";
  ApplicationContext ctx = new ClassPathXmlApplicationContext(ctxFile);      
  Connection c = (Connection) ctx.getBean("jmsConnection");
  c.start();
  System.out.println("Listening for messages");      
  Thread.sleep(100000);
}    
    </programlisting>
    <para>A durable consumber on for a topic is specified by setting the
    <literal>isDurableSubscriber</literal> property to true.  Durable
    Subscriptions only apply to the publish-subscribe messaging domain
    and you must provide a durable identity for the subscriber with
    the property <literal>DurableIdentity</literal>.
    </para>
    <para>
    The full lifecycle management of starting and stopping the JMS Connection
    after all beans have been initialized is left to the application code.
    You should avoid creating initialization life cycle methods on beans 
    managed by Spring that may start
    the JMS connection.  This is because messages can be delivered before the 
    BeanFactory has finished processing all the objects.  Some helper classes
    for this case are in the sandbox under the package 
    org.springframework.service.
    </para>
  </sect1>


        
</chapter>

