<?xml version="1.0" encoding="UTF-8"?>
<chapter>
  <title>JMS</title>
  <sect1>
    <title>Introduction</title>
    <para>Spring provides a JMS abstraction framework that simplifies
    the use of the JMS API and shields the user from differences in the 
    JMS API between version 1.0.2 and 1.1.</para>

    <para>The package <literal>org.springframework.jms</literal> provides 
    the core funtionality for using JMS.  It contains the interface 
    <literal>JmsTemplate</literal> that executes the part of the JMS API 
    responsible for creation and release of JMS resources and delegates 
    the essence of the JMS processing task to user implemented callback 
    interfaces.  It also contains the interface <literal>JmsAdmin</literal> 
    for obtaining JMS destinations from JNDI and to create dynamic
    destinations.  Exceptions that are thrown during JMS processing 
    are converted to a mirrored hierarchy of unchecked exceptions.</para>

    <para>JMS functionality can be roughly divided into two areas of
    functionality, producing and consuming of messages.  In an
    J2EE environment, the ability to consume messages is provided for 
    by MessageDriven beans while in a stand-alone application this 
    ability is provided for by the creation of MessageListeners or 
    ConnectionConsumers.  With a few small caveats, producing messages 
    is similar in both a J2EE and stand-alone environment and the JmsTemplate
    can be used in either environment.  Spring also provides various factory 
    classes for use outside a J2EE containers for configuring connections,
    sessions, message producers and messgae consumers.
    </para>
  </sect1>    

  <sect1>
    <title>Domain unification</title>
    <para>There are two major releases of the JMS specification, 1.0.2 
    and 1.1.  JMS 1.0.2 defined two types of messaging domains, 
    point-to-point and publish/subscribe.  The 1.0.2 API reflected these two
    messaging domains by providing a parallel class hierarcy for each domain.
    Consequentially, a client application was domain specific in the use of
    the JMS API.  JMS 1.1 introduced the concept of domain unification 
    that minimized both the functional differences and client API 
    differences between the two domains.  As an example of a functional 
    difference that was removed, if you use the JMS 1.1 API you can 
    transactionally consume a message from one domain and produce a message
    on the other.
    </para>

    <para>The JMS 1.1 specification is part of J2EE 1.4 and is 
    required by EJB 2.1.  The JmsTemplate inteface was designed with 
    domain unification in mind, so that it will be easy to transition from
    using 1.0.2 to a 1.1 provider.</para>
  </sect1>

  <sect1>
    <title>JmsTemplate</title>

    <para>This interface simplifies the use of the JMS by handling the 
    creation and release of resources, much like the 
    <literal>JdbcTemplate</literal> does for JDBC.  The interface
    has implementations for both the JMS 1.0.2 and 1.1 APIs, namely
    <literal>JmsTemplate102</literal> and <literal>JmsTemplate11</literal>,
    and offers various convience methods for the sending of
    messages, consuming a message synchronously, and exposing the
    JMS session and message producer to the user.<para>
    <!-- TODO see if sendRequestReply makes it into 1.1 -->
    </para>
    <para>Code that uses the the JmsTemplate only needs to implement callback
    interfaces giving them a clearly defined contract.  The 
    <literal>MessageCreator</literal> callback interface creates a message
    given a Session provided by the JmsTemplate.  In order to allow
    for more complex usage of the JMS API, the callback  
    <literal>SessionCallback</literal> provides the user with the JMS
    session.  The callback <literal>JmsSenderCallback</literal> exposes
    the a Session and MessageProduer pair.
    
    <!-- TODO change name of JmsSenderCallback to something more meaningful. -->
    </para>
    <para>
    The JMS API exposes two types of send methods, one that takes 
    delivery mode, priority, and time-to-live as quality of service 
    (QOS) parameters and one that takes no QOS parameters and uses
    default values.  Since there are many send methods in JmsTemplate, 
    the setting of the QOS parameters has been exposed in the 
    JmsTemplate as bean properties to avoid duplication in the number 
    of send methods. 
    </para>
    <para>
    Some JMS providers allow the setting of these default 
    values administratively through the configuration of the 
    ConnectionFactory.
    This has the effect that a call to MessageProducer's send method
    <literal>send(Destination destination, Message message)</literal>
    will use QOS different default values than those specified in the
    JMS specification.   Therefore, in order to to provide consistent
    managment of the QOS values, the JmsTemplate must be specifically
    enabled to use QOS values by setting the boolean property
    <literal>isExplicitQosEnabled</literal> to true.  
    </para>    


    <sect2>
      <title>ConnectionFactory</title>
      <para>The implementations of the JmsTemplate require a reference 
      to a ConnectionFactory.  The ConnectionFactory is part of the JMS
      specification and serves as the entry point for working with JMS.
      It is used by the client application as a factory to 
      create connections with the JMS provider and encapsulaes various 
      configuration parameters, many of which are vendor specific such 
      as SSL configuration options.

      The ConnectionFactory interface allows the container or a framework
      to provide a managed implementation that provides pooling of
      connection/sessions and declarative transaction management.  
      In order to obtain these features, 
      J2EE providers will typically require that you declare a 
      JMS connection factory as a <literal>resource-ref</literal>
      inside the EJB or servlet deployment descriptors.  To ensure
      the use of these features with the JmsTemplate, the client
      application should ensure that it references the managed 
      implementation of the ConnectionFactory. 
      <!-- TODO give examples -->
      </para>
      <para>The use of a managed connection factory results in somewhat
      awkwared usage of the JMS API inside an EJB when creating a 
      <literal>Session</literal>.  This is because the values for 
      transaction enabled and session acknowlegment mode are ignored when
      calling the managed connection's
      <literal>createSession(boolean transacted, int acknowledgeMode)
      </literal> method.
      For use with an unmanaged JMS API, <literal>JmsTemplate102</literal>
      and <literal>JmsTemplate11</literal> allow you to specify these values
      though the use of the properties <literal>SessionTransacted</literal>
      and <literal>SessionAcknowledgeMode</literal>.
      </para>
    </sect2>
    <sect2>
      <title>Dynamic Destinations</title>
      <!-- Talk about dynamic destination and the JmsAdmin interface -->
    </sect2> 
  </sect1>  



  <sect1>
    <title>Using the JmsTemplate</title>
    <!-- Go over the various send methods and callback -->
    <!-- Go over setting the domain flag isPubSubEnabled -->
  </sect1>

  <sect1>
    <title>MessageConverters</title>
  </sect1>

  <sect1>
    <title>Use in a J2EE container</title>
  </sect1>

  <sect1>
    <title>Use outside a J2EE container</title>
  </sect1>


        
</chapter>

