<?xml version="1.0" encoding="UTF-8"?>
<chapter id="jmx">
	<title>JMX Support</title>
	<section id="jmx-introduction">
		<title>Introduction</title>
		<para>
			The JMX support in Spring provides you with the features to easily and transparently integrate
			your Spring application into a JMX infrastructure. Specifically, Spring's JMX support provides
			four core features:
		</para>
		<itemizedlist>
			<listitem>
				<para>The automatic registration of <emphasis>any</emphasis> Spring bean as a JMX MBean</para>
			</listitem>
			<listitem>
				<para>A flexible mechanism for controlling the management interface of your beans</para>
			</listitem>
			<listitem>
				<para>The declarative exposure of MBeans over remote, JSR-160 connectors</para>
			</listitem>
			<listitem>
				<para>The simple proxying of both local and remote MBean resources</para>
			</listitem>
		</itemizedlist>
		<para>
			These features are designed to work without coupling your application components to either Spring
			or JMX interfaces and classes. Indeed, for the most part your application classes need not be aware
			of either Spring or JMX in order to take advantage of the Spring JMX features.
		</para>
        <para>
            This chapter is not an introduction to JMX... it doesn't try to explain the motivations of why one
            might want to use JMX (or indeed what the letters JMX actually stand for). If you are new to JMX
            and want an explanation of just what JMX is and what value it can add to your applications, check
            out the section entitled <xref linkend="jmx-resources"/> at the end of this chapter.
        </para>
	</section>
	<section id="jmx-exporting">
		<title>Exporting your beans to JMX</title>
		<para>
			The core class in the Spring JMX framework is the <classname>MBeanExporter</classname>.
			This class is responsible for taking your Spring beans and registering them with the JMX
			<classname>MBeanServer</classname>. For example, consider the simple bean class shown below:
		</para>
		<programlisting><![CDATA[package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;

    private int age;

    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

}]]></programlisting>
		<para>
			To expose the properties and methods of this bean as attributes and	operations of an
			MBean you simply configure an instance of the <classname>MBeanExporter</classname> class
			in your configuration file and pass in the bean as shown below:
		</para>
		<programlisting><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>
		<para>
			The pertinent bean definition from the above configuration snippet is the
			<literal>exporter</literal> bean. The <literal>beans</literal> property tells the
			<classname>MBeanExporter</classname> exactly which of your beans must be exported to
			the JMX <classname>MBeanServer</classname>. In the default configuration, the
			key of each entry in the <literal>beans</literal> <classname>Map</classname> is used as
			the <classname>ObjectName</classname> for the bean referenced by the corresponding
			entry value. This behaviour can be changed as described in section <xref linkend="jmx-naming"/>.
		</para>
		<para>
			With this configuration the <literal>testBean</literal> bean is exposed as an MBean under
			the <classname>ObjectName</classname> <literal>bean:name=testBean1</literal>. By default, all
			<emphasis>public</emphasis> properties of the bean are exposed as attributes and all
			<emphasis>public</emphasis> methods (bar those inherited from the <classname>Object</classname>
			class) are exposed as operations.
		</para>
		<section id="jmx-exporting-mbeanserver">
			<title>Creating an MBeanServer</title>
			<para>
				The above configuration assumes that the application is running in an environment that has
				one (and only one) <classname>MBeanServer</classname> already running. In this case, Spring
				will attempt to locate the running <classname>MBeanServer</classname> and register your
				beans with that server (if any). This behaviour is useful when your application is running
				inside a container such as Tomcat or IBM WebSphere that has it's own
				<classname>MBeanServer</classname>.
			</para>
			<para>
				However, this is approach is no use for a standalone environment, or when running inside a
				container that does not provide an <classname>MBeanServer</classname>. To overcome this you
				can create an <classname>MBeanServer</classname> instance declaratively by adding an instance
				of the <classname>org.springframework.jmx.support.MBeanServerFactoryBean</classname> class to
				your configuration. You can also ensure that this specific <classname>MBeanServer</classname>
				is used by setting the value of the <classname>MBeanExporter</classname>'s
				<literal>server</literal> property to the <classname>MBeanServer</classname> value returned
				by an <classname>MBeanServerFactoryBean</classname>; an example of such configuration can be
				seen below:
			</para>
			<programlisting><![CDATA[<beans>

  <bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="server" ref="mbeanServer"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>
			<para>
				Here an instance of <classname>MBeanServer</classname> is created by the
				<classname>MBeanServerFactoryBean</classname> and is supplied to the
				<classname>MBeanExporter</classname> via the server property. When you supply your
				own <classname>MBeanServer</classname> instance, the <classname>MBeanExporter</classname>
				will not attempt to locate a running <classname>MBeanServer</classname> and will use
				the supplied <classname>MBeanServer</classname> instance. For this to work correctly,
				you must (of course) have a JMX implementation on your classpath.
			</para>
		</section>
		<section id="jmx-exporting-lazy">
			<title>Lazy-initialized MBeans</title>
			<para>
				If you configure a bean with the <classname>MBeanExporter</classname> that is also
				configured for lazy initialization, then the <classname>MBeanExporter</classname> will
				<emphasis role="bold">not</emphasis> break this contract and will avoid instantiating the
				attandant bean. Instead, it will register a proxy with the <classname>MBeanServer</classname>
				and will defer obtaining the bean from the <classname>BeanFactory</classname> until the
				first invocation on the proxy occurs.
			</para>
		</section>
		<section id="jmx-exporting-auto">
			<title>Automatic registration of MBeans</title>
			<para>
				Any beans that are exported through the <classname>MBeanExporter</classname> and are already
				valid MBeans are registered as-is with the <classname>MBeanServer</classname> without further
				intervention from Spring. MBeans can be automatically detected by the
				<classname>MBeanExporter</classname> by setting the	<literal>autodetect</literal> property to
				<literal>true</literal>:
			</para>
			<programlisting><![CDATA[<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
  <property name="autodetect" value="true"/>
</bean>

<bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/>]]></programlisting>
			<para>
				Here, the bean called <literal>spring:mbean=true</literal> is already a valid JMX MBean and
				will be automatically registered by Spring. By default, beans that are autodetected for JMX
				registration have their bean name used as the <classname>ObjectName</classname>. This behavior
				can be overridden as detailed in section <xref linkend="jmx-naming"/>.
			</para>
		</section>	
		<section id="jmx-exporting-registration-behaviour">
			<title>Controlling the registration behaviour</title>
			<para>
	            Consider the scenario where a Spring <classname>MBeanExporter</classname>
	            attempts to register an <classname>MBean</classname> with an <classname>MBeanServer</classname>
	            using the <classname>ObjectName</classname> <literal>'bean:name=testBean1'</literal>.
	            If an <classname>MBean</classname> instance has already been registered under that same
	            <classname>ObjectName</classname>, the default behaviour is to fail (and throw an
	            <classname>InstanceAlreadyExistsException</classname>).
			</para>
			<para>
				It is possible to control the behaviour of exactly what happens when an
				<classname>MBean</classname> is registered with an <classname>MBeanServer</classname>.
				Spring's JMX support allows for three different registration behaviours to control the
				registration behaviour when the registration process finds that an
				<classname>MBean</classname> has already been registered under the same
				<classname>ObjectName</classname>; these registration behaviours are summarised on the
				following table:
			</para>
			<para>
				<table>
					<title>Registration Behaviours</title>
					<tgroup cols="2">
						<colspec align="left"/>
						<colspec colnum="1" colwidth="*"/>
						<colspec colnum="2" colwidth="*"/>
						<thead>
							<row>
								<entry align="center">Registration Behaviour</entry>
								<entry align="center">Explanation</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>
									<para>REGISTRATION_FAIL_ON_EXISTING</para>
								</entry>
								<entry>
									<para>
										This is the default registration behaviour. If an
										<classname>MBean</classname> instance has already been registered
										under the same <classname>ObjectName</classname>, the
										<classname>MBean</classname> that is being registered will not
										be registered and an <classname>InstanceAlreadyExistsException</classname>
										will be thrown. The existing <classname>MBean</classname> is unaffected.
									</para>
								</entry>
							</row>
							<row>
								<entry>
									<para>REGISTRATION_IGNORE_EXISTING</para>
								</entry>
								<entry>
									<para>
										If an <classname>MBean</classname> instance has already been registered
										under the same <classname>ObjectName</classname>, the
										<classname>MBean</classname> that is being registered will
										<emphasis>not</emphasis> be registered. The existing <classname>MBean</classname>
										is unaffected, and no <classname>Exception</classname> will be thrown.
									</para>
									<para>
							            This is useful in settings where multiple applications want to share a
							            common <classname>MBean</classname> in a shared
							            <classname>MBeanServer</classname>.
									</para>
								</entry>
							</row>
							<row>
								<entry>
									<para>REGISTRATION_REPLACE_EXISTING</para>
								</entry>
								<entry>
									<para>
										If an <classname>MBean</classname> instance has already been registered
										under the same <classname>ObjectName</classname>, the existing
										<classname>MBean</classname> that was previously registered will be
										unregistered and the new <classname>MBean</classname> will
										be registered in it's place (the new <classname>MBean</classname>
										effectively	replaces the prevous instance).
									</para>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
	            The above values (<literal>REGISTRATION_FAIL_ON_EXISTING</literal>,
	            <literal>REGISTRATION_IGNORE_EXISTING</literal>, and
	            <literal>REGISTRATION_REPLACE_EXISTING</literal> respectively) are defined as constants
	            on the <classname>MBeanRegistrationSupport</classname> class (the
	            <classname>MBeanExporter</classname> class derives from this superclass). If you want to change
	            the default registration behaviour, you simply need to set the value of the
	            <literal></literal> property on your <classname>MBeanExporter</classname> definition to
	            one of those values.
			</para>
			<para>
	            The following example illustrates using the <classname>FieldRetrievingFactoryBean</classname>
	            to effect a change from the default registration behaviour to the
	            <literal>REGISTRATION_REPLACE_EXISTING</literal> behaviour on an
	            <classname>MBeanExporter</classname> definition (using Spring XML):
			</para>
			<programlisting><![CDATA[<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
        <property name="registrationBehavior">
            <bean name="org.springframework.jmx.support.MBeanRegistrationSupport.REGISTRATION_REPLACE_EXISTING"
                  class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/>
        </property>
        <!-- using the 'registrationBehaviorName' property may be more convenient (and equivalent) -->
        <!--
        <property name="registrationBehaviorName" value="REGISTRATION_REPLACE_EXISTING"/>
        -->
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>]]></programlisting>
		</section>
		<section id="jmx-exporting-classloader">
			<title>Being specific about the ClassLoader</title>
			<para>
				[TODO]...
			</para>
		</section>
	</section>
	<section id="jmx-interface">
		<title>Controlling the management interface of your beans</title>
		<para>
			In the previous example, you had little control over the management interface of your bean;
			<emphasis>all</emphasis> of the <emphasis>public</emphasis> properties and methods of each
			exported bean was exposed as JMX attributes and operations respectively. To exercise
			finer-grained control over exactly which properties and methods of your exported beans are
			actually exposed as JMX attributes and operations, Spring JMX provides a comprehensive and
			extensible mechanism for controlling the management interfaces of your beans.
		</para>
		<section id="jmx-interface-assembler">
			<title>The <classname>MBeanInfoAssembler</classname> Interface</title>
			<para>
				Behind the scenes, the <classname>MBeanExporter</classname> delegates to an implementation
				of the <classname>org.springframework.jmx.export.assembler.MBeanInfoAssembler</classname>
				interface which is responsible for defining the management interface of each bean that is
				being exposed. The default implementation,
				<classname>org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</classname>,
				simply defines a management interface that exposes all public properties and methods
				(as you saw in the previous examples). Spring provides two additional implementations of
				the <classname>MBeanInfoAssembler</classname> interface that allow you to control the
				generated management interface using either source-level metadata or any arbitrary interface.
			</para>
		</section>
		<section id="jmx-interface-metadata">
			<title>Using source-Level metadata</title>
			<para>
				Using the <classname>MetadataMBeanInfoAssembler</classname> you can	define the management
				interfaces for your beans using source level metadata. The reading of metadata is
				encapsulated by the
				<classname>org.springframework.jmx.export.metadata.JmxAttributeSource</classname> interface.
				Out of the box, Spring JMX provides support for two	implementations of this interface:
				<classname>org.springframework.jmx.export.metadata.AttributesJmxAttributeSource</classname>
				for Commons Attributes and
				<classname>org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</classname>
				for JDK 5.0 annotations. The <classname>MetadataMBeanInfoAssembler</classname>
				<emphasis>must</emphasis> be configured with an implementation instance of the
				<classname>JmxAttributeSource</classname> interface for it to function correctly (there is
				<emphasis>no</emphasis> default). For the following example, we will use the Commons
				Attributes metadata approach.
			</para>
			<para>
				To mark a bean for export to JMX, you should annotate the bean class with the
				<classname>ManagedResource</classname> attribute. In the case of the Commons Attributes
				metadata approach this class can be found in the
				<literal>org.springframework.jmx.metadata</literal> package. Each method you wish to
				expose as an operation must be marked with the
				<classname>ManagedOperation</classname> attribute and each property you wish to expose
				must be marked with the <classname>ManagedAttribute</classname>	attribute. When marking
				properties you can omit either the annotation of the getter or the setter to create a
				write-only or read-only attribute respectively.
			</para>
			<para>
				The example below shows the <classname>JmxTestBean</classname> class that you saw earlier
				marked with Commons Attributes metadata:
			</para>
			<programlisting><![CDATA[package org.springframework.jmx;

/**
 * @@org.springframework.jmx.export.metadata.ManagedResource
 *  (description="My Managed Bean", objectName="spring:bean=test",
 *  log=true, logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate",
 *  persistPeriod=200, persistLocation="foo", persistName="bar")
 */
public class JmxTestBean implements IJmxTestBean {

  private String name;

  private int age;


  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (description="The Age Attribute", currencyTimeLimit=15)
   */
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *  (description="The Name Attribute",  currencyTimeLimit=20,
   *   defaultValue="bar", persistPolicy="OnUpdate")
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (defaultValue="foo", persistPeriod=300)
   */
  public String getName() {
    return name;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedOperation
   *  (description="Add Two Numbers Together")
   */
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }

}]]></programlisting>
			<para>
				Here you can see that the <classname>JmxTestBean</classname> class is
				marked with the <classname>ManagedResource</classname> attribute and that
				this <classname>ManagedResoure</classname> attribute is configured with a
				set of properties. These properties can be used to configure various
				aspects of the MBean that is generated by the <classname>MBeanExporter</classname>,
				and are explained in greater detail	later in section entitled
				<xref linkend="jmx-interface-metadata-types"/>.
			</para>
			<para>
				You will also notice that both the <literal>age</literal> and <literal>name</literal>
				properties are annotated with the <classname>ManagedAttribute</classname> attribute,
				but in the case of the <literal>age</literal> property, only the getter is marked.
				This will cause both of these properties to be included in the management interface
				as attributes, but the <literal>age</literal> attribute will be read-only.
			</para>
			<para>
				Finally, you will notice that the <literal>add(int, int)</literal>
				method is marked with the <classname>ManagedOperation</classname> attribute
				whereas the <literal>dontExposeMe()</literal> method is not. This will
				cause the management interface to contain only one operation,
				<literal>add(int, int)</literal>, when using the
				<classname>MetadataMBeanInfoAssembler</classname>.
			</para>
			<para>
				The code below shows how you configure the <classname>MBeanExporter</classname> to
				use the <classname>MetadataMBeanInfoAssembler</classname>:
			</para>
			<programlisting><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean1" value-ref="testBean"/>
      </map>
    </property>
    <property name="assembler" ref="assembler"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="attributeSource"
        class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource">
    <property name="attributes">
      <bean class="org.springframework.metadata.commons.CommonsAttributes"/>
    </property>
  </bean>

  <bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
    <property name="attributeSource" ref="attributeSource"/>
  </bean>

</beans>]]></programlisting>
			<para>
				Here you can see that an <classname>MetadataMBeanInfoAssembler</classname> bean has been
				configured with an instance of the <classname>AttributesJmxAttributeSource</classname>
				class and passed to the <classname>MBeanExporter</classname> through the assembler property.
				This is all that is required to take advantage of metadata-driven management interfaces for
				your Spring-exposed MBeans.
			</para>
		</section>
		<section id="jmx-interface-annotations">
			<title>Using JDK 5.0 Annotations</title>
			<para>
				To enable the use of JDK 5.0 annotations for management interface definition, Spring
				provides a set of annotations that mirror the Commons Attribute attribute classes and
				an implementation of the <classname>JmxAttributeSource</classname> strategy interface,
				the <classname>AnnotationsJmxAttributeSource</classname> class, that allows the
				<classname>MBeanInfoAssembler</classname> to read them.
			</para>
			<para>
				The example below shows a bean with a JDK 5.0 annotation defined management interface:
			</para>
			<programlisting><![CDATA[package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(objectName="bean:name=testBean4", description="My Managed Bean", log=true,
    logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate", persistPeriod=200,
    persistLocation="foo", persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

  private String name;

  private int age;


  @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  @ManagedAttribute(description="The Name Attribute",
      currencyTimeLimit=20,
      defaultValue="bar",
      persistPolicy="OnUpdate")
  public void setName(String name) {
    this.name = name;
  }

  @ManagedAttribute(defaultValue="foo", persistPeriod=300)
  public String getName() {
    return name;
  }

  @ManagedOperation(description="Add Two Numbers Together")
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }

}]]></programlisting>
			<para>
				As you can see little has changed, other than the basic syntax of the metadata definitions.
				Behind the scenes this approach is a little slower at startup because the JDK 5.0 annotations
				are converted into the classes used by Commons Attributes. However, this is only a one-off cost
				and JDK 5.0 annotations give you the added (and valuable) benefit of compile-time checking.
			</para>
		</section>
		<section id="jmx-interface-metadata-types">
			<title>Source-Level Metadata Types</title>
			<para>
				The following source level metadata types are available for use in Spring JMX:
			</para>
			<para>
				<table>
					<title>Source-Level Metadata Types</title>
					<tgroup cols="4">
						<colspec align="left"/>
						<colspec colnum="1" colname="spycolgen1" colwidth="*"/>
						<colspec colnum="2" colname="spycolgen2" colwidth="*"/>
						<colspec colnum="3" colname="spycolgen3" colwidth="*"/>
						<thead>
							<row>
								<entry align="center">Purpose</entry>
								<entry align="center">Commons Attributes Attribute</entry>
								<entry align="center">JDK 5.0 Annotation</entry>
								<entry align="center">Attribute / Annotation Type</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>Mark all instances of a <classname>Class</classname> as JMX managed resources</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
								<entry>
									<literal>@ManagedResource</literal>
								</entry>
								<entry>Class</entry>
							</row>
							<row>
								<entry>Mark a method as a JMX operation</entry>
								<entry>
									<classname>ManagedOperation</classname>
								</entry>
								<entry>
									<literal>@ManagedOperation</literal>
								</entry>
								<entry>Method</entry>
							</row>
							<row>
								<entry>Mark a getter or setter as one half of a JMX attribute</entry>
								<entry>
									<classname>ManagedAttribute</classname>
								</entry>
								<entry>
									<classname>@ManagedAttribute</classname>
								</entry>
								<entry>Method (only getters and setters)</entry>
							</row>
							<row>
								<entry>Define descriptions for operation parameters</entry>
								<entry>
									<classname>ManagedOperationParameter</classname>
								</entry>
								<entry>
									<classname>@ManagedOperationParameter</classname> and <classname>@ManagedOperationParameters</classname>
								</entry>
								<entry>Method</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
			<para>
				The following configuration parameters are available for use on these source-level metadata types:
			</para>
			<para>
				<table>
					<title>Source-Level Metadata Parameters</title>
					<tgroup cols="3">
						<colspec align="left"/>
						<colspec colnum="1" colname="spycolgen1" colwidth="*"/>
						<colspec colnum="2" colname="spycolgen2" colwidth="*"/>
						<thead>
							<row>
								<entry align="center">Parameter</entry>
								<entry align="center">Description</entry>
								<entry align="center">Applies to</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>
									<classname>ObjectName</classname>
								</entry>
								<entry>
									Used by <classname>MetadataNamingStrategy</classname> to determine the
									<classname>ObjectName</classname> of a managed resource
								</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>description</literal>
								</entry>
								<entry>
									Sets the friendly description of the resource, attribute or operation
								</entry>
								<entry>
									<classname>ManagedResource</classname>,
									<classname>ManagedAttribute</classname>,
									<classname>ManagedOperation</classname>,
									<classname>ManagedOperationParameter</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>currencyTimeLimit</literal>
								</entry>
								<entry>
									Sets the value of the <literal>currencyTimeLimit</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedResource</classname>, <classname>ManagedAttribute</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>defaultValue</literal>
								</entry>
								<entry>
									Sets the value of the <literal>defaultValue</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedAttribute</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>log</literal>
								</entry>
								<entry>
									Sets the value of the <literal>log</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>logFile</literal>
								</entry>
								<entry>
									Sets the value of the <literal>logFile</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>persistPolicy</literal>
								</entry>
								<entry>
									Sets the value of the <literal>persistPolicy</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>persistPeriod</literal>
								</entry>
								<entry>
									Sets the value of the <literal>persistPeriod</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>persistLocation</literal>
								</entry>
								<entry>
									Sets the value of the <literal>persistLocation</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>persistName</literal>
								</entry>
								<entry>
									Sets the value of the <literal>persistName</literal> descriptor field
								</entry>
								<entry>
									<classname>ManagedResource</classname>
								</entry>
							</row>
							<row>
								<entry>
									<literal>name</literal>
								</entry>
								<entry>Sets the display name of an operation parameter</entry>
								<entry>
									<literal>ManagedOperationParameter</literal>
								</entry>
							</row>
							<row>
								<entry>
									<literal>index</literal>
								</entry>
								<entry>Sets the index of an operation parameter</entry>
								<entry>
									<literal>ManagedOperationParameter</literal>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</section>
		<section id="jmx-interface-autodetect">
			<title>The <classname>AutodetectCapableMBeanInfoAssembler</classname> interface</title>
			<para>
				To simply configuration even further, Spring introduces the
				<classname>AutodetectCapableMBeanInfoAssembler</classname> interface which
				extends the <classname>MBeanInfoAssembler</classname> interface to add
				support for autodetection of MBean resources. If you configure the
				<classname>MBeanExporter</classname> with an instance of
				<classname>AutodetectCapableMBeanInfoAssembler</classname> then it is
				allowed to "vote" on the inclusion of beans for exposure to JMX.
			</para>
			<para>
				Out of the box, the only implementation of the
				<classname>AutodetectCapableMBeanInfo</classname> interface is the
				<classname>MetadataMBeanInfoAssembler</classname> which will vote to include
				any bean which is marked with the <classname>ManagedResource</classname>
				attribute. The default approach in this case is to use the bean name as
				the <classname>ObjectName</classname> which results in a configuration like
				this:
			</para>
			<programlisting><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="assembler" ref="assembler"/>
	  <property name="autodetect" value="true"/>
  </bean>

  <bean name="bean:name=testBean1" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="attributeSource"
      class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/>

  <bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
    <property name="attributeSource" ref="attributeSource"/>
  </bean>

</beans>]]></programlisting>
			<para>
				Notice that in this configuration no beans are passed to the
				<classname>MBeanExporter</classname>; however, the
				<classname>JmxTestBean</classname> will still be registered since it is
				marked with the <classname>ManagedResource</classname> attribute and the
				<classname>MetadataMBeanInfoAssembler</classname> detects this and votes to
				include it. The only problem with this approach is that the name of the
				<classname>JmxTestBean</classname> now has business meaning. You can address
				this issue by changing the default behavior for
				<classname>ObjectName</classname> creation as defined in the section entitled
				<xref linkend="jmx-naming"/>.
			</para>
		</section>
		<section id="jmx-interface-java">
			<title>Defining Management interfaces using Java interfaces</title>
			<para>
				In addition to the <classname>MetadataMBeanInfoAssembler</classname>,
				Spring also includes the
				<classname>InterfaceBasedMBeanInfoAssembler</classname> which allows you to
				constrain the methods and properties that are exposed based on the set
				of methods defined in a collection of interfaces.
			</para>
			<para>
				Although the standard mechanism for exposing MBeans is to use
				interfaces and a simple naming scheme, the
				<classname>InterfaceBasedMBeanInfoAssembler</classname> extends this
				functionality by removing the need for naming conventions, allowing you
				to use more than one interface and removing the need for your beans to
				implement the MBean interfaces.
			</para>
			<para>
				Consider this interface that is used to define a management	interface for the
				<classname>JmxTestBean</classname> class that you saw earlier:
			</para>
			<programlisting><![CDATA[public interface IJmxTestBean {

  public int add(int x, int y);

  public long myOperation();

  public int getAge();

  public void setAge(int age);

  public void setName(String name);

  public String getName();
}]]></programlisting>
			<para>
				This interface defines the methods and properties that will be
				exposed as operations and attributes on the JMX MBean. The code below
				shows how to configure Spring JMX to use this interface as the
				definition for the management interface:
			</para>
			<programlisting><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean5" value-ref="testBean"/>
      </map>
    </property>
    <property name="assembler">
      <bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler">
        <property name="managedInterfaces">
          <value>org.springframework.jmx.IJmxTestBean</value>
        </property>
      </bean>
    </property>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

</beans>]]></programlisting>
			<para>
				Here you can see that the
				<classname>InterfaceBasedMBeanInfoAssembler</classname> is configured to use
				the <classname>IJmxTestBean</classname> interface when constructing the
				management interface for any bean. It is important to understand that
				beans processed by the
				<classname>InterfaceBasedMBeanInfoAssembler</classname> are <emphasis>not</emphasis>
				required to implement the interface used to generate the JMX management
				interface.
			</para>
			<para>
				In the case above, the <classname>IJmxTestBean</classname> interface
				is used to construct all management interfaces for all beans. In many
				cases this is not the desired behavior and you may want to use different
				interfaces for different beans. In this case, you can pass
				<classname>InterfaceBasedMBeanInfoAssembler</classname> a
				<classname>Properties</classname> instance via the
				<literal>interfaceMappings</literal> property, where the key of each
				entry is the bean name and the value of each entry is a comma-separated
				list of interface names to use for that bean.
			</para>
			<para>
				If no management interface is specified through either the
				<literal>managedInterfaces</literal> or
				<literal>interfaceMappings</literal> properties, then the
				<classname>InterfaceBasedMBeanInfoAssembler</classname> will reflect on the
				bean and use all of the interfaces implemented by that bean to create the
				management interface.
			</para>
		</section>
		<section id="jmx-interface-methodnames">
			<title>Using <classname>MethodNameBasedMBeanInfoAssembler</classname></title>
			<para>
				The <classname>MethodNameBasedMBeanInfoAssembler</classname> allows
				you to specify a list of method names that will be exposed to JMX as
				attributes and operations. The code below shows a sample configuration
				for this:
			</para>
			<programlisting><![CDATA[<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="bean:name=testBean5">
          <ref local="testBean"/>
        </entry>
      </map>
    </property>
    <property name="assembler">
      <bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler">
        <property name="managedMethods">
          <value>add,myOperation,getName,setName,getAge</value>
        </property>
      </bean>
    </property>
</bean>]]></programlisting>
			<para>
				Here you can see that the methods <literal>add</literal> and
				<literal>myOperation</literal> will be exposed as JMX operations and
				<literal>getName()</literal>, <literal>setName(String)</literal> and
				<literal>getAge()</literal> will be exposed as the appropriate half of a
				JMX attribute. In the code above, the method mappings apply to beans
				that are exposed to JMX. To control method exposure on a bean-by-bean
				basis, use the <literal>methodMappings</literal> property of
				<classname>MethodNameMBeanInfoAssembler</classname> to map bean names to
				lists of method names.
			</para>
		</section>
	</section>
	<section id="jmx-naming">
		<title>Controlling the <classname>ObjectName</classname>s for your beans</title>
		<para>
			Behind the scenes, the <classname>MBeanExporter</classname> delegates to
			an implementation of the <classname>ObjectNamingStrategy</classname> to obtain
			<classname>ObjectName</classname>s for each of the beans it is registering.
			The default implementation, <classname>KeyNamingStrategy</classname>, will, by
			default, use the key of the <literal>beans</literal>
			<classname>Map</classname> as the <classname>ObjectName</classname>. In addition,
			the <classname>KeyNamingStrategy</classname> can map the key of the
			<literal>beans</literal> <classname>Map</classname> to an entry in a
			<classname>Properties</classname> file (or files) to resolve the
			<classname>ObjectName</classname>. In addition to the
			<classname>KeyNamingStrategy</classname>, Spring provides two additional
			<classname>ObjectNamingStrategy</classname> implementations:
			the <classname>IdentityNamingStrategy</classname> that builds an
			<classname>ObjectName</classname> based on the JVM identity of the bean and
			the <classname>MetadataNamingStrategy</classname> that uses source level
			metadata to obtain the <classname>ObjectName</classname>.
		</para>
		<section id="jmx-naming-properties">
			<title>Reading <classname>ObjectName</classname>s from <classname>Properties</classname></title>
			<para>
				You can configure your own <classname>KeyNamingStrategy</classname>
				instance and configure it to read <classname>ObjectName</classname>s from a
				<classname>Properties</classname> instance rather than use bean key. The
				<classname>KeyNamingStrategy</classname> will attempt to locate an entry in
				the <classname>Properties</classname> with a key corresponding to the bean
				key. If no entry is found or if the <classname>Properties</classname>
				instance is <literal>null</literal> then the bean key itself is used.
			</para>
			<para>
				The code below shows a sample configuration for the <classname>KeyNamingStrategy</classname>:
			</para>
			<programlisting><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="testBean" value-ref="testBean"/>
      </map>
    </property>
    <property name="namingStrategy" ref="namingStrategy"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy">
    <property name="mappings">
      <props>
        <prop key="testBean">bean:name=testBean1</prop>
      </props>
    </property>
    <property name="mappingLocations">
      <value>names1.properties,names2.properties</value>
    </property>
  </bean

</beans>]]></programlisting>
			<para>
				Here an instance of <classname>KeyNamingStrategy</classname> is	configured with a
				<classname>Properties</classname> instance that is merged from the
				<classname>Properties</classname> instance defined by the mapping property and the
				properties files located in the paths defined by the mappings property. In this
				configuration, the <literal>testBean</literal> bean will be given the
				<classname>ObjectName</classname> <literal>bean:name=testBean1</literal> since this
				is the entry in the <classname>Properties</classname> instance that has a key corresponding
				to the bean key.
			</para>
			<para>
				If no entry in the <classname>Properties</classname> instance can be
				found then the bean key name is used as the <classname>ObjectName</classname>.
			</para>
		</section>
		<section id="jmx-naming-metadata">
			<title>Using the <classname>MetadataNamingStrategy</classname></title>
			<para>
				The <classname>MetadataNamingStrategy</classname> uses
				<classname>ObjectName</classname> property of the
				<classname>ManagedResource</classname> attribute on each bean to create the
				<classname>ObjectName</classname>. The code below shows the configuration
				for the <classname>MetadataNamingStrategy</classname>:
			</para>
			<programlisting><![CDATA[<beans>

  <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
      <map>
        <entry key="testBean" value-ref="testBean"/>
      </map>
    </property>
    <property name="namingStrategy" ref="namingStrategy"/>
  </bean>

  <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
    <property name="name" value="TEST"/>
    <property name="age" value="100"/>
  </bean>

  <bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
    <property name="attributeSource" ref="attributeSource"/>
  </bean>

  <bean id="attributeSource"
      class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/>

</beans>]]></programlisting>
		</section>
	</section>
	<section id="jmx-jsr160">
		<title>Exporting your beans with JSR-160 Connectors</title>
		<para>
			For remote access, Spring JMX module offers two	<classname>FactoryBean</classname> implementations
			inside the <literal>org.springframework.jmx.support</literal> package for creating both server- and
			client-side connectors.
		</para>
		<section id="jmx-jsr160-server">
			<title>Server-side Connectors</title>
			<para>
				To have Spring JMX create,start and expose a JSR-160 <classname>JMXConnectorServer</classname>
				use the following configuration:
			</para>
			<programlisting><![CDATA[<bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/>]]></programlisting>
			<para>
				By default <literal>ConnectorServerFactoryBean</literal> creates a
				<classname>JMXConnectorServer</classname> bound to
				<literal>"service:jmx:jmxmp://localhost:9875"</literal>. The <literal>serverConnector</literal>
				bean thus exposes the local <classname>MBeanServer</classname> to clients through the JMXMP
				protocol on localhost, port 9875. Note that the JMXMP protocol is marked as	optional by the
				JSR 160 specification: currently, the main open-source JMX implementation, MX4J, and the
				one provided with J2SE 5.0 do <emphasis>not</emphasis> support JMXMP.
			</para>
			<para>
				To specify another URL and register the	<classname>JMXConnectorServer</classname> itself
				with the <classname>MBeanServer</classname> use the <literal>serviceUrl</literal> and
				<classname>ObjectName</classname> properties respectively:
			</para>
			<programlisting><![CDATA[<bean id="serverConnector"
      class="org.springframework.jmx.support.ConnectorServerFactoryBean">
  <property name="objectName" value="connector:name=rmi"/>
  <property name="serviceUrl" 
            value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/>
</bean>]]></programlisting>
			<para>
				If the <classname>ObjectName</classname> property is set Spring will automatically register
				your connector with the <classname>MBeanServer</classname> under that
				<classname>ObjectName</classname>. The example below shows the full set of parameters which
				you can pass to	the <classname>ConnectorServerFactoryBean</classname> when creating a
				JMXConnector:
			</para>
			<programlisting><![CDATA[<bean id="serverConnector"
      class="org.springframework.jmx.support.ConnectorServerFactoryBean">
  <property name="objectName" value="connector:name=iiop"/>
  <property name="serviceUrl" 
               value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/>
  <property name="threaded" value="true"/>
  <property name="daemon" value="true"/>
  <property name="environment">
    <map>
      <entry key="someKey" value="someValue"/>
    </map>
  </property>
</bean>]]></programlisting>
			<para>
				For more information on these properties consult the JavaDoc. For information of meaning of
				the various environment variables, consult the JavaDoc for... [TODO]
			</para>
			<para>
				Note that when using a RMI-based connector you need the lookup service (tnameserv or
				rmiregistry) to be started in order for the name registration to complete. If you are using
				Spring to export remote services for you via RMI, then Spring will already have constructed
				an RMI registry. If not, you can easily start a registry using the following snippet of
				configuration:
			</para>
			<programlisting><![CDATA[<bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean">
  <property name="port" value="1099"/>
</bean>]]></programlisting>
		</section>
		<section id="jmx-jsr160-client">
			<title>Client-side Connectors</title>
			<para>
				To create an <classname>MBeanServerConnection</classname> to a remote
				JSR-160 enabled <classname>MBeanServer</classname> use the
				<classname>MBeanServerConnectionFactoryBean</classname> as shown below:
			</para>
			<programlisting><![CDATA[<bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
  <property name="serviceUrl" value="service:jmx:rmi://localhost:9875"/>
</bean>]]></programlisting>
		</section>
		<section id="jmx-jsr160-protocols">
			<title>JMX over Burlap/Hessian/SOAP</title>
			<para>
				JSR-160 permits extensions to the way in which communication is done between the client and
				the server. The examples above are using the mandatory RMI-based implementation required by
				the JSR-160 specification (IIOP and JRMP) and the (optional) JMXMP. By using other providers
				or JMX implementations (such as <ulink url="http://mx4j.sourceforge.net">MX4J</ulink>) you
				can take advantage of protocols like SOAP, Hessian, Burlap over simple HTTP or SSL and others:
			</para>
			<programlisting><![CDATA[<bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean">
  <property name="objectName" value="connector:name=burlap"/>
  <property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/>
</bean>]]></programlisting>
			<para>
				In the case of the above example, MX4J 3.0.0 was used; see the official MX4J documentation for
				more information.
			</para>
		</section>
	</section>
	<section id="jmx-proxy">
		<title>Accessing MBeans via Proxies</title>
		<para>
			Spring JMX allows you to create proxies that re-route calls to MBeans registered in a local or
			remote <classname>MBeanServer</classname>. These proxies provide you with a standard Java
			interface through which you can interact with your MBeans. The code below shows how to configure
			a proxy for an MBean running in a local <classname>MBeanServer</classname>:
		</para>
		<programlisting><![CDATA[bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
    <property name="objectName" value="bean:name=testBean"/>
    <property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
</bean>]]></programlisting>
		<para>
			Here you can see that a proxy is created for the MBean registered under the
			<classname>ObjectName</classname>: <literal>bean:name=testBean</literal>. The set of interfaces
			that the proxy will implement is controlled by the <literal>proxyInterfaces</literal> property
			and the rules for mapping methods and properties on these interfaces to operations and attributes on
			the MBean are the same rules used by the <classname>InterfaceBasedMBeanInfoAssembler</classname>.
		</para>
		<para>
			The <classname>MBeanProxyFactoryBean</classname> can create a proxy to any MBean that is accessible
			via an <classname>MBeanServerConnection</classname>. By default, the local
			<classname>MBeanServer</classname> is located and used, but you can override this and provide an
			<classname>MBeanServerConnection</classname> pointing to a remote <classname>MBeanServer</classname>
			to cater for proxies pointing to remote MBeans:
		</para>
		<programlisting><![CDATA[<bean id="clientConnector"
      class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
  <property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/>
</bean>

<bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
  <property name="objectName" value="bean:name=testBean"/>
  <property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
  <property name="server" ref="clientConnector"/>
</bean>]]></programlisting>
		<para>
			Here you can see that we create an <classname>MBeanServerConnection</classname> pointing to a
			remote machine using the <classname>MBeanServerConnectionFactoryBean</classname>. This
			<classname>MBeanServerConnection</classname> is then passed to the
			<classname>MBeanProxyFactoryBean</classname> via the <literal>server</literal> property. The
			proxy that is created will forward all invocations to the <classname>MBeanServer</classname>
			via this <classname>MBeanServerConnection</classname>.
		</para>
	</section>
	<section id="jmx-notifications">
		<title>Notifications</title>
        <para>
            [TODO]...
        </para>
	</section>
	<section id="jmx-resources">
		<title>Further Resources - JMX</title>
        <para>
            This section contains resources about JMX...
        </para>
	</section>
</chapter>
