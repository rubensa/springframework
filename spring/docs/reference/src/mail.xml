<?xml version="1.0" encoding="UTF-8"?>
<chapter id="mail">
  <title>The Spring email abstraction layer</title>

  <section id="mail-introduction">
    <title>Introduction</title>

    <para>Spring provides a higher level of abstraction for sending electronic
    mail which shields the user from the specifics of the underlying mailing
    system and is responsible for low level resource handling on behalf of
    the client.</para>
  </section>

  <section id="mail-structure">
    <title>Spring mail abstraction structure</title>

    <para>The main package of Spring mail abstraction layer is
    <literal>org.springframework.mail</literal> package. It contains the central
    interface for sending emails called <interfacename>MailSender</interfacename> and the
    <emphasis>value object</emphasis> which encapsulates properties of a
    simple mail such as <emphasis>from</emphasis>, <emphasis>to</emphasis>,
    <emphasis>cc</emphasis>, <emphasis>subject</emphasis>,
    <emphasis>text</emphasis> called <classname>SimpleMailMessage</classname>.
    This package also contains a hierarchy of checked exceptions which provide
    a higher level of abstraction over the lower level mail system exceptions
    with the root exception being <classname>MailException</classname>. Please
    refer to the javadocs for more information on the rich mail exception hierarchy.</para>

    <para>Spring also provides a sub-interface of <interfacename>MailSender</interfacename>
    for specialized <emphasis>JavaMail</emphasis> features such as MIME
    messages, namely
    <classname>org.springframework.mail.javamail.JavaMailSender</classname>. It
    also provides a callback interface for preparation of JavaMail MIME
    messages, namely
    <interfacename>org.springframework.mail.javamail.MimeMessagePreparator</interfacename></para>

    <programlisting><![CDATA[public interface MailSender {

    /**
     * Send the given simple mail message.
     * @param simpleMessage message to send
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(SimpleMailMessage simpleMessage) throws MailException;

    /**
     * Send the given array of simple mail messages in batch.
     * @param simpleMessages messages to send
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(SimpleMailMessage[] simpleMessages) throws MailException;

}]]></programlisting>

    <programlisting><![CDATA[public interface JavaMailSender extends MailSender {

    /**
     * Create a new JavaMail MimeMessage for the underlying JavaMail Session
     * of this sender. Needs to be called to create MimeMessage instances
     * that can be prepared by the client and passed to send(MimeMessage).
     * @return the new MimeMessage instance
     * @see #send(MimeMessage)
     * @see #send(MimeMessage[])
     */
    public MimeMessage createMimeMessage();

    /**
     * Send the given JavaMail MIME message.
     * The message needs to have been created with createMimeMessage.
     * @param mimeMessage message to send
     * @throws MailException in case of message, authentication, or send errors
     * @see #createMimeMessage
     */
    public void send(MimeMessage mimeMessage) throws MailException;

    /**
     * Send the given array of JavaMail MIME messages in batch.
     * The messages need to have been created with createMimeMessage.
     * @param mimeMessages messages to send
     * @throws MailException in case of message, authentication, or send errors
     * @see #createMimeMessage
     */
    public void send(MimeMessage[] mimeMessages) throws MailException;

    /**
     * Send the JavaMail MIME message prepared by the given MimeMessagePreparator.
     * Alternative way to prepare MimeMessage instances, instead of createMimeMessage
     * and send(MimeMessage) calls. Takes care of proper exception conversion.
     * @param mimeMessagePreparator the preparator to use
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(MimeMessagePreparator mimeMessagePreparator) throws MailException;

    /**
     * Send the JavaMail MIME messages prepared by the given MimeMessagePreparators.
     * Alternative way to prepare MimeMessage instances, instead of createMimeMessage
     * and send(MimeMessage[]) calls. Takes care of proper exception conversion.
     * @param mimeMessagePreparators the preparator to use
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(MimeMessagePreparator[] mimeMessagePreparators) throws MailException;

}]]></programlisting>
    
    <programlisting><![CDATA[public interface MimeMessagePreparator {

    /**
     * Prepare the given new MimeMessage instance.
     * @param mimeMessage the message to prepare
     * @throws MessagingException passing any exceptions thrown by MimeMessage
     * methods through for automatic conversion to the MailException hierarchy
     */
    void prepare(MimeMessage mimeMessage) throws MessagingException;

}]]></programlisting>
  </section>

  <section id="mail-usage">
    <title>Using the Spring mail abstraction</title>

    <para>Let's assume there is a business interface called
    <interfacename>OrderManager</interfacename>:</para>
    
    <programlisting><![CDATA[public interface OrderManager {

    void placeOrder(Order order);
}]]></programlisting>

    <para>Let's assume that there is a use case that says that an email message
    with an order number needs to be generated and sent to a customer
    placing the relevant order. So for this purpose we want to use
    <interfacename>MailSender</interfacename> and <classname>SimpleMailMessage</classname>.</para>

    <para><emphasis>Note that as usual, we work with interfaces in the
    business code and let Spring IoC container take care of wiring of all the
    collaborators for us.</emphasis></para>

    <para>Here is the implementation of <interfacename>OrderManager</interfacename>:</para>
    
    <programlisting><![CDATA[import org.springframework.mail.MailException;
import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class OrderManagerImpl implements OrderManager {

    private MailSender mailSender;
    private SimpleMailMessage message;

    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void setMessage(SimpleMailMessage message) {
        this.message = message;
    }

    public void placeOrder(Order order) {

        ]]><lineannotation>// Do the business calculations...</lineannotation><![CDATA[
        ]]><lineannotation>// Call the collaborators to persist the order...</lineannotation><![CDATA[

        //Create a thread safe "sandbox" of the message
        SimpleMailMessage msg = new SimpleMailMessage(this.message);
        msg.setTo(order.getCustomer().getEmailAddress());
        msg.setText(
            "Dear "
                + order.getCustomer().getFirstName()
                + order.getCustomer().getLastName()
                + ", thank you for placing order. Your order number is "
                + order.getOrderNumber());
        try{
            mailSender.send(msg);
        }
        catch(MailException ex) {
            //log it and go on
            System.err.println(ex.getMessage());            
        }
    }
}]]></programlisting>
    
        <para>Here is what the bean definitions for the code above would look like:</para>

    <programlisting><![CDATA[<bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl">
  <property name="host" value="mail.mycompany.com"/>
</bean>

<bean id="mailMessage" class="org.springframework.mail.SimpleMailMessage">
  <property name="from" value="customerservice@mycompany.com"/>
  <property name="subject" value="Your order"/>
</bean>

<bean id="orderManager" class="com.mycompany.businessapp.support.OrderManagerImpl">
  <property name="mailSender" ref="mailSender"/>
  <property name="message" ref="mailMessage"/>
</bean>]]></programlisting>

    <para>Here is the implementation of <interfacename>OrderManager</interfacename> using
    <interfacename>MimeMessagePreparator</interfacename> callback interface. Please note
    that the mailSender property is of type <interfacename>JavaMailSender</interfacename>
    in this case in order to be able to use JavaMail <classname>MimeMessage</classname>:</para>
    
    <programlisting><![CDATA[import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMessage;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;

public class OrderManagerImpl implements OrderManager {

    private JavaMailSender mailSender;
    
    public void setMailSender(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void placeOrder(final Order order) {

        ]]><lineannotation>// Do the business calculations...</lineannotation><![CDATA[
        ]]><lineannotation>// Call the collaborators to persist the order...</lineannotation><![CDATA[
        
        MimeMessagePreparator preparator = new MimeMessagePreparator() {
        
            public void prepare(MimeMessage mimeMessage) throws MessagingException {
        
                mimeMessage.setRecipient(Message.RecipientType.TO, 
                        new InternetAddress(order.getCustomer().getEmailAddress()));
                mimeMessage.setFrom(new InternetAddress("mail@mycompany.com"));
                mimeMessage.setText(
                    "Dear "
                        + order.getCustomer().getFirstName()
                        + order.getCustomer().getLastName()
                        + ", thank you for placing order. Your order number is "
                        + order.getOrderNumber());
            }
        };
        try {
            mailSender.send(preparator);
        }
        catch (MailException ex) {
            //log it and go on
            System.err.println(ex.getMessage());            
        }
    }
}]]></programlisting>

    <para>If you want to use the JavaMail <classname>MimeMessage</classname> to its full power,
    the <classname>MimeMessagePreparator</classname> is available to you.</para>

    <note>
        <para>The mail code is a crosscutting concern and is a perfect candidate
        for refactoring into a custom Spring AOP aspect, which then could be executed at
        appropriate joinpoints on the <interfacename>OrderManager</interfacename> target.
        See the chapter entitled <xref linkend="aop"/>.</para>
    </note>

    <section>
      <title>Pluggable <interfacename>MailSender</interfacename> implementations</title>

      <para>Spring comes with two <interfacename>MailSender</interfacename> implementations
      out of the box - the JavaMail implementation and the implementation on top of Jason
      Hunter's <classname>MailMessage</classname> class that's included in
      <ulink url="http://servlets.com/cos">http://servlets.com/cos</ulink>
      (com.oreilly.servlet). Please refer to the relevant javadocs for more
      information.</para>
    </section>
  </section>
  
  <section>
  	<title>Using the JavaMail <classname>MimeMessageHelper</classname></title>
  	<para>
  		One of the components that comes in pretty handy when dealing with
  		JavaMail messages is the <classname>org.springframework.mail.javamail.MimeMessageHelper</classname>.
  		It prevents you from having to use the nasty APIs the the <literal>javax.mail.internet</literal> classes.
  		Find below a couple of possible scenarios:
  	</para>
  	<section>
  		<title>Creating a simple <classname>MimeMessage</classname> and sending it</title>
  		<para>
  			Using the <classname>MimeMessageHelper</classname> it's pretty easy to setup
  			and send a <classname>MimeMessage</classname>:</para>
  			<programlisting><lineannotation>// of course you would use DI in any real-world cases</lineannotation><![CDATA[
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();
MimeMessageHelper helper = new MimeMessageHelper(message);
helper.setTo("test@host.com");
helper.setText("Thank you for ordering!");

sender.send(message);]]></programlisting>
	</section>
	<section>
		<title>Sending attachments and inline resources</title>
		<para>
			Email allows for attachments, but also for inline resources in multipart
			messages. Inline resources could for example be images or stylesheet you
			want to use in your message, but don't want displayed as an attachment.
			The following shows you how to use the <classname>MimeMessageHelper</classname>
			to send an email along with an inline image.</para>
			<programlisting><![CDATA[JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();

]]><lineannotation>// use the true flag to indicate you need a multipart message</lineannotation><![CDATA[
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

]]><lineannotation>// use the true flag to indicate the text included is HTML</lineannotation><![CDATA[
helper.setText("<html><body><img src='cid:identifier1234'></body></html>", true);

]]><lineannotation>// let's include the infamous windows Sample file (this time copied to c:/)</lineannotation><![CDATA[
FileSystemResource res = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addInline("identifier1234", res);

]]><lineannotation>// if you would need to include the file as an attachment, use
// the various addAttachment() methods on the MimeMessageHelper</lineannotation><![CDATA[

sender.send(message);]]></programlisting>

        <warning>
            <para>Inline resources are added to the mime message using the Content-ID specified
            as you've seen just now (<literal>identifier1234</literal> in this case). The order in 
            which you're adding the text and the resource are VERY important. First add the text
            and after that the resources. If you're doing it the other way around, it won't work!</para>
		</warning>
	</section>
  </section>
  
</chapter>