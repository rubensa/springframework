<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="metadata">
	<title>Annotations and Source Level Metadata Support</title>
	<section id="metadata-concepts">
		<title>Source-level metadata</title>
		<para>
			Source-level metadata is the addition of <emphasis>attributes</emphasis> or
			<emphasis>annotations</emphasis> to program elements: usually, classes
			and/or methods.
		</para>
		<para>
			For example, we might add metadata to a class as follows:
		</para>
		<programlisting><![CDATA[/**
 * Normal comments
 * @@org.springframework.transaction.interceptor.DefaultTransactionAttribute()
 */
public class PetStoreImpl implements PetStoreFacade, OrderService {]]></programlisting>
		<para>We could add metadata to a method as follows:</para>
		<programlisting><![CDATA[/**
 * Normal comments
 * @@org.springframework.transaction.interceptor.RuleBasedTransactionAttribute()
 * @@org.springframework.transaction.interceptor.RollbackRuleAttribute(Exception.class)
 * @@org.springframework.transaction.interceptor.NoRollbackRuleAttribute("ServletException")
 */
public void echoException(Exception ex) throws Exception {
    ....
}]]></programlisting>
		<para>Both of these examples use Jakarta Commons Attributes syntax.</para>
		<para>
			Source-level metadata was introduced to the mainstream by XDoclet
			(in the Java world) and by the release of Microsoft's .NET platform, which
			uses source-level attributes to control transactions, pooling and other
			behavior.
		</para>
		<para>
			The value in this approach has been recognized in the J2EE
			community. For example, it's much less verbose than the traditional XML
			deployment descriptors exclusively used by EJB. While it is desirable to
			externalize some things from program source code, some important
			enterprise settings - notably transaction characteristics - arguably belong
			in program source. Contrary to the assumptions of the EJB spec, it seldom
			makes sense to modify the transactional characteristics of a method
			(although parameters like transaction timeouts might change!).
		</para>
		<para>
			Although metadata attributes are typically used mainly by framework
			infrastructure to describe the services application classes require, it
			should also be possible for metadata attributes to be queried at runtime.
			This is a key distinction from solutions such as XDoclet, which primarily
			view metadata as a way of generating code such as EJB artefacts.
		</para>
		<para>
			There are a number of solutions in this space, including:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis role="bold">Standard Java Annotations</emphasis>: the
        standard Java metadata implementation (developed as JSR-175 and
        available in Java 5. Spring already supports specific Java 5
        Annotations for transactional demarcation, and for JMX. But we need a
        solution for Java 1.4 and even 1.3 too.</para>
			</listitem>
			<listitem>
				<para><emphasis role="bold">XDoclet</emphasis>: well-established
        solution, primarily intended for code generation</para>
			</listitem>
			<listitem>
				<para>Various <emphasis role="bold">open source attribute
        implementations</emphasis>, for Java 1.3 and 1.4, of which Commons
        Attributes appears to be the most promising. All these require a
        special pre- or post-compilation step.</para>
			</listitem>
		</itemizedlist>
	</section>
	<section id="metadata-spring">
		<title>Spring's metadata support</title>
		<para>
			In keeping with its provision of abstractions over important
			concepts, Spring provides a facade to metadata implementations, in the
			form of the <interfacename>org.springframework.metadata.Attributes</interfacename>
			interface.
		</para>
		<para>
			Such a facade adds value for several reasons:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					Java 5 provides metadata support at language level, there will
					still be value in providing such an abstraction:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							Java 5 metadata is static. It is associated with a class
							at compile time, and cannot be changed in a deployed
							environment. There is a need for hierarchical metadata,
							providing the ability to override certain attribute values in
							deployment - for example, in an XML file.
						</para>
					</listitem>
					<listitem>
						<para>
							Java 5 metadata is returned through the Java reflection
							API. This makes it impossible to mock during test time. Spring
							provides a simple interface to allow this.
						</para>
					</listitem>
					<listitem>
						<para>
							There will be a need for metadata support in 1.3 and 1.4
							applications for at least two years. Spring aims to provide
							working solutions <emphasis>now</emphasis>; forcing the use of
							Java 5 is not an option in such an important area.
						</para>
					</listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>
					Current metadata APIs, such as Commons Attributes (used by
					Spring 1.0-1.2) are hard to test. Spring provides a simple metadata
					interface that is much easier to mock.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			The Spring <interfacename>Attributes</interfacename> interface looks like this:
		</para>
		<programlisting><![CDATA[public interface Attributes {

    Collection getAttributes(Class targetClass);

    Collection getAttributes(Class targetClass, Class filter);

    Collection getAttributes(Method targetMethod);

    Collection getAttributes(Method targetMethod, Class filter);

    Collection getAttributes(Field targetField);

    Collection getAttributes(Field targetField, Class filter);
}]]></programlisting>
		<para>
			This is a lowest common denominator interface. JSR-175 offers more
			capabilities than this, such as attributes on method arguments. As of
			Spring 1.0, Spring aims to provide the subset of metadata required to
			provide effective declarative enterprise services a la EJB or .NET, on
			Java 1.3+. As of Spring 1.2, analogous JSR-175 annotations are supported
			on JDK 1.5, as direct alternative to Commons Attributes.
		</para>
		<para>
			Note that this interface offers <classname>Object</classname>
			attributes, like .NET. This distinguishes it from attribute systems such
			as that of Nanning Aspects, which offer only <classname>String</classname>
			attributes. There is a significant advantage in supporting
			<classname>Object</classname> attributes. It enables attributes to
			participate in class hierarchies and enables attributes to react
			intelligently to their configuration parameters.
		</para>
		<para>
			In most attribute providers, attribute classes will be configured
			via constructor arguments or JavaBean properties. Commons Attributes
			supports both.
		</para>
		<para>
			As with all Spring abstraction APIs, <interfacename>Attributes</interfacename>
			is an interface. This makes it easy to mock attribute implementations for
			unit tests.
		</para>
	</section>
	<section id="metadata-annotations">
		<title>Annotations</title>
		<para>
			Spring has a number of custom <interfacename>Annotations</interfacename>.
		</para>
		<section id="metadata-annotations-required">
			<title>@<interfacename>Required</interfacename></title>
			<para>
				The @<interfacename>Required</interfacename> annotation in the
				<literal>org.springframework.beans.factory.annotation</literal>
				package can be used to <emphasis>mark</emphasis> a property as
				being <emphasis>'required-to-be-set'</emphasis> (i.e. an
				annotated (setter) method of a class must be configured to be
				dependency injected with a value), else an
				<classname>Exception</classname> must (and will) be thrown by
				the container at runtime.
			</para>
			<para>
				The best way to illustrate the usage of this annotation is to
				simply show an example; to wit..
			</para>
			<programlisting><![CDATA[public class SimpleMovieLister {

    ]]><lineannotation>// the <classname>SimpleMovieLister</classname> has a dependency on the <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    private MovieFinder movieFinder;

    ]]><lineannotation>// a setter method so that the Spring container can 'inject' a <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    @Required
    public void setMoveFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    ]]><lineannotation>// business logic that actually 'uses' the injected <interfacename>MovieFinder</interfacename> is omitted...</lineannotation><![CDATA[
}]]></programlisting>
			<para>
				Hopefully the above class definition reads easy on the eye.
				Basically (and in the context of the Spring IoC container), any
				and all <interfacename>BeanDefinitions</interfacename> for the
				<classname>SimpleMovieLister</classname> class must be provided
				with a value (in terms of the Spring API this means a
				<classname>PropertyValue</classname> must be set for that property).
			</para>
			<para>
				Lets look at an example of some XML configuration that will
				<emphasis role="bold">not</emphasis> pass validation.
			</para>
			<programlisting><![CDATA[<bean id="movieLister" class="x.y.SimpleMovieLister">
    ]]><lineannotation>&lt;!-- whoops, no MovieFinder is set (and this property is '@Required') --&gt;</lineannotation><![CDATA[
</bean>]]></programlisting>
			<para>
				At runtime the following message will be generated by the Spring container
				(the rest of the stack trace has been truncated).
			</para>
			<programlisting><![CDATA[Exception in thread "main" java.lang.IllegalArgumentException: Property 'movieFinder' is required for bean 'movieLister'.]]></programlisting>
			<para>
				Now hold your horses there a minute... there is one last little (small, tiny)
				piece of Spring configuration that is required to actually
				<emphasis>'switch on'</emphasis> this behaviour. Simply annotating the
				<emphasis>'setter'</emphasis> properties
				of your classes is not enough to get this behaviour... you need
				something that is aware of the @<interfacename>Required</interfacename>
				annotation and that can process it appropriately.
			</para>
			<para>
				Enter the <classname>RequiredBeanFactoryPostProcessor</classname> class.
				This is a <interfacename>BeanFactoryPostProcessor</interfacename> implementation
				that is provided out of the box by Spring that is @<interfacename>Required</interfacename>-aware
				and actually provides the <emphasis>'blow up if this required property has not been set'</emphasis>
				logic. It is <emphasis>very</emphasis> easy to configure; simply drop the following
				bean definition into your Spring XML configuration.
			</para>
			<programlisting><![CDATA[<bean class="org.springframework.beans.factory.annotation.RequiredBeanFactoryPostProcessor"/>]]></programlisting>
			<para>
				Finally, one can configure an instance of the
				<classname>RequiredBeanFactoryPostProcessor</classname> class to look
				for <emphasis>another</emphasis> <interfacename>Annotation</interfacename> type.
				This is great if you already have your own
				@<interfacename>Required</interfacename>-style annotation... simply plug it into
				the definition of a <classname>RequiredBeanFactoryPostProcessor</classname> and
				you are good to go. 
			</para>
			<para>
				By way of an example, lets assume your (or your organization / team) have
				defined an attribute called (for the sake of this example)
				@<interfacename>Mandatory</interfacename>. You can make a
				<classname>RequiredBeanFactoryPostProcessor</classname> instance
				@<interfacename>Mandatory</interfacename>-aware like so...
			</para>
			<programlisting><![CDATA[<bean class="org.springframework.beans.factory.annotation.RequiredBeanFactoryPostProcessor">
    <property name="requiredAnnotationType" value="your.company.package.Mandatory"/>
</bean>]]></programlisting>
		</section>
	</section>
	<section id="metadata-commons">
		<title>Integration with Jakarta Commons Attributes</title>
		<para>
			Presently Spring supports only Jakarta Commons Attributes out of the
			box, although it is easy to provide implementations of the
			<interfacename>org.springframework.metadata.Attributes</interfacename> interface for
			other metadata providers.
		</para>
		<para>
			<emphasis role="bold">Commons Attributes 2.1</emphasis>
			(<ulink url="http://jakarta.apache.org/commons/attributes/">http://jakarta.apache.org/commons/attributes/</ulink>)
			is a capable attributes solution. It supports attribute configuration via
			constructor arguments and JavaBean properties, which offers better
			self-documentation in attribute definitions. (Support for JavaBean
			properties was added at the request of the Spring team.)
		</para>
		<para>
			We've already seen two examples of Commons Attributes attributes
			definitions. In general, we will need to express:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					<emphasis>The name of the attribute class</emphasis>. This can
					be an FQN, as shown above. If the relevant attribute class has already
					been imported, the FQN isn't required. It's also possible to specify
					"attribute packages" in attribute compiler configuration.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis>Any necessary parameterization,</emphasis> via
					constructor arguments or JavaBean properties.
				</para>
			</listitem>
		</itemizedlist>
		<para>Bean properties look as follows:</para>
		<programlisting><![CDATA[/**
 * @@MyAttribute(myBooleanJavaBeanProperty=true)
 */]]></programlisting>
		<para>
			It's possible to combine constructor arguments and JavaBean
			properties (as in Spring IoC).
		</para>
		<para>
			Because, unlike Java 1.5 attributes, Commons Attributes is not
			integrated with the Java language, it is necessary to run a special
			<emphasis>attribute compilation</emphasis> step as part of the build
			process.
		</para>
		<para>
			To run Commons Attributes as part of the build process, you will
			need to do the following.
		</para>
		<para>
			1. Copy the necessary library Jars to
			<literal>$ANT_HOME/lib</literal>. Four Jars are required, and all are
			distributed with Spring:
		</para>
		<itemizedlist>
			<listitem>
				<para>The Commons Attributes compiler Jar and API Jar</para>
			</listitem>
			<listitem>
				<para>xjavadoc.jar, from XDoclet</para>
			</listitem>
			<listitem>
				<para>commons-collections.jar, from Jakarta Commons</para>
			</listitem>
		</itemizedlist>
		<para>
			2. Import the Commons Attributes ant tasks into your project build
			script, as follows:
		</para>
		<programlisting><![CDATA[<taskdef resource="org/apache/commons/attributes/anttasks.properties"/>]]></programlisting>
		<para>
			3. Next, define an attribute compilation task, which will use the
			Commons Attributes attribute-compiler task to "compile" the attributes in
			the source. This process results in the generation of additional sources,
			to a location specified by the destdir attribute. Here we show the use of
			a temporary directory:
		</para>
		<programlisting><![CDATA[<target name="compileAttributes">

  <attribute-compiler destdir="${commons.attributes.tempdir}">
    <fileset dir="${src.dir}" includes="**/*.java"/>
  </attribute-compiler>

</target>]]></programlisting>
		<para>
			The compile target that runs Javac over the sources should depend on
			this attribute compilation task, and must also compile the generated
			sources, which we output to our destination temporary directory. If there
			are syntax errors in your attribute definitions, they will normally be
			caught by the attribute compiler. However, if the attribute definitions
			are syntactically plausible, but specify invalid types or class names, the
			compilation of the generated attribute classes may fail. In this case, you
			can look at the generated classes to establish the cause of the
			problem.
		</para>
		<remark>
			Commons Attributes also provides Maven support. Please refer to
			Commons Attributes documentation for further information.
		</remark>
		<para>
			While this attribute compilation process may look complex, in fact
			it's a one-off cost. Once set up, attribute compilation is incremental, so
			it doesn't usually noticeably slow the build process. And once the
			compilation process is set up, you may find that use of attributes as
			described in this chapter can save you a lot of time in other
			areas.
		</para>
		<para>
			If you require attribute indexing support (only currently required
			by Spring for attribute-targeted web controllers, discussed below), you
			will need an additional step, which must be performed on a jar file of
			your compiled classes. In this, optional, step, Commons Attributes will
			create an index of all the attributes defined on your sources, for
			efficient lookup at runtime. This step looks as follows:
		</para>
		<programlisting><![CDATA[<attribute-indexer jarFile="myCompiledSources.jar">
    
  <classpath refid="master-classpath"/>

</attribute-indexer>]]></programlisting>
		<remark>
			See the <literal>/attributes</literal> directory of the Spring JPetStore sample
			application for an example of this build process. You can take the build
			script it contains and modify it for your own projects.
		</remark>
		<para>
			If your unit tests depend on attributes, try to express the
			dependency on the Spring Attributes abstraction, rather than Commons
			Attributes. Not only is this more portable - for example, your tests will
			still work if you switch to Java 1.5 attributes in future - it simplifies
			testing. Commons Attributes is a static API, while Spring provides a
			metadata interface that you can easily mock.
		</para>
	</section>
	<section id="metadata-uses">
		<title>Metadata and Spring AOP autoproxying</title>
		<para>
			The most important uses of metadata attributes are in conjunction
			with Spring AOP. This provides a .NET-like programming model, where
			declarative services are automatically provided to application objects
			that declare metadata attributes. Such metadata attributes can be
			supported out of the box by the framework, as in the case of declarative
			transaction management, or can be custom.
		</para>
		<para>
			There is widely held to be a synergy between AOP and metadata attributes.
		</para>
		<section>
			<title>Fundamentals</title>
			<para>
				This builds on the Spring AOP autoproxy functionality.
				Configuration might look like this:
			</para>
			<programlisting><![CDATA[<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>

<bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor">
  <property name="transactionInterceptor" ref="txInterceptor" />
</bean>

<bean id="txInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor">
  <property name="transactionManager" ref="transactionManager" />
  <property name="transactionAttributeSource">
    <bean class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource">
      <property name="attributes" ref="attributes" />
    </bean>
  </property>
</bean>

<bean id="attributes" class="org.springframework.metadata.commons.CommonsAttributes" />]]></programlisting>
			<para>
				The basic concepts here should be familiar from the discussion of
				autoproxying in the AOP chapter.
			</para>
			<para>
				The most important bean definitions are those the auto-proxy creator
				and the advisor. Note that the actual bean names are not important;
				what matters is their class.
			</para>
			<para>
				The bean definition of class
				<classname>org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</classname>
				will automatically advise ("auto-proxy") all bean instances in the
				current factory based on matching Advisor implementations. This class
				knows nothing about attributes, but relies on Advisors' pointcuts
				matching. The pointcuts do know about attributes.
			</para>
			<para>
				Thus we simply need an AOP advisor that will provide declarative
				transaction management based on attributes.
			</para>
			<para>
				It's possible to add arbitrary custom Advisor implementations as
				well, and they will also be evaluated and applied automatically. (You
				can use Advisors whose pointcuts match on criteria besides attributes in
				the same autoproxy configuration, if necessary.)
			</para>
			<para>
				Finally, the <literal>attributes</literal> bean is the Commons
				Attributes Attributes implementation. Replace it with another
				implementation of the
				<interfacename>org.springframework.metadata.Attributes</interfacename>
				interface to source attributes from a different source.
			</para>
		</section>
		<section id="metadata-tx">
			<title>Declarative transaction management</title>
			<para>
				The most common use of source-level attributes it to provide
				declarative transaction management a la .NET. Once the bean definitions
				shown above are in place, you can define any number of application
				objects requiring declarative transactions. Only those classes or
				methods with transaction attributes will be given transaction advice.
				You need to do nothing except define the required transaction
				attributes.
			</para>
			<para>
				<emphasis>Unlike</emphasis> in .NET, you can specify transaction
				attributes at either class or method level. Class-level attributes, if
				specified, will be "inherited" by all methods. Method attributes will
				wholly override any class-level attributes.
			</para>
		</section>
		<section id="metadata-pool">
			<title>Pooling</title>
			<para>
				Again, as with .NET, you can enable pooling behavior via
				class-level attributes. Spring can apply this behavior to any POJO. You
				simply need to specify a pooling attribute, as follows, in the business
				object to be pooled:
			</para>
			<programlisting><![CDATA[ /** 
 * @@org.springframework.aop.framework.autoproxy.target.PoolingAttribute(10)
 */
public class MyClass {]]></programlisting>
			<para>
				You'll need the usual autoproxy
				infrastructure configuration. You then need to specify a pooling
				<interfacename>TargetSourceCreator</interfacename>, as follows. Because pooling
				affects the creation of the target, we can't use a regular advice. Note
				that pooling will apply even if there are no advisors applicable to the
				class, if that class has a pooling attribute.
			</para>
			<programlisting><![CDATA[<bean id="poolingTargetSourceCreator"
  class="org.springframework.aop.framework.autoproxy.metadata.AttributesPoolingTargetSourceCreator">
  <property name="attributes" ref="attributes" />
</bean>]]></programlisting>
			<para>
				The relevant autoproxy bean definition needs to specify a list of
				"custom target source creators", including the Pooling target source
				creator. We could modify the example shown above to include this
				property as follows:
			</para>
			<programlisting><![CDATA[<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator">
  <property name="customTargetSourceCreators">
    <list>
      <ref bean="poolingTargetSourceCreator" />
    </list>
  </property>
</bean>]]></programlisting>
			<para>
				As with the use of metadata in Spring in general, this is a
				one-off cost: once setup is out of the way, it's very easy to use
				pooling for additional business objects.
			</para>
			<remark>
				It's arguable that the need for pooling is rare, so there's
				seldom a need to apply pooling to a large number of business objects.
				Hence this feature does not appear to be used often.
			</remark>
			<para>
				Please see the Javadoc for the
				<literal>org.springframework.aop.framework.autoproxy</literal> package
				for more details. It's possible to use a different pooling
				implementation than Commons Pool with minimal custom coding.
			</para>
		</section>
		<section id="metadata-arbitrary">
			<title>Custom metadata</title>
			<para>
				We can even go beyond the capabilities of .NET metadata
				attributes, because of the flexibility of the underlying autoproxying
				infrastructure.
			</para>
			<para>
				We can define custom attributes, to provide any kind of
				declarative behavior. To do this, you need to:
			</para>
			<itemizedlist>
				<listitem>
					<para>Define your custom attribute class</para>
				</listitem>
				<listitem>
					<para>
						Define a Spring AOP <interfacename>Advisor</interfacename> with a
						pointcut that fires on the presence of this custom attribute.
					</para>
				</listitem>
				<listitem>
					<para>
						Add that <interfacename>Advisor</interfacename> as a bean definition
						to an application context with the generic autoproxy infrastructure
						in place.
					</para>
				</listitem>
				<listitem>
					<para>Add attributes to your POJOs.</para>
				</listitem>
			</itemizedlist>
			<para>
				There are several potential areas you might want to do this, such
				as custom declarative security, or possibly caching.
			</para>
			<remark>
				This is a powerful mechanism which can significantly reduce
				configuration effort in some projects. However, remember that it does
				rely on AOP under the covers. The more Advisors you have in play, the
				more complex your runtime configuration will be.
			</remark>
			<remark>
				(If you want to see what advice applies to any object, try
				casting a reference to
				<interfacename>org.springframework.aop.framework.Advised</interfacename>. This
				will enable you to examine the Advisors.)
			</remark>
		</section>
	</section>
	<section>
		<title>Using attributes to minimize MVC web tier configuration</title>
		<para>
			The other main use of Spring metadata as of 1.0 is to provide an
			option to simplify Spring MVC web configuration.
		</para>
		<para>
			Spring MVC offers flexible <emphasis>handler mappings</emphasis>:
			mappings from incoming request to controller (or other handler) instance.
			Normally handler mappings are configured in the
			<literal>xxxx-servlet.xml</literal> file for the relevant Spring
			<classname>DispatcherServlet</classname>.
		</para>
		<para>
			Holding these mappings in the <classname>DispatcherServlet</classname>
			configuration file is normally A Good Thing. It provides maximum flexibility.
			In particular:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					The controller instance is explicitly managed by Spring IoC,
					through an XML bean definition.
				</para>
			</listitem>
			<listitem>
				<para>
					The mapping is external to the controller, so the same
					controller instance could be given multiple mappings in
					the same <classname>DispatcherServlet</classname> context
					or reused in a different configuration.
				</para>
			</listitem>
			<listitem>
				<para>
					Spring MVC is able to support mappings based on any criteria,
					rather than merely the request URL-to-controller mappings available
					in most other frameworks.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			However, this does mean that for each controller we typically need
			both a handler mapping (normally in a handler mapping XML bean definition)
			and an XML mapping for the controller itself.
		</para>
		<para>
			Spring offers a simpler approach based on source-level attributes,
			which is an attractive option in simpler scenarios.
		</para>
		<remark>
			The approach described in this section is best suited to
			relatively simple MVC scenarios. It sacrifices some of the power of Spring
			MVC, such as the ability to use the same controller with different
			mappings, and the ability to base mappings on something other than request
			URL.
		</remark>
		<para>
			In this approach, controllers are marked with one or more
			class-level metadata attributes, each specifying one URL they should be
			mapped to.
		</para>
		<para>
			The following examples show the approach. In each case, we have a
			controller that depends on a business object of type
			<interfacename>Cruncher</interfacename>. As usual,
			this dependency will be resolved by Dependency Injection. The
			<interfacename>Cruncher</interfacename>
			must be available through a bean definition in the relevant
			<classname>DispatcherServlet</classname> XML file, or a parent context.
		</para>
		<para>
			We attach an attribute to the controller class specifying the URL
			that should map to it. We can express the dependency through a JavaBean
			property or a constructor argument. This dependency must be resolvable by
			autowiring: that is, there must be exactly one business object of type
			<interfacename>Cruncher</interfacename> available in the context.
		</para>
		<programlisting><![CDATA[/**
 * Normal comments here
 *
 * @@org.springframework.web.servlet.handler.metadata.PathMap("/bar.cgi")
 */
public class BarController extends AbstractController {

    private Cruncher cruncher;

    public void setCruncher(Cruncher cruncher) {
        this.cruncher = cruncher;
    }

    protected ModelAndView handleRequestInternal (
            HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("Bar Crunching c and d =" + cruncher.concatenate("c", "d"));
        return new ModelAndView("test");
    }
}]]></programlisting>
		<para>
			For this auto-mapping to work, we need to add the following to the
			relevant <literal>xxxx-servlet.xml</literal> file, specifying the
			attributes handler mapping. This special handler mapping can handle any
			number of controllers with attributes as shown above. The bean id
			("commonsAttributesHandlerMapping") is not important. The type is what
			matters:
		</para>
		<programlisting><![CDATA[<bean id="commonsAttributesHandlerMapping"      
    class="org.springframework.web.servlet.handler.metadata.CommonsPathMapHandlerMapping"/>]]></programlisting>
		<para>
			We <emphasis>do not </emphasis>currently need an Attributes bean
			definition, as in the above example, because this class works directly
			with the Commons Attributes API, not via the Spring metadata
			abstraction.
		</para>
		<para>
			We now need no XML configuration for each controller. Controllers
			are automatically mapped to the specified URL(s). Controllers benefit from
			IoC, using Spring's autowiring capability. For example, the dependency
			expressed in the "cruncher" bean property of the simple controller shown
			above is automatically resolved in the current web application context.
			Both Setter and Constructor Dependency Injection are available, each with
			zero configuration.
		</para>
		<para>
			An example of Constructor Injection, also showing multiple URL paths:
		</para>
		<programlisting><![CDATA[/**
* Normal comments here...
* 
* @@org.springframework.web.servlet.handler.metadata.PathMap("/foo.cgi")
* @@org.springframework.web.servlet.handler.metadata.PathMap("/baz.cgi")
*/
public class FooController extends AbstractController {

    private Cruncher cruncher;

    public FooController(Cruncher cruncher) {
        this.cruncher = cruncher;
    }

    protected ModelAndView handleRequestInternal (
            HttpServletRequest request, HttpServletResponse response) throws Exception {
        return new ModelAndView("test");
    }
}]]></programlisting>
		<para>This approach has the following benefits:</para>
		<itemizedlist>
			<listitem>
				<para>
					Significantly reduced volume of configuration. Each time we add
					a controller we need add <emphasis>no</emphasis> XML configuration.
					As with attribute-driven transaction management, once the basic
					infrastructure is in place, it is very easy to add more application
					classes.
				</para>
			</listitem>
			<listitem>
				<para>
					We retain much of the power of Spring IoC to configure controllers.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			This approach has the following limitations:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					One-off cost in more complex build process. We need an attribute
					compilation step and an attribute indexing step. However, once in
					place, this should not be an issue.
				</para>
			</listitem>
			<listitem>
				<para>
					Currently Commons Attributes only, although support for other
					attribute providers may be added in future.
				</para>
			</listitem>
			<listitem>
				<para>
					Only "autowiring by type" dependency injection is supported for
					such controllers. However, this still leaves them far in advance of
					Struts Actions (with no IoC support from the framework) and, arguably,
					WebWork Actions (with only rudimentary IoC support) where IoC is
					concerned.
				</para>
			</listitem>
			<listitem>
				<para>
					Reliance on automagical IoC resolution may be confusing.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			Because autowiring by type means there must be exactly one
			dependency of the specified type, we need to be careful if we use AOP. In
			the common case using <classname>TransactionProxyFactoryBean</classname>,
			for example, we end up with <emphasis>two</emphasis> implementations of a
			business interface such as <interfacename>Cruncher</interfacename>: the
			original POJO definition, and the transactional AOP
			proxy. This won't work, as the owning application context can't resolve
			the type dependency unambiguously. The solution is to use AOP
			autoproxying, setting up the autoproxy infrastructure so that there is
			only one implementation of <interfacename>Cruncher</interfacename> defined,
			and that implementation is
			automatically advised. Thus this approach works well with
			attribute-targeted declarative services as described above. As the
			attributes compilation process must be in place to handle the web
			controller targeting, this is easy to set up.
		</para>
		<para>
			Unlike other metadata functionality, there is currently only a
			Commons Attributes implementation available:
			<classname>org.springframework.web.servlet.handler.metadata.CommonsPathMapHandlerMapping.</classname>
			This limitation is due to the fact that not only do we need attribute
			compilation, we need attribute <emphasis>indexing</emphasis>: the ability
			to ask the attributes API for all classes with the <literal>PathMap</literal> attribute.
			Indexing is not currently offered on the
			<classname>org.springframework.metadata.Attributes</classname> abstraction
			interface, although it may be in future. (If you want to add support for
			another attributes implementation - which must support indexing - you can
			easily extend the <classname>AbstractPathMapHandlerMapping</classname>
			superclass of <classname>CommonsPathMapHandlerMapping</classname>,
			implementing the two <literal>protected</literal> <literal>abstract</literal>
			methods to use your preferred attributes API.)
		</para>
		<para>
			Thus we need two additional steps in the build process: attribute
			compilation and attribute indexing. Use of the attribute indexer task was
			shown above. Note that Commons Attributes presently requires a jar file as
			input to indexing.
		</para>
	</section>
	<section>
		<title>Other uses of metadata attributes</title>
		<para>
			Other uses of metadata attributes appear to be growing in
			popularity. As of Spring 1.2, metadata attributes for JMX exposure are
			supported, through both Commons Attributes (on JDK 1.3+) and JSR-175
			annotations (on JDK 1.5).
		</para>
	</section>
	<section>
		<title>Adding support for additional metadata APIs</title>
		<para>
			Should you wish to provide support for another metadata API it is
			easy to do so.
		</para>
		<para>
			Simply implement the
			<classname>org.springframework.metadata.Attributes</classname> interface as a
			facade for your metadata API. You can then include this object in your
			bean definitions as shown above.
		</para>
		<para>
			All framework services that use metadata, such as AOP
			metadata-driven autoproxying, will then automatically be able to use your
			new metadata provider.
		</para>
	</section>
</chapter>