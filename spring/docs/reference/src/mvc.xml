<chapter id="mvc">

    <title>Web framework</title>
    
	<sect1 id="mvc-introduction">	
		
		<title>Introduction to the web framework</title>

		<para>
			Spring's web framework is designed around a DispatcherServlet that dispatches requests to handlers, with configurable handler mappings, view resolution, locale and theme resolution as well support for upload files. The default handler is a very simple Controller interface, just offering a <literal>ModelAndView handleRequest(request,response)</literal> method. This can already be used for application controllers, but you will prefer the included implementation hierarchy, consisting of for example <literal>AbstractController</literal>, <literal>AbstractCommandController</literal> and <literal>SimpleFormController</literal>. Application controllers will typically be subclasses of those. Note that you can choose an appropriate base class: If you don't have a form, you don't need a FormController. This is a major difference to Struts.
		</para>

		<para>
			You can take any object as command or form object: There's no need to implement an interface or derive from a base class. Spring's data binding is highly flexible, e.g. it treats type mismatches as validation errors that can be evaluated by the application, not as system errors. So you don't need to duplicate your business objects' properties as Strings in your form objects, just to be able to handle invalid submissions, or to convert the Strings properly. Instead, it's often preferable to bind directly to your business objects. This is another major difference to Struts which is built around required base classes like <literal>Action</literal> and <literal>ActionForm</literal> - for every type of action.
		</para>

		<para>
			Compared to WebWork, Spring has more differentiated object roles: It supports the notion of a Controller, an optional command or form object, and a model that gets passed to the view. The model will normally include the command or form object but also arbitrary reference data. Instead, a WebWork Action combines all those roles into one single object. WebWork does allow you to use existing business objects as part of your form, but just by making them bean properties of the respective Action class. Finally, the same Action instance that handles the request gets used for evaluation and form population in the view. Thus, reference data needs to be modelled as bean properties of the Action too. These are arguably too many roles in one object. 
		</para>

		<para>
			Regarding views: Spring's view resolution is extremely flexible. A Controller implementation can even write a view directly to the response, returning null as ModelAndView. In the normal case, a ModelAndView instance consists of a view name and a model Map, containing bean names and corresponding objects (like a command or form, reference data, etc). View name resolution is highly configurable, either via bean names, via a properties file, or via your own ViewResolver implementation. The abstract model Map allows for complete abstraction of the view technology, without any hassle: Be it JSP, Velocity, or anything else - every renderer can be integrated directly. The model Map simply gets transformed into an appropriate format, like JSP request attributes or a Velocity template model. 
		</para>

		<sect2 id="mvc-introduction-pluggability">		

			<title>Pluggability of MVC implementation</title>

			<para>
				Many teams will try to leverage their investments in terms of know-how and tools, both for existing projects and for new ones. Concretely, there are not only a large number of books and tools for Struts but also a lot of developers that have experience with it. Thus, if you can live with Struts' architectural flaws, it can still be a viable choice for the web layer. The same applies to WebWork and other web frameworks.
			</para>

			<para>
				If you don't want to use Spring's web MVC but intend to leverage other solutions that Spring offers, you can integrate the web framework of your choice with Spring easily. Simply start up a Spring root application context via its ContextLoaderListener, and access it via its ServletContext attribute (or Spring's respective helper method) from within a Struts or WebWork action. Note that there aren't any "plugins" involved, therefore no dedicated integration: From the view of the web layer, you'll simply use Spring as a library, with the root application context instance as entry point.
			</para>

			<para>
				All your registered beans and all of Spring's services can be at your fingertips even without Spring's web MVC. Spring doesn't compete with Struts or WebWork in this usage, it just addresses the many areas that the pure web frameworks don't, from bean configuration to data access and transaction handling. So you are able to enrich your application with a Spring middle tier and/or data access tier, even if you just want to use e.g. the transaction abstraction with JDBC or Hibernate.
			</para>

		</sect2>
		
		<sect2 id="mvc-features">
			<title>Features of Spring MVC</title>

			<para>
				If just focussing on the web support, some of the Spring's unique features are:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Clear separation of roles: controller vs validator vs command object vs form object vs model object, DispatcherServlet vs handler mapping vs view resolver, etc.
					</para>
				</listitem>
				<listitem>
					<para>
						Powerful and straightforward configuration of both framework and application classes as JavaBeans, including easy in-between referencing via an application context, e.g. from web controllers to business objects and validators.
					</para>
				</listitem>
				<listitem>
					<para>
						Adaptability, non-intrusiveness: Use whatever Controller subclass you need (plain, command, form, wizard, multi action, or a custom one) for a given scenario instead of deriving from Action/ActionForm for everything.
					</para>
				</listitem>
				<listitem>
					<para>
						Reusable business code, no need for duplication: You can use existing business objects as command or form objects instead of mirroring them in special ActionForm subclasses.
					</para>
				</listitem>
				<listitem>
					<para>
						Customizable binding and validation: type mismatches as application-level validation errors that keep the offending value, localized date and number binding, etc instead of String-only form objects with manual parsing and conversion to business objects.
					</para>
				</listitem>
				<listitem>
					<para>
						Customizable handler mapping, customizable view resolution: flexible model transfer via name/value Map, handler mapping and view resolution strategies from simple to sophisticated instead of one single way.
					</para>
				</listitem>
				<listitem>
					<para>
						Customizable locale and theme resolution, support for JSPs with and without Spring tag library, support for JSTL, support for Velocity without the need for extra bridges, etc.
					</para>
				</listitem>
				<listitem>
					<para>
						Simple but powerful tag library that avoids HTML generation at any cost, allowing for maximum flexibility in terms of markup code.
					</para>
				</listitem>
			</itemizedlist>

		</sect2>
		
	</sect1>
	
	<sect1 id="mvc-servlet">
		<title>The <literal>DispatcherServlet</literal></title>
		
		<para>
			Spring's web framework is - like many other web frameworks - designed around a servlet that dispatches requests
			to controller and offers other functionality facilitating the development of webapplications. Spring's
			<literal>DispatcherServlet</literal> however, does more than just that. It is completely integrated with
			the Spring ApplicationContext and makes fully use of that.
		</para>
		
		<para>
			Servlets are declared in the <literal>web.xml</literal> of your webapplication, so is the DispatcherServlet.
			Requests that you want the DispatcherServlet to handle, will have to be mapped, using a url-mapping in the same
			<literal>web.xml</literal> file.
		</para>
		<programlisting><![CDATA[<web-app>
	...
	<servlet>
		<servlet-name>example</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>example</servlet-name>
		<url-pattern>*.form</url-pattern>
	</servlet-mapping>    
</web-app>]]></programlisting>

		<para>
			In the example above, all requests ending with <literal>.form</literal> will be handled by the DispatcherServlet.
			Then, the DispatcherServlet needs to be configured. As illustrated in <xref linkend="context"/>, ApplicationContexts in
			Spring can be scoped. In the web framework, each DispatcherServlet has its own <literal>WebApplicationContext</literal>,
			which contains the DispatcherServlet configuration beans. The default BeanFactory used by the DispatcherServlet is the
			<literal>XmlBeanFactory</literal> and the DispatcherServlet will on initialization 
			<emphasis>look for a file named <literal>[servlet-name]-servlet.xml</literal></emphasis> in the <literal>WEB-INF</literal>
			directory of your web application. The default values used by the DispatcherServlet can be modified by using the
			servlet initialization parameters (see below for more information).
		</para>
		
		<para>
			The <literal>WebApplicationContext</literal> is just an ordinary ApplicationContext that has some extra features
			necessary for webapplications. It differs from a normal ApplicationContext in that it is capable of resolving
			themes (see <xref linkend="mvc-themes"/>) and that is knows to which servlet it is associated (by having a link
			to the <literal>ServletContext</literal>). The WebApplicationContext is bound in the ServletContext, and using
			<literal>RequestContextUtils</literal> you can always lookup the WebApplicationContext in case you need it.
		</para>
		
		<para>
			The Spring DispatcherServlet has a couple of special beans it uses, in order to be able to process requests
			and render the appropriate views. Those beans are included in the Spring framework and (optionally) have to be configured in 
			the WebApplicationContext, just as any other bean would have to configured. Each of those beans, is described
			in more detail below. Right now, we'll just mention them, just to let you know they exist and to enable us to
			go on talking about the DispatcherServlet. For most of the beans, defaults are provided so you don't have to
			worry about those.
		</para>
		
		<table frame="all">
			<title>Special beans in the WebApplicationContext</title>
			<tgroup cols="2">
				<colspec colname="c1" colwidth="1*"/>
				<colspec colname="c2" colwidth="4*"/>
				<thead>
					<row>
						<entry>Expression</entry>
						<entry>Explanation</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>handler mapping(s)</entry>
						<entry>(<xref linkend="mvc-handlermapping"/>) a list of pre- and postprocessors and controllers that 
							will be executed if they match certain criteria (for instance a matching URL specified with the
							controller)
						</entry>
					</row>
					<row>
						<entry>view resolver</entry>
						<entry>(<xref linkend="mvc-viewresolver"/>) capable of resolving view names and needed by the DispatcherServlet
							to resolves those views with
						</entry>
					</row>
					<row>
						<entry>locale resolver</entry>
						<entry>(<xref linkend="mvc-localeresolver"/>) capable of resolves the locale a client is using, in order
							to be able to offer internationalized views
						</entry>
					</row>
					<row>
						<entry>theme resolver</entry>
						<entry>(<xref linkend="mvc-themeresolver"/>) capable of resolving themes your webapplication can use e.g.
							to offer personalized layouts
						</entry>
					</row>
					<row>
						<entry>multipart resolver</entry>
						<entry>(<xref linkend="mvc-multipart"/>) offers functionality to process file uploads from HTML forms
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		
		<para>
			When a DispatcherServlet is setup for use and a request comes in for that specific DispatcherServlet it starts
			processing it. The list below describes the complete process a request goes through if a DispatcherServlet
			is supposed to handle it:
			
			<orderedlist spacing="compact">
				<listitem>
					<para>
						The WebApplicationContext is searched for and bound in the request as an attribute in order
						for controller and other elements in the chain of process to use it. It is bound by default under
						the key <literal>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						The locale resolver is bound to the request to let elements in the chain resolve the
						locale to use when processing the request (rendering the view, preparing data, etcetera).
						If you don't use the resolver, it won't affect anything, so if you don't need locale resolving,
						just don't bother
					</para>
				</listitem>
				<listitem>
					<para>
						The theme resolver is bound to the request to let e.g. views determine which theme to use
						(if you don't needs themes, don't bother, the resolver is just bound and does not
						affect anything if you don't use it)
					</para>
				</listitem>
				<listitem>
					<para>
						If a multipart resolver is specified, the request is inspected for multiparts and if so,
						it is wrapped in a <literal>MultipartHttpServletRequest</literal> for further processing
						by other elements in the chain (more information about multipart handling is provided
						below)
					</para>
				</listitem>
				<listitem>
					<para>
						An appropriate handler is searched for. If a handler is found, it execution chain
						associated to the handler (preprocessors, postprocessors, controllers) will be executed
						in order to prepare a model
					</para>
				</listitem>
				<listitem>
					<para>
						If a model is returned, the view is rendered, using the view resolver that has been
						configured with the WebApplicationContext. If no model was returned
						(which could be the result of a pre- or postprocessor intercepting the request because
						of for instance security reasons), no view is rendered as well, since the
						request could already have been fulfilled
					</para>
				</listitem>
			</orderedlist>
		</para>
		
		<para>
			The Spring DispatcherServlet also has support for returning the <emphasis>last-modification-date</emphasis>, 
			as specified by the Servlet API. The process of determining the last modification date for a specific
			request, is simple. The DispatcherServlet will first of all lookup an appropriate handler mapping 
			and test is the handler that matched <emphasis>implements the interface <literal>LastModified</literal></emphasis>
			and if so, the value the of <literal>long getLastModified(request)</literal> is returned to the client.
		</para>	
		
		<para>
			TODO: initialization parameters of the servlet
		</para>
		
	</sect1>
	
	<sect1 id="mvc-handlermapping">
		<title>Handler mappings</title>
	</sect1>
	
	<sect1 id="mvc-viewresolver">
		<title>Views and resolving them</title>
	</sect1>
	
	<sect1 id="mvc-localeresolver">
		<title>Using locales</title>
	</sect1>
	
	<sect1 id="mvc-themeresolver">
		<title>Using themes</title>
	</sect1>
	
	<sect1 id="mvc-multipart">
		<title>Spring's multipart (fileupload) support</title>	
		<sect2 id="mvc-multipart-introduction">
			<title>Introduction</title>
		
			<para>
				Spring has built-in multipart support to handle fileuploads in webapplications.
				The design for the multipart support is done in such a way that pluggable so-called
				<literal>MultipartResovlers</literal> can be used. Out of the box, Spring provides
				MultipartResolver for use with <emphasis>Commons FileUpload</emphasis> and
				<emphasis>COS FileUpload</emphasis>. How uploading files is supported will be described
				in the rest of this chapter.
			</para>
			<para>
				As already said, the multipart support is provided through the 
				<literal>MultipartResolver</literal> interface, located in the 
				<literal>org.springframework.web.multipart</literal> package. By default, no 
				multipart handling will be done by Spring. You'll have to enable it yourself by adding
				a multipartresolver to the webapplication's context. After you've done that, each
				request will be inspected for a multipart that it might contain. If no such multipart is
				found, the request will continue as expected. If however, a multipart is found in the
				request, the MultipartResolver that has been declared in your context will resolve.
				After that, the multipart attribute in your request will be treated as any other
				attributes.
			</para>
		
		</sect2>
		
		<sect2 id="mvc-multipart-resolver">
			<title>Using the <literal>MultipartResolver</literal></title>
			<para>
				To be able to resolve multiparts from a request, you will have to declare a MultipartResolver.
				There's two multipart resolver Spring's comes with. First of all the resolver that
				works with Commons FileUpload (<ulink url="http://jakarta.apache.org/commons/fileupload"/>),
				and secondly, the resolver that uses the O'Reilly COS package (<ulink url="http://www.servlets.com/cos"/>).
				Without a MultipartResolver declared in your webapplication context, no detection of multiparts
				will take place, because some developers might find the need to parse out the multiparts themselves.
			</para>
			<para>
				The following example shows how to use the <literal>CommonsMultipartResolver</literal>:
			<programlisting><![CDATA[
<bean id="multipartResolver" 
	class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
	
	<!-- one of the properties available; the maximum file size in bytes -->
	<property name="maximumFileSize">
		<value>100000</value>
	</property>
</bean>
			]]></programlisting>
				
				But you can also use the <literal>CosMultipartResolver</literal>:
				
			<programlisting><![CDATA[
<bean id="multipartResolver" 
	class="org.springframework.web.multipart.cos.CosMultipartResolver">
	
	<!-- one of the properties available; the maximum file size in bytes -->
	<property name="maximumFileSize">
		<value>100000</value>
	</property>
</bean>
]]></programlisting>
			</para>
			<para>
				Of course you need to stick the appropriate jars in your classpath if using one the 
				multipartresolver. In case of the CommonsMultipartResolver, you need to use <literal>commons-fileupload.jar</literal>,
				in case of the CosMultipartResolver, use <literal>cos.jar</literal>.
			</para>
			<para>
				Now that Spring's set up to handle multipart requests, let's talk about how to actually use it.
				When the Spring DispatcherServlet detects a Multipart request, it activates the resolver that has been
				declared in your context and hands over the request. What it basically does is wrap the current <literal>HttpServletRequest</literal>
				into a <literal>MultipartHttpServletRequest</literal> that has support for multiparts. Using the
				MultipartHttpServletRequest you can get information about the multiparts contained by this request
				and actually get the multiparts themselves in your controllers.
			</para>
		</sect2>
		
		<sect2 id="mvc.multipart-forms">
			<title>Handling a fileupload in a form</title>
			<para>
				After the MultipartResolver has finished doing its jobs, the request will be processed as any other.
				So in fact, you can create a form, with a form upload field, and let Spring bind the file on your form.
				Just as with any other property that's not automagically convertible to a String or primitive type,
				to be able to put binary data in your beans, you have to register a custom editor with the 
				<literal>ServletRequestDatabinder</literal>. There's a couple of editors available for handling
				file and setting the result on a bean. There's a <literal>StringMultipartEditor</literal> capable
				of converting files to Strings (using a user-defined character set) and there's a
				<literal>ByteArrayMultipartEditor</literal> which concerts files to byte-arrays. They function just as for
				instance the <literal>CustomDateEditor</literal>
			</para>
			<para>
				So, to be able to upload files using a form in a website, declare the resolver, a url mapping to a controller
				that will process the bean and the controller itself.
				<programlisting><![CDATA[
<beans>

	...

	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>

	<bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="mappings">
			<props>
				<prop key="/upload.form">fileUploadController</prop>
			</props>
		</property>
	</bean>

	<bean id="fileUploadController" class="examples.FileUploadController">
		<property name="commandClass"><value>examples.FileUploadBean</value></property>
		<property name="formView"><value>fileuploadform</value></property>
		<property name="successView"><value>confirmation</value></property>
	</bean>
	
</beans>
				]]></programlisting>
			</para>
			<para>
				After that, create the controller and the actual bean holding the file property
				<programlisting><![CDATA[
// snippet from FileUploadController
public class FileUploadController extends SimpleFormController {

	protected ModelAndView onSubmit(
		HttpServletRequest request,
		HttpServletResponse response,
		Object command,
		BindException errors)
		throws ServletException, IOException {
		
		// cast the bean
		FileUploadBean bean = (FileUploadBean)command;
		
		// let's see if there's content there
		byte[] file = bean.getFile();
		if (file == null) {
			// hmm, that's strange, the user did not upload anything
		}

		// well, let's do nothing with the bean for now and return:		
		return super.onSubmit(request, response, command, errors);
	}
	
	protected void initBinder(
		HttpServletRequest request,
		ServletRequestDataBinder binder)
		throws ServletException {
		// to actually be able to convert Multipart instance to byte[]
		// we have to register a custom editor (in this case the
		// ByteArrayMultipartEditor
		binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
		// now Spring knows how to handle multipart object and convert them
	}
		
}

// snippet from FileUploadBean
public class FileUploadBean {
	private byte[] file;
	
	public void setFile(byte[] file) {
		this.file = file;
	}
	
	public byte[] getFile() {
		return file;
	}
}
				]]></programlisting>
				
				As you can see, the FileUploadBean has a property typed byte[] that holds the
				file. The controller register a custom editor to let Spring know how to actually
				convert the multipart objects the resolver has found, to properties specified by
				the bean. Right now, nothing is done with the byte[] and the bean itself, but
				you can do with it whatever you want (save it in a database, mail it to somebody,
				etcetera).
			</para>
			<para>
				But we're still not finished. To actually let the user upload something, we have to
				create a form:
				<programlisting><![CDATA[
<html>
	<head>
		<title>Upload a file please</title>
	</head>
	<body>
		<h1>Please upload a file</h1>
		<form method="post" action="upload.form" enctype="multipart/form-data">
			<input type="file" name="file"/>
			<input type="submit"/>
		</form>
	</body>
</html>
				]]></programlisting>
				
				As you can see, we've created a field named after the property of the bean
				that holds the byte[]. Furthermore we've added the encoding attribute which
				is necessary to let the browser know how to encode the multipart fields
				(dont' forget this!).
				Right now everything should work.
			</para>
		</sect2>	
		
	</sect1>
		
</chapter>


