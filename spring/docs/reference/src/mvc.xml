<chapter id="mvc">

    <title>Web framework</title>
    
	<sect1 id="mvc-introduction">	
		
		<title>Introduction to the web framework</title>

		<para>
			Spring's web framework is designed around a DispatcherServlet that dispatches requests to handlers, with configurable handler mappings, view resolution, locale and theme resolution as well support for upload files. The default handler is a very simple Controller interface, just offering a <literal>ModelAndView handleRequest(request,response)</literal> method. This can already be used for application controllers, but you will prefer the included implementation hierarchy, consisting of for example <literal>AbstractController</literal>, <literal>AbstractCommandController</literal> and <literal>SimpleFormController</literal>. Application controllers will typically be subclasses of those. Note that you can choose an appropriate base class: If you don't have a form, you don't need a FormController. This is a major difference to Struts.
		</para>

		<para>
			You can take any object as command or form object: There's no need to implement an interface or derive from a base class. Spring's data binding is highly flexible, e.g. it treats type mismatches as validation errors that can be evaluated by the application, not as system errors. So you don't need to duplicate your business objects' properties as Strings in your form objects, just to be able to handle invalid submissions, or to convert the Strings properly. Instead, it's often preferable to bind directly to your business objects. This is another major difference to Struts which is built around required base classes like <literal>Action</literal> and <literal>ActionForm</literal> - for every type of action.
		</para>

		<para>
			Compared to WebWork, Spring has more differentiated object roles: It supports the notion of a Controller, an optional command or form object, and a model that gets passed to the view. The model will normally include the command or form object but also arbitrary reference data. Instead, a WebWork Action combines all those roles into one single object. WebWork does allow you to use existing business objects as part of your form, but just by making them bean properties of the respective Action class. Finally, the same Action instance that handles the request gets used for evaluation and form population in the view. Thus, reference data needs to be modelled as bean properties of the Action too. These are arguably too many roles in one object. 
		</para>

		<para>
			Regarding views: Spring's view resolution is extremely flexible. A Controller implementation can even write a view directly to the response, returning null as ModelAndView. In the normal case, a ModelAndView instance consists of a view name and a model Map, containing bean names and corresponding objects (like a command or form, reference data, etc). View name resolution is highly configurable, either via bean names, via a properties file, or via your own ViewResolver implementation. The abstract model Map allows for complete abstraction of the view technology, without any hassle: Be it JSP, Velocity, or anything else - every renderer can be integrated directly. The model Map simply gets transformed into an appropriate format, like JSP request attributes or a Velocity template model. 
		</para>

		<sect2 id="mvc-introduction-pluggability">		

			<title>Pluggability of MVC implementation</title>

			<para>
				Many teams will try to leverage their investments in terms of know-how and tools, both for existing projects and for new ones. Concretely, there are not only a large number of books and tools for Struts but also a lot of developers that have experience with it. Thus, if you can live with Struts' architectural flaws, it can still be a viable choice for the web layer. The same applies to WebWork and other web frameworks.
			</para>

			<para>
				If you don't want to use Spring's web MVC but intend to leverage other solutions that Spring offers, you can integrate the web framework of your choice with Spring easily. Simply start up a Spring root application context via its ContextLoaderListener, and access it via its ServletContext attribute (or Spring's respective helper method) from within a Struts or WebWork action. Note that there aren't any "plugins" involved, therefore no dedicated integration: From the view of the web layer, you'll simply use Spring as a library, with the root application context instance as entry point.
			</para>

			<para>
				All your registered beans and all of Spring's services can be at your fingertips even without Spring's web MVC. Spring doesn't compete with Struts or WebWork in this usage, it just addresses the many areas that the pure web frameworks don't, from bean configuration to data access and transaction handling. So you are able to enrich your application with a Spring middle tier and/or data access tier, even if you just want to use e.g. the transaction abstraction with JDBC or Hibernate.
			</para>

		</sect2>
		
		<sect2 id="mvc-features">
			<title>Features of Spring MVC</title>

			<para>
				If just focussing on the web support, some of the Spring's unique features are:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Clear separation of roles: controller vs validator vs command object vs form object vs model object, DispatcherServlet vs handler mapping vs view resolver, etc.
					</para>
				</listitem>
				<listitem>
					<para>
						Powerful and straightforward configuration of both framework and application classes as JavaBeans, including easy in-between referencing via an application context, e.g. from web controllers to business objects and validators.
					</para>
				</listitem>
				<listitem>
					<para>
						Adaptability, non-intrusiveness: Use whatever Controller subclass you need (plain, command, form, wizard, multi action, or a custom one) for a given scenario instead of deriving from Action/ActionForm for everything.
					</para>
				</listitem>
				<listitem>
					<para>
						Reusable business code, no need for duplication: You can use existing business objects as command or form objects instead of mirroring them in special ActionForm subclasses.
					</para>
				</listitem>
				<listitem>
					<para>
						Customizable binding and validation: type mismatches as application-level validation errors that keep the offending value, localized date and number binding, etc instead of String-only form objects with manual parsing and conversion to business objects.
					</para>
				</listitem>
				<listitem>
					<para>
						Customizable handler mapping, customizable view resolution: flexible model transfer via name/value Map, handler mapping and view resolution strategies from simple to sophisticated instead of one single way.
					</para>
				</listitem>
				<listitem>
					<para>
						Customizable locale and theme resolution, support for JSPs with and without Spring tag library, support for JSTL, support for Velocity without the need for extra bridges, etc.
					</para>
				</listitem>
				<listitem>
					<para>
						Simple but powerful tag library that avoids HTML generation at any cost, allowing for maximum flexibility in terms of markup code.
					</para>
				</listitem>
			</itemizedlist>

		</sect2>
		
	</sect1>
	
	<sect1 id="mvc-servlet">
		<title>The <literal>DispatcherServlet</literal></title>
		
		<para>
			Spring's web framework is - like many other web frameworks - designed around a servlet that dispatches requests
			to controller and offers other functionality facilitating the development of webapplications. Spring's
			<literal>DispatcherServlet</literal> however, does more than just that. It is completely integrated with
			the Spring ApplicationContext and makes fully use of that.
		</para>
		
		<para>
			Servlets are declared in the <literal>web.xml</literal> of your webapplication, so is the DispatcherServlet.
			Requests that you want the DispatcherServlet to handle, will have to be mapped, using a url-mapping in the same
			<literal>web.xml</literal> file.
		</para>
		<programlisting><![CDATA[<web-app>
	...
	<servlet>
		<servlet-name>example</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>example</servlet-name>
		<url-pattern>*.form</url-pattern>
	</servlet-mapping>    
</web-app>]]></programlisting>

		<para>
			In the example above, all requests ending with <literal>.form</literal> will be handled by the DispatcherServlet.
			Then, the DispatcherServlet needs to be configured. As illustrated in <xref linkend="context"/>, ApplicationContexts in
			Spring can be scoped. In the web framework, each DispatcherServlet has its own <literal>WebApplicationContext</literal>,
			which contains the DispatcherServlet configuration beans. The default BeanFactory used by the DispatcherServlet is the
			<literal>XmlBeanFactory</literal> and the DispatcherServlet will on initialization 
			<emphasis>look for a file named <literal>[servlet-name]-servlet.xml</literal></emphasis> in the <literal>WEB-INF</literal>
			directory of your web application. The default values used by the DispatcherServlet can be modified by using the
			servlet initialization parameters (see below for more information).
		</para>
		
		<para>
			The <literal>WebApplicationContext</literal> is just an ordinary ApplicationContext that has some extra features
			necessary for webapplications. It differs from a normal ApplicationContext in that it is capable of resolving
			themes (see <xref linkend="mvc-themes"/>) and that is knows to which servlet it is associated (by having a link
			to the <literal>ServletContext</literal>). The WebApplicationContext is bound in the ServletContext, and using
			<literal>RequestContextUtils</literal> you can always lookup the WebApplicationContext in case you need it.
		</para>
		
		<para>
			The Spring DispatcherServlet has a couple of special beans it uses, in order to be able to process requests
			and render the appropriate views. Those beans are included in the Spring framework and (optionally) have to be configured in 
			the WebApplicationContext, just as any other bean would have to be configured. Each of those beans, is described
			in more detail below. Right now, we'll just mention them, just to let you know they exist and to enable us to
			go on talking about the DispatcherServlet. For most of the beans, defaults are provided so you don't have to
			worry about those.
		</para>
		
		<table frame="all">
			<title>Special beans in the WebApplicationContext</title>
			<tgroup cols="2">
				<colspec colname="c1" colwidth="1*"/>
				<colspec colname="c2" colwidth="4*"/>
				<thead>
					<row>
						<entry>Expression</entry>
						<entry>Explanation</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>handler mapping(s)</entry>
						<entry>(<xref linkend="mvc-handlermapping"/>) a list of pre- and postprocessors and controllers that 
							will be executed if they match certain criteria (for instance a matching URL specified with the
							controller)
						</entry>
					</row>
					<row>
						<entry>controller(s)</entry>
						<entry>(<xref linkend="mvc-controllers"/>) the beans providing the actual functionality (or at least, 
							access to the functionality) as part of the MVC triad
						</entry>
					</row>
					<row>
						<entry>view resolver</entry>
						<entry>(<xref linkend="mvc-viewresolver"/>) capable of resolving view names and needed by the DispatcherServlet
							to resolves those views with
						</entry>
					</row>
					<row>
						<entry>locale resolver</entry>
						<entry>(<xref linkend="mvc-localeresolver"/>) capable of resolves the locale a client is using, in order
							to be able to offer internationalized views
						</entry>
					</row>
					<row>
						<entry>theme resolver</entry>
						<entry>(<xref linkend="mvc-themeresolver"/>) capable of resolving themes your webapplication can use e.g.
							to offer personalized layouts
						</entry>
					</row>
					<row>
						<entry>multipart resolver</entry>
						<entry>(<xref linkend="mvc-multipart"/>) offers functionality to process file uploads from HTML forms
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		
		<para>
			When a DispatcherServlet is setup for use and a request comes in for that specific DispatcherServlet it starts
			processing it. The list below describes the complete process a request goes through if a DispatcherServlet
			is supposed to handle it:
			
			<orderedlist spacing="compact">
				<listitem>
					<para>
						The WebApplicationContext is searched for and bound in the request as an attribute in order
						for controller and other elements in the chain of process to use it. It is bound by default under
						the key <literal>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</literal>
					</para>
				</listitem>
				<listitem>
					<para>
						The locale resolver is bound to the request to let elements in the chain resolve the
						locale to use when processing the request (rendering the view, preparing data, etcetera).
						If you don't use the resolver, it won't affect anything, so if you don't need locale resolving,
						just don't bother
					</para>
				</listitem>
				<listitem>
					<para>
						The theme resolver is bound to the request to let e.g. views determine which theme to use
						(if you don't needs themes, don't bother, the resolver is just bound and does not
						affect anything if you don't use it)
					</para>
				</listitem>
				<listitem>
					<para>
						If a multipart resolver is specified, the request is inspected for multiparts and if so,
						it is wrapped in a <literal>MultipartHttpServletRequest</literal> for further processing
						by other elements in the chain (more information about multipart handling is provided
						below)
					</para>
				</listitem>
				<listitem>
					<para>
						An appropriate handler is searched for. If a handler is found, it execution chain
						associated to the handler (preprocessors, postprocessors, controllers) will be executed
						in order to prepare a model
					</para>
				</listitem>
				<listitem>
					<para>
						If a model is returned, the view is rendered, using the view resolver that has been
						configured with the WebApplicationContext. If no model was returned
						(which could be the result of a pre- or postprocessor intercepting the request because
						of for instance security reasons), no view is rendered as well, since the
						request could already have been fulfilled
					</para>
				</listitem>
			</orderedlist>
		</para>
		
		<para>
			The Spring DispatcherServlet also has support for returning the <emphasis>last-modification-date</emphasis>, 
			as specified by the Servlet API. The process of determining the last modification date for a specific
			request, is simple. The DispatcherServlet will first of all lookup an appropriate handler mapping 
			and test is the handler that matched <emphasis>implements the interface <literal>LastModified</literal></emphasis>
			and if so, the value the of <literal>long getLastModified(request)</literal> is returned to the client.
		</para>	
		
		<para>
			TODO: initialization parameters of the servlet
		</para>
		
	</sect1>
	
	<sect1 id="mvc-controller">
		<title>Controllers</title>
		<para>
			The notion of controller is part of the MVC design pattern. Controllers define application behavior, or at least
			provide users with access to the application behavior. Controllers interpret user input and transform the user input
			into a sensible model which will be represented to the user by the view. Spring has implemented the notion
			of a controller in a very abstract way enabling a wide variety of different kinds of controllers to be created. 
			Spring contains formcontroller, commandcontroller, controllers that execute wizard-style logic and more.			
		</para>
		
		<para>
			Spring's basis for the controller architecture is the <literal>org.springframework.mvc.Controller</literal> interface, which
			is listed below.
			<programlisting><![CDATA[
public interface Controller {

	/**
	 * Process the request and return a ModelAndView object which the DispatcherServlet
	 * will render.
	 */
	ModelAndView handleRequest(
		HttpServletRequest request, 
		HttpServletResponse response) 
	throws Exception;
}
			]]></programlisting>
			
			As you can see, the Controller interface just states one single method that should be capable of 
			handling a request and return an appropriate model and view. Those three concepts are the basis for the 
			Spring MVC implemente; <emphasis>ModelAndView</emphasis> and <emphasis>Controller</emphasis>.
			While the Controller interface is quite abstract, Spring offers a lot of controllers that already
			contain a lot of functionality you might need. The controller interface just define the most commons
			functionality offered by every controller: the functionality of handling a request and returning a model 
			and a view.
		</para>
		
		<sect2 id="mvc-controller-abstractcontroller">
			<title>Using the <literal>AbstractController</literal> and <literal>WebContentGenerator</literal></title>
			<para>
				Of course, jsut a controller interface isn't enough. To provide a basic infrastructure, all Spring's
				Controller inherit from AbstractController, a class offering caching support and for instance the setting
				of the mimetype.
			</para>
			
			<table id="mvc-controller-abstract-features" frame="all">
				<title>Features offered by the <literal>AbstractController</literal></title>
				<tgroup cols="2">
					<colspec colname="c1" colwidth="1*"/>
					<colspec colname="c2" colwidth="3*"/>
					<thead>
						<row>
							<entry>Feature</entry>
							<entry>Explanation</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><literal>supportedMethods</literal></entry>
							<entry>indicates what methods this controller should accept. Usually this is set to both
								<literal>GET</literal> and <literal>POST</literal>, but you can modify this to reflect
								the method you want to support. If a request is received with a method that is not supported
								by the controller, the client will be informed of this (using a <literal>ServletException)</literal>)
							</entry>
						</row>
						<row>
							<entry><literal>requiresSession</literal></entry>
							<entry>indicates whether or not this controller requires a session to do its work. This
								feature is offered to all controllers. If a session is not present when such a controller
								receives a request, the user is informed using a <literal>ServletException</literal>								
							</entry>
						</row>
						<row>
							<entry><literal>synchronizeSession</literal></entry>
							<entry>
								use this if you want handling by this controller to be synchronized on the user's session.
								To be more specific, extending controller will override the <literal>handleRequestInternal</literal>
								method, which will be synchronized if you specify this variable
							</entry>
						</row>
						<row>
							<entry><literal>cacheSeconds</literal></entry>
							<entry>
								when you want a controller to generate caching directive in the HTTP response, specify
								a positive integer here. By default it is set to <emphasis>-1</emphasis> so no caching
								directives will be included
							</entry>
						</row>
						<row>
							<entry><literal>useExpiresHeader</literal></entry>
							<entry>
								tweaking of your controllers specifying the HTTP 1.0 compatible
								<emphasis>"Expires"</emphasis> header. By default it's set to true, so you won't have
								to touch it
							</entry>
						</row>
						<row>
							<entry><literal>useCacheHeader</literal></entry>
							<entry>
								tweaking of your controllers specifying the HTTP 1.1 compatible
								<emphasis>"Cache-Control"</emphasis> header. By default this is set to true so
								you won't really have to touch it
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			
			<emphasis>
				the last two properties are actually part of the <literal>WebContentGenerator</literal> which is the superclass
				of <literal>AbstractController</literal> but to keeps things clear...
			</emphasis>
			
			<para>
				When using the AbstractController as a baseclass for your controllers (which is <emphasis>not</emphasis> recommended
				since there are a lot of other controller that might already do the job for your) you only have to override the
				<literal>handleRequestInternal(HttpServletRequest, HttpServletResponse)</literal>-method and implement your logic
				code and return a <literal>ModelAndView</literal> object there. A short example consisting of a class and a declaration
				in the webapplicationcontext.
				<programlisting><![CDATA[
package samples;

public class SampleController extends AbstractController {

	public ModelAndView handleRequestInternal(
		HttpServletRequest request,
		HttpServletResponse response)
	throws Exception {
	
		ModelAndView mav = new ModelAndView("foo", new HashMap());
	}
}
				]]></programlisting>
				
				<programlisting><![CDATA[
<bean id="sampleController" class="samples.SampleController">
	<property name="cacheSeconds"><value>120</value</property>
</bean>
				]]></programlisting>
				
				The class above and the declaration in the webapplicationcontext is all you need to do besides setting up a handler mapping
				(see <xref linkend="mvc-handlermapping"/>) to get this very simple controller working. This controller will generates caching
				directives telling the client to cache things for 2 minutes before rechecking. This controller furthermore returns an hard-coded
				view (hmm, not so nice), named index (see <xref linkend="mvc-viewresolver"/> for more information about views).
			</para>
		</sect2>
		
		<sect2 id="mvc-controller-othersimplecontrollers">
			<title>Other simple controller</title>
			<para>
				Besides the AbstractController - which you could of course extend, although a more concrete controller might offer you more
				functionality - there are a couple of other simple controllers that might easy the pain of developing simple MVC applications.
				The <literal>ParameterizableViewController</literal> basically is the same as the one in the example above, except for the
				fact that you can specify its view name that it'll be returning in the webapplicationcontext (ahhh, no need to hard-code the viewname).
				The viewname you 
			</para>
			<para>
				The <literal>FileNameViewController</literal> inspects the URL and retrieves the filename of the file request (the filename of 
				<literal>http://www.springframework.org/index.html</literal> is <literal>index</literal>) and uses that as a viewname. Nothing more
				to it.
			</para>
		</sect2>
		
		<sect2 id="mvc-controller-multiaction">
			<title>The <literal>MultiActionController</literal></title>
			<para>
				Spring offers a multi-action controller with which you aggregate multiple actions into one controller, grouping functionality
				together. The multi-action controller lives in a separate package - <literal>org.springframework.web.mvc.multiaction</literal>
				- and is capable of mapping requests to method names and then invoking the right method name. Using the multi-action controller
				is especially handy when you're having a lot of commons functionality in one controller, but want to have multiple entry points
				to the controller to tweak behavior for instance.
			</para>
			
			<table id="mvc-controller-multiaction-features" frame="all">
				<title>Features offered by the <literal>MultiActionController</literal></title>
				<tgroup cols="2">
					<colspec colname="c1" colwidth="1*"/>
					<colspec colname="c2" colwidth="3*"/>
					<thead>
						<row>
							<entry>Feature</entry>
							<entry>Explanation</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><literal>delegate</literal></entry>
							<entry>there's two usage-scenarios for the MultiActionController. Either you subclass the MultiActionController
								and specify the methods that will be resolved by the MethodNameResolver on the subclass (in case you
								don't need this configuration parameter), or you define a delegate oject, on which methods resolved by the
								Resolver will be invoked. If you choose to enter this scenario, you will have to define the delegate
								using this configuration parameter as a collaborator
							</entry>
						</row>
						<row>
							<entry><literal>methodNameResolver</literal></entry>
							<entry>somehow, the MultiActionController will need to resolve the method it has to invoke, based
								on the request that came in. You can define a resolver that is capable of doing that using
								this configuration parameter
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			
			<para>
				Methods defined for a multi-action controller will need to conform to the following signature:
				<programlisting><![CDATA[
// actionName can be replaced by any methodname
ModelAndView actionName(HttpServletRequest, HttpServletResponse);
				]]></programlisting>
				Method overloading is not allowed since it'll confuse the MultiActionController. Furthermore, you can define
				<emphasis>exception handlers</emphasis> capable of handling exception that will be thrown form a method you specify.
				Exception handler methods need to return a ModelAndView object, just as any other action method and will need to conform to the following
				signature: 
				<programlisting><![CDATA[
// anyMeaningfulName can be replaced by any methodname
ModelAndView anyMeaningfulName(HttpServletRequest, HttpServletResponse, ExceptionClass);
				]]></programlisting>
				The <literal>ExceptionClass</literal> can be <emphasis>any</emphasis> exception, as long as it's a subclass of 
				<literal>java.lang.Exception</literal> or <literal>java.lang.RuntimeException</literal>.
			</para>
			
			<para>
				The <literal>MethodNameResolver</literal> is supposed to resolve method names based on the request coming in. There are three
				resolver to your disposal, but of course you can implement more of them yourself if you want.
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							<literal>ParameterMethodNameResolver</literal> - capable of resolving a request parameter and using that as the
							method name (<literal>http://www.sf.net/index.view?testParam=testIt</literal> will result in a method
							<literal>testIt(HttpServletRequest, HttpServletResponse)</literal> being called). Use the
							<literal>paramName</literal> configuration parameter to tweak the parameter that's inspected)
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>InternalPathMethodNameResolver</literal> - retrieves the filename from the path and uses that
							as the method name (<literal>http://www.sf.net/testing.view</literal> will result in a method
							<literal>testing(HttpServletRequest, HttpServletResponse)</literal> being called)
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>PropertiesMethodNameResolver</literal> - uses a user-defined properties object with
							request URLs mapped to methodnames. When the properties contain <literal>/index/welcome.html=doIt</literal>
							and a request to <literal>/index/welcome.html</literal> comes in, the 
							<literal>doIt(HttpServletRequest, HttpServletResponse)</literal> method is called. This method name resolver
							works with the <literal>PathMatcher</literal> (see <xref linkend="mvc-utilities-pathmatcher"/>) so
							if the properties contained <literal>/**/welcom?.html</literal> it would also have worked!
						</para>
					</listitem>
				</itemizedlist>
			</para>
			
			<para>
				A couple of examples. First of all one showing the <literal>ParameterMethodNameResolver</literal> and
				the delegate property, which will accept requests to urls with the parameter method included and set
				to <literal>retrieveIndex</literal>:
				
				<programlisting><![CDATA[					
<bean id="paramResolver" class="org....mvc.multiaction.ParameterMethodNameResolver">
	<property name="paramName"><value>method</value></property>
</bean>

<bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController">
	<property name="methodNameResolver"><ref bean="paramResolver"/></property>
	<property name="delegate"><ref bean="sampleDelegate"/>
</bean>

<bean id="sampleDelegate" class="samples.SampleDelegate"/>

## together with

public class SampleDelegate {

	public ModelAndView retrieveIndex(
		HttpServletRequest req, 
		HttpServletResponse resp) {

		rerurn new ModelAndView("index", "date", new Long(System.currentTimeMillis()));
	}
}							
				]]></programlisting>
				
				When using the delegates shown above, we could also use the <literal>PropertiesMethodNameRseolver</literal>
				to match a couple of URLs to the method we defined:
				
				<programlisting><![CDATA[
<bean id="propsResolver" class="org....mvc.multiaction.PropertiesMethodNameResolver">
	<property name="mappings">
		<props>
			<prop key="/index/welcome.html">retrieveIndex</prop>
			<prop key="/**/notwelcome.html">retrieveIndex</prop>
			<prop key="/*/user?.html">retrieveIndex</prop>
		</props>
	</property>
</bean>

<bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController">
	<property name="methodNameResolver"><ref bean="propsResolver"/></property>
	<property name="delegate"><ref bean="sampleDelegate"/>
</bean>
				]]></programlisting>
				
			</para>
			
		</sect2>
			
		<sect2 id="mvc-controller-command">
			<title>CommandControllers</title>
			<para>
				Spring's <emphasis>CommandControllers</emphasis> are a fundamental part of the Spring MVC package. Command controllers provide
				a way to interact with dataobjects and dynamically bind parameters from the <literal>HttpServletRequest</literal> to the
				dataobject you're specifying. This compares to Struts actionforms, where in Spring, you don't have to implement any interface
				of superclasses to do databinding. First, let's examine what command controllers available, just to get clear picture of what
				you can do with them:
				
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							<literal>AbstractCommandController</literal> - a command controller you can use to create your own
							command controller, capable of binding request parameters to a data object you're specifying. This class does not
							offer form functionality, it does however, offer validation features and let's you specify in the controller
							itself what to do with the dataobject that has been filled with the parameters from the request.
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>AbstractFormController</literal> - an abstract controller offering form submission support.
							Using this controller you can model forms and populate them using a dataobject you're retrieving in the
							controller. After a user has filled the form, the AbstractFormController binds the fields, validates and
							hands the object back to you - the controller - to take appropriate action. Supported features are
							invalid form submission (resubmission), validation, and the right workflow a form always has. What
							views you tie to your AbstractFormController you decide yourself. Use this controller if you need forms,
							but don't want to specify what views you're going to show the user in the applicationcontext
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>SimpleFormController</literal> - an even more concrete FormCotnroller that helps you
							creating a form with corresponding data object even more. The SimpleFormController let's you specify a
							command object, a viewname for the form, a viewname for page you want to show the user when formsubmission
							has succeeded, and more
						</para>
					</listitem>
					<listitem>
						<para>
							<literal>WizardFormController</literal> - last but not least, a WizardFormController allows you
							to model wizard-style manipulation of dataobjects, which is extremely handy when large dataobjects come in
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>		
	</sect1>
		
	
	<sect1 id="mvc-handlermapping">
		<title>Handler mappings</title>
        <para>
            Using a handler mapping you can map incoming web requests to appropriate handlers. There are some handler mapping
            you can use, for example the <literal>SimpleUrlHandlerMapping</literal> or the <literal>BeanNameUrlHandlerMapping</literal>, but
            let's first examine the general concept of a <literal>HandlerMapping</literal>.
        </para>
        
        <para>
            The functionality a basic <literal>HandlerMapping</literal> provides is the delivering of a <literal>HandlerExecutionChain</literal>,
            first of all containing one handler that matched the incoming request. The second (but optional) element a
            handler execution chain will contain is a list of handler interceptor that should be applied to the request.
            When a request comes in, the <literal>DispatcherServlet</literal> will hand it over to the handler mapping to let it
            inspect the request and come up with an appropriate HandlerExecutionChain. When done, the DispatcherServlet will
            execute the handler and interceptors in the chain (if any).
        </para>
        
        <para>
            The concept of configurable handler mappings that can optionally contain interceptors (executed before or after
            the actual handler was executed, or both) is extremely powerful. A lot of supporting functionality can be built-in
            in custom <literal>HandlerMappings</literal>. Think of a custom handler mapping that chooses a handler not only based on
            the URL of the request coming in, but also on a specific state of the session associated with the request.
        </para>
        
        <para>
            Let's examine the handler mappings that Spring provides.
        </para>
        
        <sect2 id="mvc-handlermapping-beanname">
            <title><literal>BeanNameUrlHandlerMapping</literal></title>
            <para>
                A very simple, but very powerful handlermapping is the <literal>BeanNameUrlHandlerMapping</literal>, which
                maps incoming Http-requests to names of beans, defined in the webapplicationcontext. Let's say we want
                to enable a user to insert an account and we've already provided an appropriate FormController
                (see <xref linkend="mvc-controller-command"/> for more information on Command- and FormControllers) and
                an JSP view (or Velocity template) that renders the form. When using the BeanNameUrlHandlerMapping, we could
                map the Http-request with URL <literal>http://samples.com/editaccount.form</literal> to the appropriate
                FormController as follows:
                <programlisting><![CDATA[
<beans>
    <bean 
            id="handlerMapping" 
            class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
        
    <bean 
            name="/editaccount.form"
            class="org.springframework.web.servlet.mvc.SimpleFormController">
        <property name="formView"><value>account</value></property>
        <property name="successView"><value>account-created</value></property>
        <property name="commandName"><value>Account</value></property>
        <property name="commandClass"><value>samples.Account</value></property>
    </bean>
<beans>
                ]]></programlisting>
                All incoming requests for the URL <literal>/editaccount.form</literal>
                will now be handled by the FormController in the source listing above.
                Of course we have to define a servlet-mapping in web.xml as well,
                to let through all the requests ending with .form.
                <programlisting><![CDATA[
<web-app>
    ...
    <servlet>
	    <servlet-name>sample</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
    </servlet>

  <!-- Maps the sample dispatcher to /*.form -->
    <servlet-mapping>
        <servlet-name>sample</servlet-name>
        <url-pattern>*.form</url-pattern>
    </servlet-mapping>
    ...
</web-app>    
                ]]></programlisting>
            </para>
            
            <para>
                <emphasis>NOTE: if you want to use the <literal>BeanNameUrlHandlerMapping</literal>,
                you don't necessarily have to define it in the webapplicationcontext (as indicated above).
                By default, if no handler mapping can be found in the context,
                the DispatcherServlet creates a <literal>BeanNameUrlHandlerMapping</literal> for you!
                </emphasis>
            </para>
        </sect2>   
        
        <sect2 id="mvc-handlermapping-urlhandlermapping">
            <title><literal>SimpleUrlHandlerMapping</literal></title>
            <para>
                Another - and much more powerful handlermapping - is the
                the <literal>SimpleUrlHandlerMapping</literal>. This mapping
                is configurable in the applicationcontext and has 
                Ant-style pathmatching capabilities (see <xref linkend="mvc-utilities-pathmatching"/>).
                A couple of example will probably makes thing clear enough:
                <programlisting><![CDATA[
<web-app>
    ...
    <servlet>
	    <servlet-name>sample</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
    </servlet>

  <!-- Maps the sample dispatcher to /*.form -->
    <servlet-mapping>
        <servlet-name>sample</servlet-name>
        <url-pattern>*.form</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>sample</servlet-name>
        <url-pattern>*.html</url-pattern>
    </servlet-mapping>
    ...
</web-app>    
                ]]></programlisting>
                Allows all requests ending with .html and .form to be handled
                by the sample dispatcherservlet.
                <programlisting><![CDATA[
<beans>
    <bean 
            id="handlerMapping" 
            class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">            
        <property name="mappings">
            <props>
                <prop key="/*/account.form">editAccountFormController</prop>
                <prop key="/*/editaccount.form">editAccountFormController</prop>
                <prop key="/ex/view*.html">someViewController</prop>
                <prop key="/**/help.html
            </props>
        </property>
    </bean>
    
    <bean
            id="someViewController"
            class="org.springframework.web.servlet.mvc.FilenameViewController"/>
    
    <bean 
            id="editAccountFormController"
            class="org.springframework.web.servlet.mvc.SimpleFormController">
        <property name="formView"><value>account</value></property>
        <property name="successView"><value>account-created</value></property>
        <property name="commandName"><value>Account</value></property>
        <property name="commandClass"><value>samples.Account</value></property>
    </bean>
<beans>    
                ]]></programlisting>
                This handlermapping first of all reroutes all requests 
                in all directories for a file named <literal>help.html</literal>
                to the <literal>someViewController</literal>, which is a
                FilenameViewController (more about that can be found in 
                <xref linkend="mvc-controller"/>). Also, all requests for a 
                resource beginning with <literal>view</literal>, ending
                with <literal>.html</literal>, in the directory <literal>ex</literal>,
                will be rerouted to that specific controller. Furtermore,
                two mappings have been defined that will match with the
                <literal>editAccountFormController</literal>
            </para>
        </sect2>
        
        <sect2 id="mvc-handlermapping-interceptor">
            <title>Adding <literal>HandlerInterceptors</literal></title>
            <para>
                The handler mapping also has a notion of handler interceptors,
                that can be extremely useful when you want to apply specific
                functionality to all requests, for example the checking for a 
                principal or something alike.
            </para>
            <para>
                Interceptors located in the handler mapping must implement
                <literal>HandlerInterceptor</literal> from the 
                <literal>org.springframework.web.servlet</literal>-package. This interface
                defines three methods, one that will be called <emphasis>before</emphasis>
                the actual handler will be executed, one that will be 
                called <emphasis>after</emphasis> the handler is executed, and
                one that is called <emphasis>after the complete request
                has finished</emphasis>. Those three methods should provide you
                with enough flexibility to do all kinds of pre- and postprocessing.
            </para>
            <para>
                The <literal>preHandle</literal> method has a boolean return value.
                Using this value, you can tweak the behavior of the execution chain.
                When returning <literal>true</literal>, the handler execution chain
                will continue, when returning false, the DispatcherServlet assumes
                the interceptor itself has taken care of requests (and  for instance
                rendered an appropriate view) and does not continue with executing
                the other interceptors and the actual handler in the execution chain.
            </para>
            
            <para> 
                The following example provides an interceptor that
                intercepts all requests and reroutes the user to a specific page
                if the time is not between 9 a.m. and 6 p.m.
            
                <programlisting><![CDATA[
<beans>
    <bean 
            id="handlerMapping" 
            class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">            
        <property name="interceptors">
			<list>
				<ref bean="officeHoursInterceptor"/>
			</list>
		</property>
        <property name="mappings">
            <props>
                <prop key="/*.form">editAccountFormController</prop>
                <prop key="/*.view">editAccountFormController</prop>
            </props>
        </property>
    </bean>
    
    <bean 
            id="officeHoursInterceptor" 
            class="samples.TimeBasedAccessInterceptor">
        <property name="openingTime"><value>9</value></property>
        <property name="closingTime"><value>18</value></property>
    </bean>    
<beans>    
                ]]></programlisting>
                
                <programlisting><![CDATA[
package samnples;

public class TimeBasedAccessInterceptor implements HandlerInterceptor {

    private int openingTime;    
    private int closingTime;    
    public void setOpeningTime(int openingTime) {
        this.openingTime = openingTime;
    }    
    public void setClosingTime(int closingTime) {
        this.closingTime = closingTime;
    }    
    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler)
    throws Exception {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(HOUR_OF_DAY);
        if (openingTime <= hour < closingTime) {
            return true;
        } else {
            response.sendRedirect("http://host.com/outsideOfficeHours.html");
            return false;
        }
    }
    
    public void postHandle(
            HttpServletRequest request, 
            HttpServletResponse response,
            Object handler)
    throws Exception {     // do nothing      }
    
    public void afterCompletion(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler, 
            Exception ex) 
    throws Exception {     // do nothing      }
}
                ]]></programlisting>
                Any request coming in, will be intercepted by the
                <literal>TimeBasedAccessInterceptor</literal>, and if the
                current time is outside office hours, the user will be redirect
                to a static html file, saying for instance he can only access
                the website during office hours.
            </para>
        </sect2>
	</sect1>
	
	<sect1 id="mvc-viewresolver">
		<title>Views and resolving them</title>
	</sect1>
	
	<sect1 id="mvc-localeresolver">
		<title>Using locales</title>
	</sect1>
	
	<sect1 id="mvc-themeresolver">
		<title>Using themes</title>
	</sect1>
	
	<sect1 id="mvc-multipart">
		<title>Spring's multipart (fileupload) support</title>	
		<sect2 id="mvc-multipart-introduction">
			<title>Introduction</title>
		
			<para>
				Spring has built-in multipart support to handle fileuploads in webapplications.
				The design for the multipart support is done in such a way that pluggable so-called
				<literal>MultipartResovlers</literal> can be used. Out of the box, Spring provides
				MultipartResolver for use with <emphasis>Commons FileUpload</emphasis> and
				<emphasis>COS FileUpload</emphasis>. How uploading files is supported will be described
				in the rest of this chapter.
			</para>
			<para>
				As already said, the multipart support is provided through the 
				<literal>MultipartResolver</literal> interface, located in the 
				<literal>org.springframework.web.multipart</literal> package. By default, no 
				multipart handling will be done by Spring. You'll have to enable it yourself by adding
				a multipartresolver to the webapplication's context. After you've done that, each
				request will be inspected for a multipart that it might contain. If no such multipart is
				found, the request will continue as expected. If however, a multipart is found in the
				request, the MultipartResolver that has been declared in your context will resolve.
				After that, the multipart attribute in your request will be treated as any other
				attributes.
			</para>
		
		</sect2>
		
		<sect2 id="mvc-multipart-resolver">
			<title>Using the <literal>MultipartResolver</literal></title>
			<para>
				To be able to resolve multiparts from a request, you will have to declare a MultipartResolver.
				There's two multipart resolver Spring's comes with. First of all the resolver that
				works with Commons FileUpload (<ulink url="http://jakarta.apache.org/commons/fileupload"/>),
				and secondly, the resolver that uses the O'Reilly COS package (<ulink url="http://www.servlets.com/cos"/>).
				Without a MultipartResolver declared in your webapplication context, no detection of multiparts
				will take place, because some developers might find the need to parse out the multiparts themselves.
			</para>
			<para>
				The following example shows how to use the <literal>CommonsMultipartResolver</literal>:
			<programlisting><![CDATA[
<bean id="multipartResolver" 
	class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
	
	<!-- one of the properties available; the maximum file size in bytes -->
	<property name="maximumFileSize">
		<value>100000</value>
	</property>
</bean>
			]]></programlisting>
				
				But you can also use the <literal>CosMultipartResolver</literal>:
				
			<programlisting><![CDATA[
<bean id="multipartResolver" 
	class="org.springframework.web.multipart.cos.CosMultipartResolver">
	
	<!-- one of the properties available; the maximum file size in bytes -->
	<property name="maximumFileSize">
		<value>100000</value>
	</property>
</bean>
]]></programlisting>
			</para>
			<para>
				Of course you need to stick the appropriate jars in your classpath if using one the 
				multipartresolver. In case of the CommonsMultipartResolver, you need to use <literal>commons-fileupload.jar</literal>,
				in case of the CosMultipartResolver, use <literal>cos.jar</literal>.
			</para>
			<para>
				Now that Spring's set up to handle multipart requests, let's talk about how to actually use it.
				When the Spring DispatcherServlet detects a Multipart request, it activates the resolver that has been
				declared in your context and hands over the request. What it basically does is wrap the current <literal>HttpServletRequest</literal>
				into a <literal>MultipartHttpServletRequest</literal> that has support for multiparts. Using the
				MultipartHttpServletRequest you can get information about the multiparts contained by this request
				and actually get the multiparts themselves in your controllers.
			</para>
		</sect2>
		
		<sect2 id="mvc.multipart-forms">
			<title>Handling a fileupload in a form</title>
			<para>
				After the MultipartResolver has finished doing its jobs, the request will be processed as any other.
				So in fact, you can create a form, with a form upload field, and let Spring bind the file on your form.
				Just as with any other property that's not automagically convertible to a String or primitive type,
				to be able to put binary data in your beans, you have to register a custom editor with the 
				<literal>ServletRequestDatabinder</literal>. There's a couple of editors available for handling
				file and setting the result on a bean. There's a <literal>StringMultipartEditor</literal> capable
				of converting files to Strings (using a user-defined character set) and there's a
				<literal>ByteArrayMultipartEditor</literal> which concerts files to byte-arrays. They function just as for
				instance the <literal>CustomDateEditor</literal>
			</para>
			<para>
				So, to be able to upload files using a form in a website, declare the resolver, a url mapping to a controller
				that will process the bean and the controller itself.
				<programlisting><![CDATA[
<beans>

	...

	<bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/>

	<bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="mappings">
			<props>
				<prop key="/upload.form">fileUploadController</prop>
			</props>
		</property>
	</bean>

	<bean id="fileUploadController" class="examples.FileUploadController">
		<property name="commandClass"><value>examples.FileUploadBean</value></property>
		<property name="formView"><value>fileuploadform</value></property>
		<property name="successView"><value>confirmation</value></property>
	</bean>
	
</beans>
				]]></programlisting>
			</para>
			<para>
				After that, create the controller and the actual bean holding the file property
				<programlisting><![CDATA[
// snippet from FileUploadController
public class FileUploadController extends SimpleFormController {

	protected ModelAndView onSubmit(
		HttpServletRequest request,
		HttpServletResponse response,
		Object command,
		BindException errors)
		throws ServletException, IOException {
		
		// cast the bean
		FileUploadBean bean = (FileUploadBean)command;
		
		// let's see if there's content there
		byte[] file = bean.getFile();
		if (file == null) {
			// hmm, that's strange, the user did not upload anything
		}

		// well, let's do nothing with the bean for now and return:		
		return super.onSubmit(request, response, command, errors);
	}
	
	protected void initBinder(
		HttpServletRequest request,
		ServletRequestDataBinder binder)
		throws ServletException {
		// to actually be able to convert Multipart instance to byte[]
		// we have to register a custom editor (in this case the
		// ByteArrayMultipartEditor
		binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
		// now Spring knows how to handle multipart object and convert them
	}
		
}

// snippet from FileUploadBean
public class FileUploadBean {
	private byte[] file;
	
	public void setFile(byte[] file) {
		this.file = file;
	}
	
	public byte[] getFile() {
		return file;
	}
}
				]]></programlisting>
				
				As you can see, the FileUploadBean has a property typed byte[] that holds the
				file. The controller register a custom editor to let Spring know how to actually
				convert the multipart objects the resolver has found, to properties specified by
				the bean. Right now, nothing is done with the byte[] and the bean itself, but
				you can do with it whatever you want (save it in a database, mail it to somebody,
				etcetera).
			</para>
			<para>
				But we're still not finished. To actually let the user upload something, we have to
				create a form:
				<programlisting><![CDATA[
<html>
	<head>
		<title>Upload a file please</title>
	</head>
	<body>
		<h1>Please upload a file</h1>
		<form method="post" action="upload.form" enctype="multipart/form-data">
			<input type="file" name="file"/>
			<input type="submit"/>
		</form>
	</body>
</html>
				]]></programlisting>
				
				As you can see, we've created a field named after the property of the bean
				that holds the byte[]. Furthermore we've added the encoding attribute which
				is necessary to let the browser know how to encode the multipart fields
				(dont' forget this!).
				Right now everything should work.
			</para>
		</sect2>	
		
	</sect1>
	
	<sect1 id="mvc-utilities">
		<title>Commonly used utilities</title>
		
		<sect2 id="mvc-utilities-pathmatching">
			<title>A little story about the pathmatcher</title>
			<para>
				
			</para>
		</sect2>
		
	</sect1>
		
</chapter>


