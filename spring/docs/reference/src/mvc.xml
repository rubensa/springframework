<?xml version="1.0" encoding="UTF-8"?>
<chapter id="mvc">
  <title>Web MVC framework</title>

  <sect1 id="mvc-introduction">
    <title>Introduction to the web MVC framework</title>

    <para>Spring's web MVC framework is designed around a DispatcherServlet that
    dispatches requests to handlers, with configurable handler mappings, view
    resolution, locale and theme resolution as well as support for upload files.
    The default handler is a very simple Controller interface, just offering a
    <literal>ModelAndView handleRequest(request,response)</literal> method.
    This can already be used for application controllers, but you will prefer
    the included implementation hierarchy, consisting of, for example
    <literal>AbstractController</literal>,
    <literal>AbstractCommandController</literal> and
    <literal>SimpleFormController</literal>. Application controllers will
    typically be subclasses of those. Note that you can choose an appropriate
    base class: If you don't have a form, you don't need a FormController.
    This is a major difference to Struts.</para>

    <para>You can use any object as a command or form object - there's no need
    to implement an interface or derive from a base class. Spring's data binding
    is highly flexible, for example, it treats type mismatches as validation
    errors that can be evaluated by the application, not as system errors. So
    you don't need to duplicate your business objects' properties as Strings
    in your form objects, just to be able to handle invalid submissions, or to
    convert the Strings properly. Instead, it is often preferable to bind
    directly to your business objects. This is another major difference to
    Struts which is built around required base classes like
    <literal>Action</literal> and <literal>ActionForm</literal> - for every
    type of action.</para>

    <para>Compared to WebWork, Spring has more differentiated object roles. It
    supports the notion of a Controller, an optional command or form object,
    and a model that gets passed to the view. The model will normally include
    the command or form object but also arbitrary reference data. Instead, a
    WebWork Action combines all those roles into one single object. WebWork
    does allow you to use existing business objects as part of your form, but
    only by making them bean properties of the respective Action class.
    Finally, the same Action instance that handles the request is used for
    evaluation and form population in the view. Thus, reference data needs to
    be modeled as bean properties of the Action too. These are arguably too
    many roles for one object.</para>

    <para>Spring's view resolution is extremely flexible. A
    Controller implementation can even write a view directly to the response,
    returning null as ModelAndView. In the normal case, a ModelAndView
    instance consists of a view name and a model Map, containing bean names
    and corresponding objects (like a command or form, containing reference data).
    View name resolution is highly configurable, either via bean names, via a
    properties file, or via your own ViewResolver implementation. The abstract
    model Map allows for complete abstraction of the view technology, without
    any hassle. Any renderer can be integrated directly, whether JSP, Velocity,
    or any other rendering technology. The model Map is simply transformed into an
    appropriate format, such as JSP request attributes or a Velocity template
    model.</para>

    <sect2 id="mvc-introduction-pluggability">
      <title>Pluggability of other MVC implementations</title>

      <para>There are several reasons why some projects will prefer to use other
      MVC implementations. Many teams expect to leverage their existing
      investment in skills and tools. In addition, there is a large body of
      knowledge and experience avalailable for the Struts framework. Thus,
      if you can live with Struts' architectural flaws, it can still be a
      viable choice for the web layer. The same applies to WebWork and other
      web MVC frameworks.</para>

      <para>If you don't want to use Spring's web MVC, but intend to leverage
      other solutions that Spring offers, you can integrate the web MVC framework
      of your choice with Spring easily. Simply start up a Spring root
      application context via its ContextLoaderListener, and access it via its
      ServletContext attribute (or Spring's respective helper method) from
      within a Struts or WebWork action. Note that there aren't any "plugins"
      involved, so no dedicated integration is necessary. From the web layer's
      point of view, you'll simply use Spring as a library, with the root
      application context instance as the entry point.</para>

      <para>All your registered beans and all of Spring's services can be at
      your fingertips even without Spring's web MVC. Spring doesn't compete
      with Struts or WebWork in this scenario, it just addresses the many areas
      that the pure web MVC frameworks don't, from bean configuration to data
      access and transaction handling. So you are able to enrich your
      application with a Spring middle tier and/or data access tier, even if
      you just want to use, for example, the transaction abstraction with JDBC or
      Hibernate.</para>
    </sect2>

    <sect2 id="mvc-features">
      <title>Features of Spring MVC</title>

      <para>Spring's web module provides a wealth of unique web support
      features, including:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>Clear separation of roles - controller, validator, command
          object, form object, model object, DispatcherServlet, handler
          mapping, view resolver, etc. Each role can be fulfilled by a
          specialized object.</para>
        </listitem>

        <listitem>
          <para>Powerful and straightforward configuration of both framework
          and application classes as JavaBeans, including easy referencing across
          contexts, such as from web controllers to business objects and
          validators.</para>
        </listitem>

        <listitem>
          <para>Adaptability, non-intrusiveness. Use whatever controller
          subclass you need (plain, command, form, wizard, multi-action, or a
          custom one) for a given scenario instead of deriving from
          a single controller for everything.</para>
        </listitem>

        <listitem>
          <para>Reusable business code - no need for duplication. You can use
          existing business objects as command or form objects instead of
          mirroring them in order to extend a particular framework base class.</para>
        </listitem>

        <listitem>
          <para>Customizable binding and validation - type mismatches as
          application-level validation errors that keep the offending value,
          localized date and number binding, etc instead of String-only form
          objects with manual parsing and conversion to business
          objects.</para>
        </listitem>

        <listitem>
          <para>Customizable handler mapping and view resolution - handler
          mapping and view resolution strategies range from simple URL-based
          configuration, to sophisticated, purpose-built resolution strategies.
          This is more flexible than some web MVC frameworks which mandate a
          particular technique.</para>
        </listitem>

        <listitem>
          <para>Flexible model transfer - model transfer via a name/value Map
          supports easy integration with any view technology.</para>
        </listitem>

        <listitem>
          <para>Customizable locale and theme resolution, support for JSPs
          with or without Spring tag library, support for JSTL, support for
          Velocity without the need for extra bridges, etc.</para>
        </listitem>

        <listitem>
          <para>A simple but powerful tag library that avoids HTML generation at
          any cost, allowing for maximum flexibility in terms of markup
          code.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="mvc-servlet">
    <title>The <literal>DispatcherServlet</literal></title>

    <para>Spring's web MVC framework is, like many other web MVC frameworks, a
    request-driven web MVC framework, designed around a servlet that dispatches
    requests to controllers and offers other functionality facilitating the
    development of web applications. Spring's
    <literal>DispatcherServlet</literal> however, does more than just that. It
    is completely integrated with the Spring ApplicationContext and allows you
    to use every other feature Spring has.</para>

    <para>Like ordinary servlets, the DispatcherServlet is declared in the
    <literal>web.xml</literal> of your web application. Requests that you want the
    DispatcherServlet to handle, will have to be mapped, using a URL mapping
    in the same <literal>web.xml</literal> file.</para>

    <programlisting>&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</programlisting>

    <para>In the example above, all requests ending with
    <literal>.form</literal> will be handled by the DispatcherServlet. The
    DispatcherServlet now needs to be configured. As illustrated in <xref
    linkend="context-introduction" />, ApplicationContexts in Spring can be
    scoped. In the web MVC framework, each DispatcherServlet has its own
    <literal>WebApplicationContext</literal>, which contains the
    DispatcherServlet configuration beans. The default BeanFactory used by the
    DispatcherServlet is the <literal>XmlBeanFactory</literal> and the
    DispatcherServlet will on initialization <emphasis>look for a file named
    <literal>[servlet-name]-servlet.xml</literal></emphasis> in the
    <literal>WEB-INF</literal> directory of your web application. The default
    values used by the DispatcherServlet can be modified by using the servlet
    initialization parameters (see below for more information).</para>

    <para>The <literal>WebApplicationContext</literal> is just an ordinary
    ApplicationContext that has some extra features necessary for
    web applications. It differs from a normal ApplicationContext in that it is
    capable of resolving themes (see <xref linkend="mvc-themeresolver" />),
    and that is knows which servlet it is associated with (by having a link to
    the <literal>ServletContext</literal>). The WebApplicationContext is bound
    in the ServletContext, and using <literal>RequestContextUtils</literal>
    you can always lookup the WebApplicationContext in case you need
    it.</para>

    <para>The Spring DispatcherServlet has a couple of special beans it uses,
    in order to be able to process requests and render the appropriate views.
    These beans are included in the Spring framework and can
    be configured in the WebApplicationContext, just as any other bean would
    be configured. Each of those beans, is described in more detail
    below. Right now, we'll just mention them, just to let you know they exist
    and to enable us to go on talking about the DispatcherServlet. For most of
    the beans, defaults are provided so you don't have to worry about
    configuring them.</para>

    <table frame="all">
      <title>Special beans in the WebApplicationContext</title>

      <tgroup cols="2">
        <colspec colname="c1" colwidth="1*" />

        <colspec colname="c2" colwidth="4*" />

        <thead>
          <row>
            <entry>Expression</entry>

            <entry>Explanation</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>handler mapping(s)</entry>

            <entry>(<xref linkend="mvc-handlermapping" />) a list of pre- and
            postprocessors and controllers that will be executed if they match
            certain criteria (for instance a matching URL specified with the
            controller)</entry>
          </row>

          <row>
            <entry>controller(s)</entry>

            <entry>(<xref linkend="mvc-controller" />) the beans providing the
            actual functionality (or at least, access to the functionality) as
            part of the MVC triad</entry>
          </row>

          <row>
            <entry>view resolver</entry>

            <entry>(<xref linkend="mvc-viewresolver" />) capable of resolving
            view names to views, used by the DispatcherServlet</entry>
          </row>

          <row>
            <entry>locale resolver</entry>

            <entry>(<xref linkend="mvc-localeresolver" />) capable of resolving
            the locale a client is using, in order to be able to offer
            internationalized views</entry>
          </row>

          <row>
            <entry>theme resolver</entry>

            <entry>(<xref linkend="mvc-themeresolver" />) capable of resolving
            themes your web application can use, for example, to offer
            personalized layouts</entry>
          </row>

          <row>
            <entry>multipart resolver</entry>

            <entry>(<xref linkend="mvc-multipart" />) offers functionality to
            process file uploads from HTML forms</entry>
          </row>

          <row>
            <entry>handlerexception resolver</entry>

            <entry>(<xref linkend="mvc-exceptionhandlers" />) offers
            functionality to map exceptions to views or implement other more
            complex exception handling code</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>When a DispatcherServlet is setup for use and a request comes in for
    that specific DispatcherServlet it starts processing it. The list below
    describes the complete process a request goes through if handled by a
    DispatcherServlet: <orderedlist spacing="compact">
        <listitem>
          <para>The WebApplicationContext is searched for and bound in the
          request as an attribute in order for the controller and other elements
          in the process to use. It is bound by default under the key
          <literal>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</literal>.</para>
        </listitem>

        <listitem>
          <para>The locale resolver is bound to the request to let elements in
          the process resolve the locale to use when processing the request
          (rendering the view, preparing data, etc.) If you don't use the
          resolver, it won't affect anything, so if you don't need locale
          resolving, you don't have to use it.</para>
        </listitem>

        <listitem>
          <para>The theme resolver is bound to the request to let elements such
          as views determine which theme to use. The theme resolver does not
          affect anything if you don't use it, so if you don't need themes you
          can just ignore it.</para>
        </listitem>

        <listitem>
          <para>If a multipart resolver is specified, the request is inspected
          for multiparts and if they are found, it is wrapped in a
          <literal>MultipartHttpServletRequest</literal> for further
          processing by other elements in the process. (See
          <xref linkend="mvc-multipart-resolver"/> for further information about
          multipart handling).</para>
        </listitem>

        <listitem>
          <para>An appropriate handler is searched for. If a handler is found,
          the execution chain associated with the handler (preprocessors,
          postprocessors, controllers) will be executed in order to prepare a
          model.</para>
        </listitem>

        <listitem>
          <para>If a model is returned, the view is rendered, using the view
          resolver that has been configured with the WebApplicationContext. If
          no model is returned (which could be due to a pre- or
          postprocessor intercepting the request, for example, for security
          reasons), no view is rendered, since the request could already have
          been fulfilled.</para>
        </listitem>
      </orderedlist></para>

    <para>Exceptions that might be thrown during processing of the request get
    picked up by any of the handlerexception resolvers that are declared in
    the WebApplicationContext. Using these exception resolvers you can define
    custom behavior in case such exceptions get thrown.</para>

    <para>The Spring DispatcherServlet also has support for returning the
    <emphasis>last-modification-date</emphasis>, as specified by the Servlet
    API. The process of determining the last modification date for a specific
    request, is simple. The DispatcherServlet will first lookup an
    appropriate handler mapping and test if the handler that is found
    <emphasis>implements the interface
    <literal>LastModified</literal></emphasis> and if so, the value of
    <literal>long getLastModified(request)</literal> is returned to the
    client.</para>

    <para>You can customize Spring's DispatcherServlet by adding context
    parameters in the <literal>web.xml</literal> file or servlet init
    parameters. The possibilities are listed below.</para>

    <table frame="all">
      <title>DispatcherServlet initialization parameters</title>

      <tgroup cols="2">
        <colspec colname="c1" colwidth="1*" />

        <colspec colname="c2" colwidth="4*" />

        <thead>
          <row>
            <entry>Parameter</entry>

            <entry>Explanation</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>contextClass</literal></entry>

            <entry>Class that implements
            <literal>WebApplicationContext</literal>, which will be used to
            instantiate the context used by this servlet. If this parameter
            isn't specified, the <literal>XmlWebApplicationContext</literal>
            will be used.</entry>
          </row>

          <row>
            <entry><literal>contextConfigLocation</literal></entry>

            <entry>String which is passed to the context instance (specified
            by <literal>contextClass</literal>) to indicate where context(s)
            can be found. The String is potentially split up into multiple
            strings (using a comma as a delimiter) to support multiple
            contexts (in case of multiple context locations, of beans that are
            defined twice, the latest takes precedence).</entry>
          </row>

          <row>
            <entry>namespace</entry>

            <entry>the namespace of the
            <literal>WebApplicationContext</literal>. Defaults to
            <literal>[server-name]-servlet</literal>.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 id="mvc-controller">
    <title>Controllers</title>

    <para>The notion of a controller is part of the MVC design pattern.
    Controllers define application behavior, or at least provide
    access to the application behavior. Controllers interpret user input and
    transform the user input into a sensible model which will be represented
    to the user by the view. Spring has implemented the notion of a controller
    in a very abstract way enabling a wide variety of different kinds of
    controllers to be created. Spring contains formcontroller,
    commandcontroller, controllers that execute wizard-style logic, and
    more.</para>

    <para>Spring's basis for the controller architecture is the
    <literal>org.springframework.web.servlet.mvc.Controller</literal> interface,
		which is listed below. <programlisting>public interface Controller {

    /**
     * Process the request and return a ModelAndView object which the DispatcherServlet
     * will render.
     */
    ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception;
}</programlisting> As you can see, the <literal>Controller</literal> interface
    requires a single method that should be capable of handling a request and
    returning an appropriate model and view. These three concepts are the basis
    for the Spring MVC implementation - <emphasis>ModelAndView</emphasis> and
    <emphasis>Controller</emphasis>. While the <literal>Controller</literal>
    interface is quite abstract, Spring offers a lot of controllers that already
    contain a lot of the functionality you might need. The
    <literal>Controller</literal> interface just defines the most common
    functionality required of every controller - handling a request and
    returning a model and a view.</para>

    <sect2 id="mvc-controller-abstractcontroller">
      <title>AbstractController and WebContentGenerator</title>

      <para>Of course, just a controller interface isn't enough. To provide a
      basic infrastructure, all of Spring's Controllers inherit from
      AbstractController, a class offering caching support and, for example,
      the setting of the mimetype.</para>

      <table frame="all" id="mvc-controller-abstract-features">
        <title>Features offered by the
        <literal>AbstractController</literal></title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="1*" />

          <colspec colname="c2" colwidth="3*" />

          <thead>
            <row>
              <entry>Feature</entry>

              <entry>Explanation</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>supportedMethods</literal></entry>

              <entry>indicates what methods this controller should accept.
              Usually this is set to both <literal>GET</literal> and
              <literal>POST</literal>, but you can modify this to reflect the
              method you want to support. If a request is received with a
              method that is not supported by the controller, the client will
              be informed of this (using a
              <literal>ServletException)</literal>).</entry>
            </row>

            <row>
              <entry><literal>requiresSession</literal></entry>

              <entry>indicates whether or not this controller requires a
              session to do its work. This feature is offered to all
              controllers. If a session is not present when such a controller
              receives a request, the user is informed using a
              <literal>ServletException</literal>.</entry>
            </row>

            <row>
              <entry><literal>synchronizeSession</literal></entry>

              <entry>use this if you want handling by this controller to be
              synchronized on the user's session. To be more specific,
              extending controller will override the
              <literal>handleRequestInternal</literal> method, which will be
              synchronized if you specify this variable.</entry>
            </row>

            <row>
              <entry><literal>cacheSeconds</literal></entry>

              <entry>when you want a controller to generate a caching directive
              in the HTTP response, specify a positive integer here. By
              default it is set to <emphasis>-1</emphasis> so no caching
              directives will be included.</entry>
            </row>

            <row>
              <entry><literal>useExpiresHeader</literal></entry>

              <entry>tweaks your controllers to specify the HTTP 1.0
              compatible <emphasis>"Expires"</emphasis> header. By default
              it's set to true, so you won't have to change it.</entry>
            </row>

            <row>
              <entry><literal>useCacheHeader</literal></entry>

              <entry>tweaks your controllers to specify the HTTP 1.1
              compatible <emphasis>"Cache-Control"</emphasis> header. By
              default this is set to true so you won't have to change
              it.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><emphasis>The last two properties are actually part of the
      <literal>WebContentGenerator</literal> which is the superclass of
      <literal>AbstractController</literal> but are included here for
      completeness.</emphasis></para>

      <para>When using the AbstractController as a baseclass for your
      controllers (which is <emphasis>not</emphasis> recommended since there
      are a lot of other controllers that might already do the job for you)
      you only have to override the
      <literal>handleRequestInternal(HttpServletRequest,
      HttpServletResponse)</literal> method, implement your logic, and
      return a <literal>ModelAndView</literal> object. Here is short example
      consisting of a class and a declaration in the web application context.
      <programlisting>package samples;

public class SampleController extends AbstractController {

    public ModelAndView handleRequestInternal(
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception {
        ModelAndView mav = new ModelAndView("foo", new HashMap());
    }
}</programlisting> <programlisting>&lt;bean id="sampleController" class="samples.SampleController"&gt;
    &lt;property name="cacheSeconds"&gt;&lt;value&gt;120&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting> The class above and the declaration in the
      web application context is all you need besides setting up a handler
      mapping (see <xref linkend="mvc-handlermapping" />) to get this very
      simple controller working. This controller will generate caching
      directives telling the client to cache things for 2 minutes before
      rechecking. This controller returns an hard-coded view (hmm,
      not so nice), named index (see <xref linkend="mvc-viewresolver" /> for
      more information about views).</para>
    </sect2>

    <sect2 id="mvc-controller-othersimplecontrollers">
      <title>Other simple controllers</title>

      <para>Although you can extend AbstractController, Spring provides a number
      of concrete implementations which offer functionality that is commonly
      used in simple MVC applications. The
      <literal>ParameterizableViewController</literal> is basically the same
      as the example above, except for the fact that you can specify the view
      name that it will return in the web application context (ahhh, no need to
      hard-code the viewname).</para>

      <para>The <literal>UrlFilenameViewController</literal> inspects the URL and
      retrieves the filename of the file request (the filename of
      <literal>http://www.springframework.org/index.html</literal> is
      <literal>index</literal>) and uses that as a viewname. Nothing more to
      it.</para>
    </sect2>

    <sect2 id="mvc-controller-multiaction">
      <title>The <literal>MultiActionController</literal></title>

      <para>Spring offers a multi-action controller with which you aggregate
      multiple actions into one controller, grouping functionality together.
      The multi-action controller lives in a separate package -
      <literal>org.springframework.web.servlet.mvc.multiaction</literal> - and is
      capable of mapping requests to method names and then invoking the right
      method name. Using the multi-action controller is especially handy when
      you have a lot of common functionality in one controller, but want
      to have multiple entry points to the controller, for example, to tweak
      behavior.</para>

      <table frame="all" id="mvc-controller-multiaction-features">
        <title>Features offered by the
        <literal>MultiActionController</literal></title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="1*" />

          <colspec colname="c2" colwidth="3*" />

          <thead>
            <row>
              <entry>Feature</entry>

              <entry>Explanation</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>delegate</literal></entry>

              <entry>there are two usage-scenarios for the
              MultiActionController. Either you subclass the
              MultiActionController and specify the methods that will be
              resolved by the MethodNameResolver on the subclass (in which case
              you don't need to set the delegate), or you define a
              delegate object, on which methods resolved by the Resolver will
              be invoked. If you choose this scenario, you will have
              to define the delegate using this configuration parameter as a
              collaborator.</entry>
            </row>

            <row>
              <entry><literal>methodNameResolver</literal></entry>

              <entry>somehow the MultiActionController will need to resolve
              the method it has to invoke, based on the request that came in.
              You can define a resolver that is capable of doing that using
              this configuration parameter.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Methods defined for a multi-action controller need to conform
      to the following signature: <programlisting>// actionName can be replaced by any methodname
ModelAndView actionName(HttpServletRequest, HttpServletResponse);</programlisting>
      Method overloading is not allowed since it would confuse the
      MultiActionController. Furthermore, you can define <emphasis>exception
      handlers</emphasis> capable of handling exceptions that are thrown
      by the methods you specify. Exception handler methods need to return a
      ModelAndView object, just as any other action method and need to
      conform to the following signature: <programlisting>// anyMeaningfulName can be replaced by any methodname
ModelAndView anyMeaningfulName(HttpServletRequest, HttpServletResponse, ExceptionClass);</programlisting>
      The <literal>ExceptionClass</literal> can be <emphasis>any</emphasis>
      exception, as long as it's a subclass of
      <literal>java.lang.Exception</literal> or
      <literal>java.lang.RuntimeException</literal>.</para>

      <para>The <literal>MethodNameResolver</literal> is supposed to resolve
      method names based on the request coming in. There are three resolvers at
      your disposal, but of course you can implement more of them yourself if
      you want to. <itemizedlist spacing="compact">
          <listitem>
            <para><literal>ParameterMethodNameResolver</literal> - capable of
            resolving a request parameter and using that as the method name
            (<literal>http://www.sf.net/index.view?testParam=testIt</literal>
            will result in a method <literal>testIt(HttpServletRequest,
            HttpServletResponse)</literal> being called). The
            <literal>paramName</literal> configuration parameter specifies the
            parameter that is inspected).</para>
          </listitem>

          <listitem>
            <para><literal>InternalPathMethodNameResolver</literal> -
            retrieves the filename from the path and uses that as the method
            name (<literal>http://www.sf.net/testing.view</literal> will
            result in a method <literal>testing(HttpServletRequest,
            HttpServletResponse)</literal> being called).</para>
          </listitem>

          <listitem>
            <para><literal>PropertiesMethodNameResolver</literal> - uses a
            user-defined properties object with request URLs mapped to
            methodnames. When the properties contain
            <literal>/index/welcome.html=doIt</literal> and a request to
            <literal>/index/welcome.html</literal> comes in, the
            <literal>doIt(HttpServletRequest, HttpServletResponse)</literal>
            method is called. This method name resolver works with the
            <literal>PathMatcher</literal>, so if the properties contained
						<literal>/**/welcom?.html</literal>, it would also have worked!</para>
          </listitem>
        </itemizedlist></para>

      <para>Here are a couple of examples. First, an example showing the
      <literal>ParameterMethodNameResolver</literal> and the delegate
      property, which will accept requests to urls with the parameter method
      included and set to <literal>retrieveIndex</literal>: <programlisting>&lt;bean id="paramResolver" class="org....mvc.multiaction.ParameterMethodNameResolver"&gt;
  &lt;property name="paramName"&gt;&lt;value&gt;method&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
  &lt;property name="methodNameResolver"&gt;&lt;ref bean="paramResolver"/&gt;&lt;/property&gt;
  &lt;property name="delegate"&gt;&lt;ref bean="sampleDelegate"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="sampleDelegate" class="samples.SampleDelegate"/&gt;

## together with

public class SampleDelegate {

    public ModelAndView retrieveIndex(
        HttpServletRequest req,
        HttpServletResponse resp) {

        return new ModelAndView("index", "date", new Long(System.currentTimeMillis()));
    }
}</programlisting> When using the delegates shown above, we could also use the
      <literal>PropertiesMethodNameResolver</literal> to match a couple of
      URLs to the method we defined: <programlisting>&lt;bean id="propsResolver" class="org....mvc.multiaction.PropertiesMethodNameResolver"&gt;
  &lt;property name="mappings"&gt;
    &lt;props&gt;
      &lt;prop key="/index/welcome.html"&gt;retrieveIndex&lt;/prop&gt;
      &lt;prop key="/**/notwelcome.html"&gt;retrieveIndex&lt;/prop&gt;
      &lt;prop key="/*/user?.html"&gt;retrieveIndex&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
    &lt;property name="methodNameResolver"&gt;&lt;ref bean="propsResolver"/&gt;&lt;/property&gt;
    &lt;property name="delegate"&gt;&lt;ref bean="sampleDelegate"/&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
    </sect2>

    <sect2 id="mvc-controller-command">
      <title>CommandControllers</title>

      <para>Spring's <emphasis>CommandControllers</emphasis> are a fundamental
      part of the Spring MVC package. Command controllers provide a way to
      interact with data objects and dynamically bind parameters from the
      <literal>HttpServletRequest</literal> to the data object specified.
      They perform a similar role to Struts' ActionForm, but in Spring, your
      data objects don't have to implement a framework-specific interface.
      First, let's examine what command controllers available, to get
      overview of what you can do with them: <itemizedlist
          spacing="compact">
          <listitem>
            <para><literal>AbstractCommandController</literal> - a command
            controller you can use to create your own command controller,
            capable of binding request parameters to a data object you
            specify. This class does not offer form functionality, it does
            however, offer validation features and lets you specify in the
            controller itself what to do with the command object that has been
            filled with the parameters from the request.</para>
          </listitem>

          <listitem>
            <para><literal>AbstractFormController</literal> - an abstract
            controller offering form submission support. Using this controller
            you can model forms and populate them using a command object you
            retrieve in the controller. After a user has filled the form,
            the AbstractFormController binds the fields, validates, and hands
            the object back to the controller to take appropriate
            action. Supported features are: invalid form submission
            (resubmission), validation, and normal form workflow. You implement
            methods to determine which views are used for form presentation and
            success. Use this controller if you need forms, but don't want to
            specify what views you're going to show the user in the
            application context.</para>
          </listitem>

          <listitem>
            <para><literal>SimpleFormController</literal> - a concrete
            FormController that provides even more support when creating a form
            with a corresponding command object. The SimpleFormController
            let's you specify a command object, a viewname for the form, a
            viewname for page you want to show the user when form submission
            has succeeded, and more.</para>
          </listitem>

          <listitem>
            <para><literal>AbstractWizardFormController</literal> - as the
            class name suggests, this is an abstract class--your
            WizardController should extend it. This means you have to
            implement the <literal>validatePage()</literal>,
            <literal>processFinish</literal> and
            <literal>processCancel</literal> methods.</para>

            <para>You probably also want to write a contractor, which should
            at the very least call <literal>setPages()</literal> and
            <literal>setCommandName()</literal>. The former takes as its
            argument an array of type String. This array is the list of views
            which comprise your wizard. The latter takes as its argument a
            String, which will be used to refer to your command object from
            within your views.</para>

            <para>As with any instance of AbstractFormController, you are
            required to use a command object - a JavaBean which will be
            populated with the data from your forms. You can do this in one of
            two ways: either call <literal>setCommandClass()</literal> from
            the constructor with the class of your command object, or
            implement the <literal>formBackingObject()</literal>
            method.</para>

            <para>AbstractWizardFormController has a number of concrete
            methods that you may wish to override. Of these, the ones you are
            likely to find most useful are: <literal>referenceData</literal>
            which you can use to pass model data to your view in the form of a
            Map; <literal>getTargetPage</literal> if your wizard needs to
            change page order or omit pages dynamically; and
            <literal>onBindAndValidate</literal> if you want to override the
            built-in binding and validation workflow.</para>

            <para>Finally, it is worth pointing out the
            <literal>setAllowDirtyBack</literal> and
            <literal>setAllowDirtyForward</literal>, which you can call from
            <literal>getTargetPage</literal> to allow users to move backwards
            and forwards in the wizard even if validation fails for the
            current page.</para>

            <para>For a full list of methods, see the JavaDoc for
            AbstractWizardFormController. There is an implemented example of
            this wizard in the jPetStore included in the Spring distribution:
            org.springframework.samples.jpetstore.web.spring.OrderFormController</para>
          </listitem>
        </itemizedlist></para>
    </sect2>
  </sect1>

  <sect1 id="mvc-handlermapping">
    <title>Handler mappings</title>

    <para>Using a handler mapping you can map incoming web requests to
    appropriate handlers. There are some handler mappings you can use out of the
    box, for example, the <literal>SimpleUrlHandlerMapping</literal> or the
    <literal>BeanNameUrlHandlerMapping</literal>, but let's first examine the
    general concept of a <literal>HandlerMapping</literal>.</para>

    <para>The functionality a basic <literal>HandlerMapping</literal> provides
    is the delivering of a <literal>HandlerExecutionChain</literal>, which must
    contain the handler that matches the incoming request, and may also contain
    a list of handler interceptors that are applied to the request. When a
    request comes in, the <literal>DispatcherServlet</literal> will hand it over
    to the handler mapping to let it inspect the request and come up with an
    appropriate HandlerExecutionChain. Then the DispatcherServlet will
    execute the handler and interceptors in the chain (if any).</para>

    <para>The concept of configurable handler mappings that can optionally
    contain interceptors (executed before or after the actual handler was
    executed, or both) is extremely powerful. A lot of supporting
    functionality can be built into custom
    <literal>HandlerMapping</literal>s. Think of a custom handler mapping that
    chooses a handler not only based on the URL of the request coming in, but
    also on a specific state of the session associated with the
    request.</para>

	<para>This section describes two of Spring's most commonly used handler mappings.
	They both extend the <literal>AbstractHandlerMapping</literal> and share the following
	properties:
		<itemizedlist spacing="compact">
			<listitem>
				<para><literal>interceptors</literal>: the list of interceptors to use.
				<literal>HandlerInterceptor</literal>s are discussed in
				<xref linkend="mvc-handlermapping-interceptor"/>.</para>
			</listitem>
			<listitem>
				<para><literal>defaultHandler</literal>: the default handler to use,
					when this handler mapping does not result in a matching handler.</para>
			</listitem>
			<listitem>
				<para><literal>order</literal>: based on the value of the order property (see
					the <literal>org.springframework.core.Ordered</literal> interface),
					Spring will sort all handler mappings available in the context and
					apply the first matching handler.</para>
			</listitem>
			<listitem>
				<para><literal>alwaysUseFullPath</literal>: if this property is set to
          <literal>true</literal>, Spring will use the full path within the
          current servlet context to find an appropriate handler. If this
          property is set to <literal>false</literal> (the default), the path
          within the current servlet mapping will be used. For example, if a
          servlet is mapped using <literal>/testing/*</literal> and the
          <literal>alwaysUseFullPath</literal> property is set to true,
          <literal>/testing/viewPage.html</literal> would be used, whereas if
          the property is set to false, <literal>/viewPage.html</literal> would
          be used.</para>
			</listitem>
			<listitem>
				<para><literal>urlPathHelper</literal>: using this property, you can
				tweak the UrlPathHelper used when inspecting URLs. Normally,
        you shouldn't have to change the default value.</para>
			</listitem>
			<listitem>
				<para><literal>urlDecode</literal>: the default value for this property
          is <literal>false</literal>. The <literal>HttpServletRequest</literal>
          returns request URLs and URIs that are <emphasis>not</emphasis>
          decoded. If you do want them to be decoded before a
          <literal>HandlerMapping</literal> uses them to find an appropriate
          handler, you have to set this to <literal>true</literal> (note that
          this requires JDK 1.4). The decoding method uses either the encoding
          specified by the request or the default ISO-8859-1 encoding scheme.</para>
			</listitem>
			<listitem>
				<para><literal>lazyInitHandlers</literal>: allows for lazy
          initialization of <emphasis>singleton</emphasis> handlers (prototype
          handlers are always lazily initialized). Default value is
          <literal>false</literal>.</para>
			</listitem>
		</itemizedlist>
   (<emphasis>Note: the last four properties are only available to subclasses of
    <literal>org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</literal></emphasis>).
	</para>

    <sect2 id="mvc-handlermapping-beanname">
      <title><literal>BeanNameUrlHandlerMapping</literal></title>

      <para>A very simple, but very powerful handler mapping is the
      <literal>BeanNameUrlHandlerMapping</literal>, which maps incoming HTTP
      requests to names of beans, defined in the web application context. Let's
      say we want to enable a user to insert an account and we've already
      provided an appropriate FormController (see <xref
      linkend="mvc-controller-command" /> for more information on Command- and
      FormControllers) and a JSP view (or Velocity template) that renders the
      form. When using the BeanNameUrlHandlerMapping, we could map the HTTP
      request with URL <literal>http://samples.com/editaccount.form</literal>
      to the appropriate FormController as follows: <programlisting>&lt;beans&gt;
  &lt;bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;

  &lt;bean name="/editaccount.form" class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
    &lt;property name="formView"&gt;&lt;value&gt;account&lt;/value&gt;&lt;/property&gt;
    &lt;property name="successView"&gt;&lt;value&gt;account-created&lt;/value&gt;&lt;/property&gt;
    &lt;property name="commandName"&gt;&lt;value&gt;Account&lt;/value&gt;&lt;/property&gt;
    &lt;property name="commandClass"&gt;&lt;value&gt;samples.Account&lt;/value&gt;&lt;/property&gt;
  &lt;/bean&gt;
&lt;beans&gt;    </programlisting> All incoming requests for the URL
      <literal>/editaccount.form</literal> will now be handled by the
      FormController in the source listing above. Of course we have to define
      a servlet-mapping in web.xml as well, to let through all the requests
      ending with .form. <programlisting>&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

   &lt;!-- Maps the sample dispatcher to /*.form --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</programlisting></para>

      <para><emphasis>NOTE: if you want to use the
      <literal>BeanNameUrlHandlerMapping</literal>, you don't necessarily have
      to define it in the web application context (as indicated above). By
      default, if no handler mapping can be found in the context, the
      DispatcherServlet creates a <literal>BeanNameUrlHandlerMapping</literal>
      for you! </emphasis></para>
    </sect2>

    <sect2 id="mvc-handlermapping-urlhandlermapping">
      <title><literal>SimpleUrlHandlerMapping</literal></title>

      <para>A further - and much more powerful handler mapping - is the
      <literal>SimpleUrlHandlerMapping</literal>. This mapping is configurable
      in the application context and has Ant-style path matching capabilities
      (see the JavaDoc for
      <literal>org.springframework.util.PathMatcher</literal>). Here is an
      example: <programlisting>&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!-- Maps the sample dispatcher to /*.form --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</programlisting> Allows all requests ending with .html and
      .form to be handled by the sample dispatcher servlet. <programlisting>&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/*/account.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/*/editaccount.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/ex/view*.html"&gt;someViewController&lt;/prop&gt;
                &lt;prop key="/**/help.html"&gt;helpController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="someViewController"
          class="org.springframework.web.servlet.mvc.UrlFilenameViewController"/&gt;

    &lt;bean id="editAccountFormController"
          class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
        &lt;property name="formView"&gt;&lt;value&gt;account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="successView"&gt;&lt;value&gt;account-created&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandName"&gt;&lt;value&gt;Account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandClass"&gt;&lt;value&gt;samples.Account&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</programlisting> This handler mapping routes requests for
      <literal>help.html</literal> in any directory to the
      <literal>helpController</literal>, which is a
      UrlFilenameViewController (more about controllers can be found in <xref
      linkend="mvc-controller" />). Requests for a resource beginning with
      <literal>view</literal>, and ending with <literal>.html</literal> in the
      directory <literal>ex</literal>, will be routed to the
      <literal>someViewController</literal>. Two further mappings are defined
      for <literal>editAccountFormController</literal>.</para>
    </sect2>

    <sect2 id="mvc-handlermapping-interceptor">
      <title>Adding <literal>HandlerInterceptors</literal></title>

      <para>Spring's handler mapping mechanism has a notion of handler
      interceptors, that can be extremely useful when you want to apply specific
      functionality to certain requests, for example, checking for a principal.</para>

      <para>Interceptors located in the handler mapping must implement
      <literal>HandlerInterceptor</literal> from the
      <literal>org.springframework.web.servlet</literal> package. This
      interface defines three methods, one that will be called
      <emphasis>before</emphasis> the actual handler will be executed, one
      that will be called <emphasis>after</emphasis> the handler is executed,
      and one that is called <emphasis>after the complete request has
      finished</emphasis>. These three methods should provide enough
      flexibility to do all kinds of pre- and post-processing.</para>

      <para>The <literal>preHandle</literal> method returns a boolean value.
      You can use this method to break or continue the processing of the
      execution chain. When this method returns <literal>true</literal>, the
      handler execution chain will continue, when it returns false, the
      DispatcherServlet assumes the interceptor itself has taken care of
      requests (and, for example, rendered an appropriate view) and does not
      continue executing the other interceptors and the actual handler in the
      execution chain.</para>

      <para>The following example provides an interceptor that intercepts all
      requests and reroutes the user to a specific page if the time is not
      between 9 a.m. and 6 p.m. <programlisting>&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="interceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="officeHoursInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/*.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/*.view"&gt;editAccountFormController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="officeHoursInterceptor"
          class="samples.TimeBasedAccessInterceptor"&gt;
        &lt;property name="openingTime"&gt;&lt;value&gt;9&lt;/value&gt;&lt;/property&gt;
        &lt;property name="closingTime"&gt;&lt;value&gt;18&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</programlisting> <programlisting>package samples;

public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {

    private int openingTime;
    private int closingTime;
    public void setOpeningTime(int openingTime) {
        this.openingTime = openingTime;
    }
    public void setClosingTime(int closingTime) {
        this.closingTime = closingTime;
    }
    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler)
    throws Exception {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(HOUR_OF_DAY);
        if (openingTime &lt;= hour &lt; closingTime) {
            return true;
        } else {
            response.sendRedirect("http://host.com/outsideOfficeHours.html");
            return false;
        }
    }
}</programlisting> Any request coming in, will be intercepted by the
      <literal>TimeBasedAccessInterceptor</literal>, and if the current time
      is outside office hours, the user will be redirected to a static html
      file, saying, for example, he can only access the website during office
      hours.</para>

      <para>As you can see, Spring has an adapter to make it easy for you to
      extend the <literal>HandlerInterceptor</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="mvc-viewresolver">
    <title>Views and resolving them</title>

    <para>All MVC frameworks for web applications provide a way to address
    views. Spring provides view resolvers, which enable you to render models
    in a browser without tying you to a specific view technology.
    Out of the box, Spring enables you to use Java Server Pages, Velocity
    templates and XSLT views, for example. <xref linkend="view" /> has details
    of integrating various view technologies.</para>

    <para>The two interfaces which are important to the way Spring handles views
    are <literal>ViewResolver</literal> and <literal>View</literal>. The
    <literal>ViewResolver</literal> provides a mapping between view names and
    actual views. The <literal>View</literal> interface addresses the
    preparation of the request and hands the request over to one of the view
    technologies.</para>

    <sect2 id="mvc-viewresolver-resolver">
      <title>ViewResolvers</title>

      <para>As discussed in <xref linkend="mvc-controller"></xref>, all
      controllers in the Spring web MVC framework, return a
      <literal>ModelAndView</literal> instance. Views in Spring are addressed by
      a view name and are resolved by a view resolver. Spring comes with quite
      a few view resolvers. We'll list most of them and then provide a couple
      of examples.</para>

      <table frame="all">
        <title>View resolvers</title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="1*" />

          <colspec colname="c2" colwidth="2*" />

          <thead>
            <row>
              <entry>ViewResolver</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>AbstractCachingViewResolver</entry>

              <entry>An abstract view resolver which takes care of caching
              views. Often views need preparation before they can be used,
              extending this view resolver provides caching of views.</entry>
            </row>

            <row>
              <entry>XmlViewResolver</entry>

              <entry>An implementation of ViewResolver that accepts a
              configuration file written in XML with the same DTD as Spring's
              bean factories. The default configuration file is
              <literal>/WEB-INF/views.xml</literal>.</entry>
            </row>

            <row>
              <entry>ResourceBundleViewResolver</entry>

              <entry>An implementation of ViewResolver that uses bean
              definitions in a ResourceBundle, specified by the bundle basename.
              The bundle is typically defined in a properties file, located in
              the classpath. The default file name is
              <literal>views.properties</literal>.</entry>
            </row>

            <row>
              <entry>UrlBasedViewResolver</entry>

              <entry>A simple implementation of ViewResolver that allows for
              direct resolution of symbolic view names to URLs, without an
              explicit mapping definition. This is appropriate if your
              symbolic names match the names of your view resources in a
              straightforward manner, without the need for arbitrary
              mappings.</entry>
            </row>

            <row>
              <entry>InternalResourceViewResolver</entry>

              <entry>A convenience subclass of UrlBasedViewResolver that
              supports InternalResourceView (i.e. Servlets and JSPs), and
              subclasses like JstlView and TilesView. The view class for all
              views generated by this resolver can be specified via
              setViewClass. See UrlBasedViewResolver's javadocs for
              details.</entry>
            </row>

            <row>
              <entry>VelocityViewResolver / FreeMarkerViewResolver</entry>

              <entry>A convenience subclass of UrlBasedViewResolver that
              supports VelocityView (i.e. Velocity templates) or
              FreeMarkerView respectively and custom subclasses of
              them.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>As an example, when using JSP for a view technology you can use
      the <literal>UrlBasedViewResolver</literal>. This view resolver
      translates a view name to a URL and hands the request over the
      RequestDispatcher to render the view. <programlisting>&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
    &lt;property name="prefix"&gt;&lt;value&gt;/WEB-INF/jsp/&lt;/value&gt;&lt;/property&gt;
    &lt;property name="suffix"&gt;&lt;value&gt;.jsp&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting> When returning <literal>test</literal> as a
      viewname, this view resolver will hand the request over to the
      RequestDispatcher that will send the request to
      <literal>/WEB-INF/jsp/test.jsp</literal>.</para>

      <para>When mixing different view technologies in a web application, you
      can use the ResourceBundleViewResolver: <programlisting>&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;&lt;value&gt;views&lt;/value&gt;&lt;/property&gt;
    &lt;property name="defaultParentView"&gt;&lt;value&gt;parentView&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

      <para>The ResourceBundleViewResolver inspects the ResourceBundle
      identified by the basename, and for each view it is supposed to resolve,
      it uses the value of the property <literal>[viewname].class</literal> as
      the view class and the value of the property
      <literal>[viewname].url</literal> as the view url. As you can see, you
      can identify a parent view, from which all views in the properties file
      sort of extend. This way you can specify a default view class, for
      example.</para>

      <para><emphasis>A note on caching</emphasis> - subclasses of
      <literal>AbstractCachingViewResolver</literal> cache view instances
      they have resolved. This greatly improves performance when using certain
      view technology. It's possible to turn off the cache, by setting the
      <literal>cache</literal> property to false. Furthermore, if you have the
      requirement to be able to refresh a certain view at runtime (for example
      when a Velocity template has been modified), you can use the
      <literal>removeFromCache(String viewName, Locale loc)</literal>
      method.</para>
    </sect2>

	<sect2 id="mvc-viewresolver-chaining">
		<title>Chaining ViewResolvers</title>
		<para>Spring supports more than just one view resolver. This allows you to
      chain resolvers and, for example, override specific views in certain
      circumstances. Chaining view resolvers is pretty straightforward - just
      add more than one resolver to your application context and, if necessary,
      set the <literal>order</literal> property to specify an order. Remember,
      the higher the order property, the later the view resolver will be
      positioned in the chain.</para>
		<para>In the following example, the chain of view resolvers consists of two
      resolvers, a <literal>InternalResourceViewResolver</literal> (which is
      always automatically positioned as the last resolver in the chain) and an
      <literal>XmlViewResolver</literal> for specifying Excel
      views (which are not supported by the InternalResourceViewResolver):
		<programlisting><![CDATA[
<bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
	<property name="prefix" value="/WEB-INF/jsp/"/>
	<property name="suffix" value=".jsp"/>
</bean>

<bean id="excelViewResolver" class="org.springframework.web.servlet.view.XmlViewResolver">
	<property name="order" value="1"/>
	<property name="location" value="/WEB-INF/views.xml"/>
</bean>

### views.xml

<beans>
	<bean name="report" class="org.springframework.example.ReportExcelView"/>
</beans>
]]></programlisting>
		</para>
		<para>If a specific view resolver does not result in a view, Spring will
			inspect the context to see if other view resolvers are configured. If
      there are additional view resolvers, it will continue to inspect them. If
      not, it will throw an Exception.</para>
		<para>You have to keep something else in mind - the contract of a view
      resolver mentions that a view resolver <emphasis>can</emphasis> return
      null to indicate the view could not be found. Not all view resolvers do
      this however! This is because in some cases, the resolver simply cannot
      detect whether or not the view exists. For example, the
      <literal>InternalResourceViewResolver</literal> uses the RequestDispatcher
			internally, and dispatching is the only way to figure out if a JSP exists
      -this can only be done once. The same holds for the VelocityViewResolver
      and some others. Check the JavaDoc for the view resolver to see if
      you're dealing with a view resolver that does not report non-existing
      views. As a result of this, putting an
      <literal>InternalResourceViewResolver</literal> in the chain in a place
      other than the last, will result in the chain not being fully inspected,
      since the <literal>InternalResourceViewResolver</literal> will
      <emphasis>always</emphasis> return a view!</para>
	</sect2>
  </sect1>

  <sect1 id="mvc-localeresolver">
    <title>Using locales</title>

    <para>Most parts of Spring's architecture support internationalization, just
    as the Spring web MVC framework does. DispatcherServlet enables you to
    automatically resolve messages using the client's locale. This is done with
    <literal>LocaleResolver</literal> objects.</para>

    <para>When a request comes in, the DispatcherServlet looks for a locale
    resolver and if it finds one it tries to use it to set the locale. Using
    the <literal>RequestContext.getLocale()</literal> method, you can always
    retrieve the locale that was resolved by the locale resolver.</para>

    <para>Besides the automatic locale resolution, you can also attach an
    interceptor to the handler mapping (see <xref
    linkend="mvc-handlermapping-interceptor" /> for more information on handler
    mapping interceptors), to change the locale under specific circumstances,
    based on a parameter in the request, for example.</para>

    <para>Locale resolvers and interceptors are all defined in the
    <literal>org.springframework.web.servlet.i18n</literal> package, and are
    configured in your application context in the normal way. Here is a
    selection of the locale resolvers included in Spring.</para>

    <sect2 id="mvc-localeresolver-acceptheader">
      <title><literal>AcceptHeaderLocaleResolver</literal></title>

      <para>This locale resolver inspects the
      <literal>accept-language</literal> header in the request that was sent
      by the browser of the client. Usually this header field contains the
      locale of the client's operating system.</para>
    </sect2>

    <sect2 id="mvc-localeresolver-cookie">
      <title><literal>CookieLocaleResolver</literal></title>

      <para>This locale resolver inspects a Cookie that might exist on the
      client, to see if a locale is specified. If so, it uses that
      specific locale. Using the properties of this locale resolver, you can
      specify the name of the cookie, as well as the maximum age.
      <programlisting>&lt;bean id="localeResolver"&gt;
    &lt;property name="cookieName"&gt;&lt;value&gt;clientlanguage&lt;/value&gt;&lt;/property&gt;
    &lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;
    &lt;property name="cookieMaxAge"&gt;&lt;value&gt;100000&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting> This is an example of defining a
      CookieLocaleResolver.</para>

      <table frame="all">
        <title>Special beans in the WebApplicationContext</title>

        <tgroup cols="3">
          <colspec colname="c1" colwidth="1*" />

          <colspec colname="c2" colwidth="1*" />

          <colspec colname="c3" colwidth="3*" />

          <thead>
            <row>
              <entry>Property</entry>

              <entry>Default</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>cookieName</entry>

              <entry>classname + LOCALE</entry>

              <entry>The name of the cookie</entry>
            </row>

            <row>
              <entry>cookieMaxAge</entry>

              <entry>Integer.MAX_INT</entry>

              <entry>The maximum time a cookie will stay persistent on the
              client. If -1 is specified, the cookie will not be persisted. It
              will only be available until the client shuts down his or her
              browser.</entry>
            </row>

            <row>
              <entry>cookiePath</entry>

              <entry>/</entry>

              <entry>Using this parameter, you can limit the visibility of the
              cookie to a certain part of your site. When cookiePath is
              specified, the cookie will only be visible to that path, and the
              paths below it.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 id="mvc-localeresolver-session">
      <title><literal>SessionLocaleResolver</literal></title>

      <para>The <literal>SessionLocaleResolver</literal> allows you to
      retrieve locales from the session that might be associated with the user's
      request.</para>
    </sect2>

    <sect2 id="mvc-localeresolver-interceptor">
      <title><literal>LocaleChangeInterceptor</literal></title>

      <para>You can build in changing of locales using the
      <literal>LocaleChangeInterceptor</literal>. This interceptor needs to be
      added to one of the handler mappings (see <xref
      linkend="mvc-handlermapping" />). It will detect a parameter in the
      request and change the locale (it calls <literal>setLocale()</literal>
      on the LocaleResolver that also exists in the context). <programlisting>&lt;bean id="localeChangeInterceptor"
      class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName"&gt;&lt;value&gt;siteLanguage&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
      class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
      class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;props&gt;
            &lt;prop key="/**/*.view"&gt;someController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting> All calls to all *.view resources containing a
      parameter named <literal>siteLanguage</literal> will now change the
      locale. So a call to
      <literal>http://www.sf.net/home.view?siteLanguage=nl</literal> will
      change the site language to Dutch.</para>
    </sect2>
  </sect1>

  <sect1 id="mvc-themeresolver">
    <title>Using themes</title>

    <sect2 id="mvc-themeresolver-introduction">
      <title>Introduction</title>

       <para>The <emphasis>theme</emphasis> support provided by the Spring web MVC
       framework enables you to further enhance the user experience by allowing the look and
       feel of your application to be <emphasis>themed</emphasis>. A theme is
       basically a collection of static resources affecting the visual style of the
       application, typically style sheets and images.</para>
    </sect2>
    
    <sect2 id="mvc-themeresolver-defining">
       <title>Defining themes</title>
       <para>When you want to use themes in your web application you'll have to setup
       a <literal>org.springframework.ui.context.ThemeSource</literal>. The
       <literal>WebApplicationContext</literal> interface extends <literal>ThemeSource</literal>
       but delegates it's responsabilities to a dedicated implementation. By default the
       delegate will be a <literal>org.springframework.ui.context.support.ResourceBundleThemeSource</literal>
       that loads properties files from the root of the classpath. If you want to use
       a custom <literal>ThemeSource</literal> implementation or if you need to configure
       the basename prefix of the <literal>ResourceBundleThemeSource</literal>, you can
       register a bean in the application context with the reserved name "themeSource".
       The web application context will automatically detect that bean and start using it.</para>
       
       <para>When using the <literal>ResourceBundleThemeSource</literal>, a theme is defined
       in a simple properties file. The properties file lists the resources that make up the theme.
       Here's an example:
<programlisting>styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg
</programlisting>
       The keys of the properties are the names used to refer to the themed elements
       from view code. For a JSP this would typically be done using the
       <literal>spring:theme</literal> custom tag, which is very similar to the
       <literal>spring:message</literal> tag. The following JSP fragment uses
       the theme defined above to customize the look and feel:
<programlisting>&lt;taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;link rel="stylesheet" href="&lt;spring:theme code="styleSheet"/&gt;" type="text/css"/&gt;
   &lt;/head&gt;
   &lt;body background="&lt;spring:theme code="background"/&gt;"&gt;
      ...
   &lt;/body&gt;
&lt;/html&gt;
</programlisting>
       </para>
       
       <para>By default, the <literal>ResourceBundleThemeSource</literal> uses an empty basename
       prefix. As a result the properties files will be loaded from the root of the classpath,
       so we'll have to put our <literal>cool.properties</literal> theme definition in a directory
       at the root of the classpath, e.g. in <literal>/WEB-INF/classes</literal>. Note that
       the <literal>ResourceBundleThemeSource</literal> uses the standard Java resource bundle
       loading mechanism, allowing for full internationalisation of themes. For instance, we could
       have a <literal>/WEB-INF/classes/cool_nl.properties</literal> that references a special
       background image, e.g. with Dutch text on it.</para>
    </sect2>
    
    <sect2 id="mvc-themeresolver-resolving">
       <title>Theme resolvers</title>
       
       <para>Now that we have our themes defined, the only thing left to do is decide which theme
       to use. The <literal>DispatcherServlet</literal> will look for a bean named "themeResolver"
       to find out which <literal>ThemeResolver</literal> implementation to use. A theme resolver
       works in much the same way as a <literal>LocalResolver</literal>. It can detect the
       theme that should be used for a particular request and can also alter the request's
       theme. The following theme resolvers are provided by Spring:</para>
       
       <table frame="all">
        <title>ThemeResolver implementations</title>

        <tgroup cols="2">
          <colspec colname="c1" colwidth="1*" />
          <colspec colname="c3" colwidth="3*" />

          <thead>
            <row>
              <entry>Class</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>FixedThemeResolver</entry>
              <entry>Selects a fixed theme, set using the "defaultThemeName" property.</entry>
            </row>
            <row>
              <entry>SessionThemeResolver</entry>
              <entry>The theme is maintained in the users HTTP session. It only needs
              to be set once for each session, but is not persisted between sessions.</entry>
            </row>
            <row>
              <entry>CookieThemeResolver</entry>
              <entry>The selected theme is stored in a cookie on the client's machine.</entry>
            </row>
          </tbody>
         </tgroup>
       </table>
       
       <para>Spring also provides a <literal>ThemeChangeInterceptor</literal>, which allows changing
       the theme on every request by including a simple request parameter.</para>
    </sect2>
  </sect1>

  <sect1 id="mvc-multipart">
    <title>Spring's multipart (fileupload) support</title>

    <sect2 id="mvc-multipart-introduction">
      <title>Introduction</title>

      <para>Spring has built-in multipart support to handle fileuploads in
      web applications. The design for the multipart support is done with
      pluggable <literal>MultipartResovler</literal> objects, defined in the
      <literal>org.springframework.web.multipart</literal> package. Out of the
      box, Spring provides <literal>MultipartResolver</literal>s for use with
      <emphasis>Commons FileUpload</emphasis> (<ulink
      url="http://jakarta.apache.org/commons/fileupload"></ulink>) and
      <emphasis>COS FileUpload</emphasis> (<ulink
      url="http://www.servlets.com/cos"></ulink>). How uploading files is
      supported will be described in the rest of this chapter.</para>

      <para>By default, no multipart handling will be done by Spring, as some
      developers will want to handle multiparts themselves. You will have to
      enable it yourself by adding a multipart resolver to the web application's
      context. After you have done that, each request will be inspected to see
      if it contains a multipart. If no multipart is found, the request will
      continue as expected. However, if a multipart is found in the request, the
      MultipartResolver that has been declared in your context will be used.
      After that, the multipart attribute in your request will be treated like
      any other attribute.</para>
    </sect2>

    <sect2 id="mvc-multipart-resolver">
      <title>Using the <literal>MultipartResolver</literal></title>

      <para>The following example shows how to use the
      <literal>CommonsMultipartResolver</literal>: <programlisting>&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;

    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;
    &lt;property name="maxUploadSize"&gt;
        &lt;value&gt;100000&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting> This is an example using the
      <literal>CosMultipartResolver</literal>: <programlisting>&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.cos.CosMultipartResolver"&gt;

    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;
    &lt;property name="maxUploadSize"&gt;
        &lt;value&gt;100000&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

      <para>Of course you need to stick the appropriate jars in your classpath
      for the multipart resolver to work. In the case of the
      CommonsMultipartResolver, you need to use
      <literal>commons-fileupload.jar</literal>, while in the case of the
      CosMultipartResolver, use <literal>cos.jar</literal>.</para>

      <para>Now that you have seen how to set Spring up to handle multipart
      requests, let's talk about how to actually use it. When the Spring
      DispatcherServlet detects a Multipart request, it activates the resolver
      that has been declared in your context and hands over the request. What
      it basically does is wrap the current
      <literal>HttpServletRequest</literal> into a
      <literal>MultipartHttpServletRequest</literal> that has support for
      multiparts. Using the MultipartHttpServletRequest you can get
      information about the multiparts contained by this request and actually
      get the multiparts themselves in your controllers.</para>
    </sect2>

    <sect2 id="mvc-multipart-forms">
      <title>Handling a fileupload in a form</title>

      <para>After the MultipartResolver has finished doing its job, the
      request will be processed like any other. To use it, you create a form
      with an upload field, then let Spring bind the file on your form. Just
      as with any other property that's not automagically convertible to a
      String or primitive type, to be able to put binary data in your beans
      you have to register a custom editor with the
      <literal>ServletRequestDatabinder</literal>. There are a couple of
      editors available for handling files and setting the results on a bean.
      There's a <literal>StringMultipartEditor</literal> capable of converting
      files to Strings (using a user-defined character set) and there is a
      <literal>ByteArrayMultipartEditor</literal> which converts files to byte
      arrays. They function just as the <literal>CustomDateEditor</literal>
      does.</para>

      <para>So, to be able to upload files using a form in a website, declare
      the resolver, a url mapping to a controller that will process the bean,
      and the controller itself. <programlisting>&lt;beans&gt;

    ...

    &lt;bean id="multipartResolver"
        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt;

    &lt;bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/upload.form"&gt;fileUploadController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="fileUploadController" class="examples.FileUploadController"&gt;
        &lt;property name="commandClass"&gt;&lt;value&gt;examples.FileUploadBean&lt;/value&gt;&lt;/property&gt;
        &lt;property name="formView"&gt;&lt;value&gt;fileuploadform&lt;/value&gt;&lt;/property&gt;
        &lt;property name="successView"&gt;&lt;value&gt;confirmation&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</programlisting></para>

      <para>After that, create the controller and the actual bean to hold the
      file property <programlisting>// snippet from FileUploadController
public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(
        HttpServletRequest request,
        HttpServletResponse response,
        Object command,
        BindException errors)
        throws ServletException, IOException {

        // cast the bean
        FileUploadBean bean = (FileUploadBean)command;

        // let's see if there's content there
        byte[] file = bean.getFile();
        if (file == null) {
            // hmm, that's strange, the user did not upload anything
        }

        // well, let's do nothing with the bean for now and return:
        return super.onSubmit(request, response, command, errors);
    }

    protected void initBinder(
        HttpServletRequest request,
        ServletRequestDataBinder binder)
        throws ServletException {
        // to actually be able to convert Multipart instance to byte[]
        // we have to register a custom editor (in this case the
        // ByteArrayMultipartEditor
        binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
        // now Spring knows how to handle multipart object and convert them
    }

}

// snippet from FileUploadBean
public class FileUploadBean {
    private byte[] file;

    public void setFile(byte[] file) {
        this.file = file;
    }

    public byte[] getFile() {
        return file;
    }
}</programlisting> As you can see, the FileUploadBean has a property typed
      byte[] that holds the file. The controller registers a custom editor to
      let Spring know how to actually convert the multipart objects the
      resolver has found to properties specified by the bean. In these
      examples, nothing is done with the byte[] property of the bean itself,
      but in practice you can do whatever you want (save it in a database,
      mail it to somebody, etc).</para>

      <para>But we're still not finished. To actually let the user upload
      something, we have to create a form: <programlisting>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Upload a file please&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Please upload a file&lt;/h1&gt;
        &lt;form method="post" action="upload.form" enctype="multipart/form-data"&gt;
            &lt;input type="file" name="file"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting> As you can see, we've created a field named
      after the property of the bean that holds the byte[]. Furthermore we've
      added the encoding attribute which is necessary to let the browser know
      how to encode the multipart fields (do not forget this!). Now
      everything should work.</para>
    </sect2>
  </sect1>

  <sect1 id="mvc-exceptionhandlers">
    <title>Handling exceptions</title>

    <para>Spring provides <literal>HandlerExceptionResolvers</literal> to ease
    the pain of unexpected exceptions occurring while your request is being
    handled by a controller which matched the request.
    <literal>HandlerExceptionResolvers</literal> somewhat resemble the
    exception mappings you can define in the web application descriptor
    <literal>web.xml</literal>. However, they provide a more flexible way to
    handle exceptions. They provide information about what handler was
    executing when the exception was thrown. Furthermore, a programmatic way
    of handling exception gives you many more options for how to respond
    appropriately before the request is forwarded to another URL (the same
    end result as when using the servlet specific exception mappings).</para>

    <para>Besides implementing the
    <literal>HandlerExceptionResolver</literal>, which is only a matter of
    implementing the <literal>resolveException(Exception, Handler)</literal>
    method and returning a <literal>ModelAndView</literal>, you may also use
    the <literal>SimpleMappingExceptionResolver</literal>. This resolver
    enables you to take the class name of any exception that might be thrown
    and map it to a view name. This is functionally equivalent to the
    exception mapping feature from the Servlet API, but it's also possible to
    implement more fine grained mappings of exceptions from different
    handlers.</para>
  </sect1>

</chapter>