<?xml version="1.0" encoding="UTF-8"?>
<chapter id="orm">
  <title>Data Access using O/R Mappers</title>

  <sect1 id="orm-introducion">
    <title>Introduction</title>

    <para>Spring provides integration with Hibernate, JDO, and iBATIS SQL Maps
    in terms of resource management, DAO implementation support, and
    transaction strategies. For Hibernate there is first-class support with
    lots of IoC convenience features, addressing many typical Hibernate
    integration issues. All of these comply with Spring's generic transaction
    and DAO exception hierarchies.</para>

    <para>Spring's adds significant support when using the O/R mapping layer
    of your choice to create data-access applications. First of all you should
    know that once you started using Spring's support for O/R mapping, you
    don't have to go all the way. No matter to what extent, you're invited to
    review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside an ApplicationContext or BeanFactory does provide additional
    benefits in terms of ease of configuration and deployment; as such, most
    examples in this section show configuration inside an
    ApplicationContext.</para>

    <para>Some of the the benefits of using Spring to create your O/R mapping
    applications include:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>To avoid vendor lock-in, and allow mix-and-match
        implementation strategies.</emphasis> While Hibernate is powerful,
        flexible, open source and free, it still uses a proprietary API.
        Furthermore one could argue that iBatis is a bit lightweight, although
        it's excellent for use in application that don't require complex O/R
        mapping strategies. Given the choice, it's usually desirable to
        implement major application functionality using standard or abstracted
        APIs, in case you need to switch to another implementation for reasons
        of functionality, performance, or any other concerns. For example,
        Spring's abstraction of Hibernate Transactions and Exceptions, along
        with its IoC approach which allows you to easily swap in mapper/DAO
        objects implementing data-access functionality, makes it easy to
        isolate all Hibernate-specific code in one area of your application,
        without sacrificing any of the power of Hibernate. Higher level
        service code dealing with the DAOs has no need to know anything about
        their implementation. This approach has the additional benefit of
        making it easy to intentionally implement data-access with a
        mix-and-match approach (i.e. some data-access performed using
        Hibernate, and some using JDBC, others using iBatis) in a
        non-intrusive fashion, potentially providing great benefits in terms
        of continuing to use legacy code or leveraging the strength of each
        technology.</para>
      </listitem>

      <listitem>
        <para><emphasis>Ease of testing</emphasis>. Spring's inversion of
        control approach makes it easy to swap the implementations and
        locations of Hibernate session factories, datasources, transaction
        managers, and mapper object implementations (if needed). This makes it
        much easier to isolate and test each piece of persistence-related code
        in isolation.</para>
      </listitem>

      <listitem>
        <para><emphasis>General resource management.</emphasis> Spring
        application contexts can handle the location and configuration of
        Hibernate SessionFactories, JDBC datasources, iBatis SQLMaps
        configuration objects, and other related resources. This makes these
        values easy to manage and change. Spring offers efficient, easy and
        safe handling of Hibernate Sessions. Related code using Hibernate
        generally needs to use the same Hibernate Session object for
        efficiency and proper transaction handling. Spring makes it easy to
        transparently create and bind a session tot he current thread, using
        either a declarative, AOP method interceptor approach, or by using an
        explicit, template wrapper class at the Java code level. Thus Spring
        solves many of the usage issues that repeatedly arise on the Hibernate
        forums.</para>
      </listitem>

      <listitem>
        <para><emphasis>Exception wrapping.</emphasis> Spring can wrap
        exceptions from you O/R mapping tool of choice, converting them from
        proprietary, checked exceptions, to a set of abstracted runtime
        exceptions. This allows you to handle most persistence exceptions,
        which are non-recoverable, only in the appropriate layers, without
        annoying boilerplate catches/throws, and exception declarations. You
        can still trap and handle exceptions anywhere you need to. Remember
        that JDBC exceptions (including DB specific dialects) are also
        converted to the same hierarchy, meaning that you can perform some
        operations with JDBC within a consistent programming model.</para>
      </listitem>

      <listitem>
        <para><emphasis>Integrated transaction management.</emphasis> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc.) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate related code being affected. As an
        added benefit, JDBC-related code can fully integrate transactionally
        with the code you use to do O/R mapping. This is useful for handling
        functionality not implemented in, for example, Hibernate or iBatis.
				</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="orm-hibernate">
    <title>Hibernate</title>

    <sect2>
      <title>Resource Management</title>

      <para>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling: Inversion of control via
      templating, i.e. infrastructure classes with callback interfaces, or
      applying AOP interceptors. The infrastructure cares for proper resource
      handling, and for appropriate conversion of specific API exceptions to
      an unchecked infrastructure exception hierarchy. Spring introduces a DAO
      exception hierarchy, applicable to any data access strategy. For direct
      JDBC, the <classname>JdbcTemplate</classname> class mentioned in a
      previous section cares for connection handling, and for proper
      conversion of <classname>SQLException</classname> to the
      <classname>DataAccessException</classname> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers. Spring also offers Hibernate and JDO
      support, consisting of a <classname>HibernateTemplate</classname> /
      <classname>JdoTemplate</classname> analogous to
      <classname>JdbcTemplate</classname>, a
      <classname>HibernateInterceptor</classname> /
      <classname>JdoInterceptor</classname>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business object dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring app,
      many important objects are JavaBeans: data access templates, data access
      objects (that use the templates), transaction managers, business objects
      (that use the data access objects and transaction managers), web view
      resolvers, web controllers (that use the business objects), etc.</para>
    </sect2>

    <sect2>
      <title>Resource Definitions in an Application Context</title>

      <para>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources like a JDBC DataSource or a
      Hibernate SessionFactory as beans in an application context. Application
      objects that need to access resources just receive references to such
      pre-defined instances via bean references (the DAO definition in the
      next section illustrates this). The following excerpt from an XML
      application context definition shows how to set up a JDBC
      <classname>DataSource</classname> and a Hibernate
      <classname>SessionFactory</classname> on top of it:</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

    &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;
            &lt;value&gt;java:comp/env/jdbc/myds&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

   &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
       &lt;property name="mappingResources"&gt;
           &lt;list&gt;
               &lt;value&gt;product.hbm.xml&lt;/value&gt;
           &lt;/list&gt;
       &lt;/property&gt;
       &lt;property name="hibernateProperties"&gt;
           &lt;props&gt;
               &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
           &lt;/props&gt;
       &lt;/property&gt;
       &lt;property name="dataSource"&gt;
           &lt;ref bean="myDataSource"/&gt;
       &lt;/property&gt;
   &lt;/bean&gt;

   ...

&lt;/beans&gt;</programlisting>

      <para>Note that switching from a JNDI-located
      <classname>DataSource</classname> to a locally defined one like a
      Jakarta Commons DBCP <classname>BasicDataSource</classname> is just a
      matter of configuration:</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName"&gt;
        &lt;value&gt;org.hsqldb.jdbcDriver&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="url"&gt;
        &lt;value&gt;jdbc:hsqldb:hsql://localhost:9001&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="username"&gt;
        &lt;value&gt;sa&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="password"&gt;
        &lt;value&gt;&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>You can also use a JNDI-located
      <classname>SessionFactory</classname>, but that's typically not
      necessary outside an EJB context (see the "container resources vs local
      resources" section for a discussion).</para>
    </sect2>

    <sect2>
      <title>Inversion of Control: Template and Callback</title>

      <para>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      object. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <classname>SessionFactory</classname>. It can get the latter from
      anywhere, but preferably as bean reference from a Spring application
      context - via a simple <literal>setSessionFactory</literal> bean
      property setter. The following snippets show a DAO definition in a
      Spring application context, referencing the above defined
      <classname>SessionFactory,</classname> and an example for a DAO method
      implementation.</para>

      <programlisting>&lt;beans&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    ...

&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public List loadProductsByCategory(final String category) {
        HibernateTemplate hibernateTemplate =
            new HibernateTemplate(this.sessionFactory);

        return (List) hibernateTemplate.execute(
            new HibernateCallback() {
                public Object doInHibernate(Session session) throws HibernateException {
                    List result = session.find(
                        "from test.Product product where product.category=?",
                        category, Hibernate.STRING);
                    // do some further stuff with the result list
                    return result;
                }
            }
        );
    }
}</programlisting>

      <para>A callback implementation can effectively be used for any
      Hibernate data access. <classname>HibernateTemplate</classname> will
      ensure that <classname>Session</classname>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single step
      actions like a single find, load, saveOrUpdate, or delete call,
      <classname>HibernateTemplate</classname> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <classname>HibernateDaoSupport</classname> base class that provides a
      <literal>setSessionFactory</literal> method for receiving a
      SessionFactory, and <literal>getSessionFactory</literal> and
      <literal>getHibernateTemplate</literal> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</para>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public List loadProductsByCategory(String category) {
        return getHibernateTemplate().find(
            "from test.Product product where product.category=?", category,
            Hibernate.STRING);
    }
}</programlisting>
    </sect2>

    <sect2>
      <title>Applying an AOP Interceptor Instead of a Template</title>

      <para>An alternative to using a <classname>HibernateTemplate</classname>
      is Spring's AOP <classname>HibernateInterceptor</classname>, replacing
      the callback implementation with straight Hibernate code within a
      delegating try/catch block, and a respective interceptor configuration
      in the application context. The following snippets show respective DAO,
      interceptor, and proxy definitions in a Spring application context, and
      an example for a DAO method implementation.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

    ...

    &lt;bean id="myHibernateInterceptor" 
        class="org.springframework.orm.hibernate.HibernateInterceptor"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductDaoTarget" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductDao" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces"&gt;
            &lt;value&gt;product.ProductDao&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myHibernateInterceptor&lt;/value&gt;
                &lt;value&gt;myProductDaoTarget&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    ...

&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public List loadProductsByCategory(final String category) throws MyException {
        Session session = SessionFactoryUtils.getSession(getSessionFactory(), false);
        try {
            List result = session.find(
                "from test.Product product where product.category=?",
                category, Hibernate.STRING);
            if (result == null) {
                throw new MyException("invalid search result");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw SessionFactoryUtils.convertHibernateAccessException(ex);
        }
    }
}</programlisting>

      <para>This method will only work with a
      <classname>HibernateInterceptor</classname> for it, caring for opening a
      thread-bound Session before and closing it after the method call. The
      "false" flag on getSession makes sure that the Session must already
      exist; otherwise <classname>SessionFactoryUtils</classname> would create
      a new one if none was found. If there is already a
      <classname>SessionHolder</classname> bound to the thread, e.g. by a
      <classname>HibernateTransactionManager</classname> transaction,
      <classname>SessionFactoryUtils</classname> automatically takes part in
      it in any case. <classname>HibernateTemplate</classname> uses
      <classname>SessionFactoryUtils</classname> internally - it's all the
      same infrastructure. The major advantage of
      <classname>HibernateInterceptor</classname> is that it allows any
      checked application exception to be thrown within the data access code,
      while HibernateTemplate is restricted to unchecked exceptions within the
      callback. Note that one can offen defer the respective checks and
      throwing of application exceptions to after the callback, though. The
      interceptor's major drawback is that it requires special setup in the
      context. <classname>HibernateTemplate</classname>'s convenience methods
      offers simpler means for many scenarios.</para>
    </sect2>

    <sect2>
      <title>Programmatic Transaction Demarcation</title>

      <para>On top of such lower-level data access services, transactions can
      be demarcated in a higher level of the application, spanning any number
      of operations. There are no restrictions on the implementation of the
      surrounding business object here too, it just needs a Spring
      <classname>PlatformTransactionManager</classname>. Again, the latter can
      come from anywhere, but preferably as bean reference via a
      <methodname>setTransactionManager</methodname> method - just like the
      <classname>productDAO</classname> should be set via a
      <methodname>setProductDao</methodname> method. The following snippets
      show a transaction manager and a business object definition in a Spring
      application context, and an example for a business method
      implementation.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

    ...

    &lt;bean id="myTransactionManager" 
        class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductServiceImpl implements ProductService {

    private PlatformTransactionManager transactionManager;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        TransactionTemplate transactionTemplate = new TransactionTemplate(this.transactionManager);
        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        transactionTemplate.execute(
            new TransactionCallbackWithoutResult() {
                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = productDAO.loadProductsByCategory(category);
                    ...
                }
            }
        );
    }
}</programlisting>

      <para></para>
    </sect2>

    <sect2>
      <title>Declarative Transaction Demarcation</title>

      <para>Alternatively, one can use Spring's AOP TransactionInterceptor,
      replacing the transaction demarcation code with an interceptor
      configuration in the application context. This allows you to keep
      business objects free of repetitive transaction demarcation code in each
      business method. Furthermore, transaction semantics like propagation
      behavior and isolation level can be changed in a configuration file and
      do not affect the business object implementations.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

    ...

    &lt;bean id="myTransactionManager" 
        class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myTransactionInterceptor" 
        class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="transactionAttributeSource"&gt;
            &lt;value&gt;
                product.ProductService.increasePrice*=PROPAGATION_REQUIRED
                product.ProductService.someOtherBusinessMethod=PROPAGATION_MANDATORY
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces"&gt;
            &lt;value&gt;product.ProductService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myTransactionInterceptor&lt;/value&gt;
                &lt;value&gt;myProductServiceTarget&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDAO.loadProductsByCategory(category);
        ...
    }

    ...

}</programlisting>

      <para>As with <classname>HibernateInterceptor</classname>,
      <classname>TransactionInterceptor</classname> allows any checked
      application exception to be thrown with the callback code, while
      <classname>TransactionTemplate</classname> is restricted to unchecked
      exceptions within the callback.
      <classname>TransactionTemplate</classname> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <classname>TransactionStatus</classname>).
      <classname>TransactionInterceptor</classname> behaves the same way by
      default but allows configurable rollback policies per method. A
      convenient alternative way of setting up declarative transactions is
      <classname>TransactionProxyFactoryBean</classname>, particularly if
      there are no other AOP interceptors involved.
      <classname>TransactionProxyFactoryBean</classname> combines the proxy
      definition itself with transaction configuration for a particular target
      bean. This reduces the configuration effort to one target bean plus one
      proxy bean. Furthermore, you do not need to specify which interfaces or
      classes the transactional methods are defined in.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

    ...

    &lt;bean id="myTransactionManager" 
        class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="target"&gt;
            &lt;ref bean="myProductServiceTarget"/&gt;
        &lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
                &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_MANDATORY&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Transaction Management Strategies</title>

      <para>Both <classname>TransactionTemplate</classname> and
      <classname>TransactionInterceptor</classname> delegate the actual
      transaction handling to a
      <classname>PlatformTransactionManager</classname> instance, which can be
      a <classname>HibernateTransactionManager</classname> (for a single
      Hibernate SessionFactory, using a ThreadLocal Session under the hood) or
      a <classname>JtaTransactionManager</classname> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <classname>PlatformTransactionManager</classname>
      implementation. So switching from native Hibernate transaction
      management to JTA, i.e. when facing distributed transaction requirements
      for certain deployments of your application, is just a matter of
      configuration. Simply replace the Hibernate transaction manager with
      Spring's JTA transaction implementation. Both transaction demarcation
      and data access code will work without changes, as they just use the
      generic transaction management APIs. For distributed transactions across
      multiple Hibernate session factories, simply combine
      <classname>JtaTransactionManager</classname> as a transaction strategy
      with multiple <classname>LocalSessionFactoryBean</classname>
      definitions. Each of your DAOs then gets one specific SessionFactory
      reference passed into its respective bean property. If all underlying
      JDBC data sources are transactional container ones, a business object
      can demarcate transactions across any number of DAOs and any number of
      session factories without special regard, as long as it is using
      <classname>JtaTransactionManager</classname> as the strategy.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

    &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;
            &lt;value&gt;java:comp/env/jdbc/myds1&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;
            &lt;value&gt;java:comp/env/jdbc/myds2&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="mappingResources"&gt;
            &lt;list&gt;
                &lt;value&gt;product.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="dataSource"&gt;
            &lt;ref bean="myDataSource1"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="mappingResources"&gt;
            &lt;list&gt;
                &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="hibernateProperties"&gt;
            &lt;props&gt;
                &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.OracleDialect&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
        &lt;property name="dataSource"&gt;
            &lt;ref bean="myDataSource2"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myTransactionManager" 
        class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

    &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory1"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
        &lt;property name="sessionFactory"&gt;
            &lt;ref bean="mySessionFactory2"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao"&gt;
            &lt;ref bean="myProductDao"/&gt;
        &lt;/property&gt;
        &lt;property name="inventoryDao"&gt;
            &lt;ref bean="myInventoryDao"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="myProductService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;
            &lt;ref bean="myTransactionManager"/&gt;
        &lt;/property&gt;
        &lt;property name="target"&gt;
            &lt;ref bean="myProductServiceTarget"/&gt;
        &lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
                &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_MANDATORY&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <para>Both <classname>HibernateTransactionManager</classname> and
      <classname>JtaTransactionManager</classname> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions). Additionally,
      <classname>HibernateTransactionManager</classname> can export the JDBC
      Connection used by Hibernate to plain JDBC access code. This allows for
      high level transaction demarcation with mixed Hibernate/JDBC data access
      completely without JTA, as long as just accessing one database!</para>

      <para>Note, for an alternative approach to using
      <classname>TransactionProxyFactoryBean</classname> to declaratively
      demarcate transactions, please see <xref
      linkend="beannameautoproxycreator-for-transactions" />.</para>
    </sect2>

    <sect2>
      <title>Using Spring-managed Application Beans</title>

      <para>A Spring application context definition can be loaded with a
      variety of context implementations, from
      <classname>FileSystemXmlApplicationContext</classname> and
      <classname>ClassPathXmlApplicationContext</classname> to
      <classname>XmlWebApplicationContext</classname>. This allows for reuse
      of Spring-managed data access and business objects in all kinds of
      environments. By default, a web app will have its root context defined
      in "WEB-INF/applicationContext.xml". In any Spring app, an application
      context defined in an XML file wires up all the application beans that
      are involved, from the Hibernate session factory to custom data access
      and business objects (like the beans above). Most of them do not have to
      be aware of being managed by the Spring container, not even when
      collaborating with other beans, as they simply follow JavaBeans
      conventions. A bean property can either represent a value parameter or a
      collaborating bean. The following bean definition could be part of a
      Spring web MVC context that accesses business beans in a root
      application context.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;bean id="myProductList" class="product.ProductListController"&gt;
    &lt;property name="productService"&gt;
        &lt;ref bean="myProductService"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>Spring web controllers are provided with all business or data
      access objects they need via bean references, so there typically isn't
      any need to do manual bean lookups in the application context. But when
      using Spring-managed beans with Struts, or within an EJB implementation
      or even an applet, one is always able to look up a bean manually.
      Therefore, Spring beans can be leveraged virtually anywhere. One just
      needs a reference to the application context, be it via a servlet
      context attribute in the web case, or a manually created instance from a
      file or class path resource.</para>

      <programlisting format="linespecific" xml:space="preserve">ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext);
ProductService productService = (ProductService) context.getBean("myProductService");</programlisting>

      <programlisting format="linespecific" xml:space="preserve">ApplicationContext context =
    new FileSystemXmlApplicationContext("C:/myContext.xml");
ProductService productService =
    (ProductService) context.getBean("myProductService");</programlisting>

      <programlisting format="linespecific" xml:space="preserve">ApplicationContext context =
    new ClassPathXmlApplicationContext("myContext.xml");
ProductService productService =
    (ProductService) context.getBean("myProductService");</programlisting>

      <para></para>
    </sect2>

    <sect2>
      <title>Container Resources versus Local Resources</title>

      <para>Spring's resource management allows for simple switching between a
      JNDI SessionFactory and a local one, same for a JNDI DataSource, without
      having to change a single line of application code. Whether to keep the
      resource definitions in the container or locally within the application,
      is mainly a matter of the transaction strategy being used. Compared to a
      Spring-defined local SessionFactory, a manually registered JNDI
      SessionFactory does not provide any benefits. If registered via
      Hibernate's JCA connector, there is the added value of transparently
      taking part in JTA transactions, especially within EJBs. An important
      benefit of Spring's transaction support is that it isn't bound to a
      container at all. Configured to any other strategy than JTA, it will
      work in a standalone or test environment too. Especially for the typical
      case of single-database transactions, this is a very lightweight and
      powerful alternative to JTA. When using local EJB Stateless Session
      Beans to drive transactions, you depend both on an EJB container and JTA
      - even if you just access a single database anyway, and just use SLSBs
      for declarative transactions via CMT. The alternative of using JTA
      programmatically requires a J2EE environment too. JTA does not just
      involve container dependencies in terms of JTA itself and of JNDI
      DataSources. For non-Spring JTA-driven Hibernate transactions, you have
      to use the Hibernate JCA connector, or extra Hibernate transaction code
      with JTATransaction being configured, for proper JVM-level caching.
      Spring-driven transactions can work with a locally defined Hibernate
      SessionFactory nicely, just like with a local JDBC DataSource - if
      accessing a single database, of course. Therefore you just have to fall
      back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as e.g. WebLogic
      Express does not provide JCA. A Spring app with local resources and
      transactions spanning one single database will work in any J2EE web
      container (without JTA, JCA, or EJB) - like Tomcat, Resin, or even plain
      Jetty. Additionally, such a middle tier can be reused in desktop
      applications or test suites easily. All things considered: If you do not
      use EJB, stick with local SessionFactory setup and Spring's
      <classname>HibernateTransactionManager</classname> or
      <classname>JtaTransactionManager</classname>. You will get all benefits
      including proper transactional JVM-level caching and distributed
      transactions, without any container deployment hassle. JNDI registration
      of a Hibernate SessionFactory via the JCA connector only adds value for
      use within EJBs.</para>
    </sect2>

    <sect2>
      <title>Samples</title>

      <para>The Petclinic sample in the Spring distribution offers alternative
			DAO implementations and application context configurations for Hibernate,
			JDBC, and Apache OJB. Petclinic can therefore serve as working sample
      app that illustrates the use of Hibernate in a Spring web app. It also
      leverages declarative transaction demarcation with different transaction
      strategies.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>JDO</title>

    <para>ToDo</para>
  </sect1>

  <sect1>
    <title>iBATIS</title>

    <para>Through the <literal>org.springframework.orm.ibatis</literal> package,
    Spring supports iBATIS SqlMaps 1.3.x and 2.0. The iBATIS support much
    resembles Hibernate support in that it supports the same template style
    programming and just as with Hibernate, iBatis support works with Spring's
    exception hierarchy and let's you enjoy the all IoC features Spring
    has.</para>
	
	<sect2>
		<title>Overview and differences between 1.3.x and 2.0</title>


    <para>Spring supports both iBATIS SqlMaps 1.3 and 2.0. First let's have a
    look at the differences between the two.
	
	<table
      frame="all"><title>iBATIS SqlMaps supporting classes for 1.3 and 2.0</title><tgroup cols="3"><colspec
      colname="c1" colwidth="4*" /><colspec colname="c2" colwidth="2*"/><colspec colname="c3" colwidth="2*"/><thead>
		<row>
			<entry>Feature</entry>
			<entry>1.3.x</entry>
			<entry>2.0</entry>			
		</row>
	</thead>
		<tbody>
			<row><entry>Creation of SqlMap</entry>
			<entry><literal>SqlMapFactoryBean</literal></entry>
			<entry><literal>SqlMapClientFactoryBean</literal></entry>
			</row>
			<row>
				<entry>Template-style helper class</entry>
				<entry><literal>SqlMapTemplate</literal></entry>
				<entry><literal>SqlMapClientTemplate</literal></entry>
			</row>
			<row>
				<entry>Callback to use MappedStatement</entry>
				<entry><literal>SqlMapCallback</literal></entry>
				<entry><literal>SqlMapClientCallback</literal></entry>
			</row>
			<row>
				<entry>Super class for DAOs</entry>
				<entry><literal>SqlMapDaoSupport</literal></entry>
				<entry><literal>SqlMapClientDaoSupport</literal></entry>
			</row>
</tbody></tgroup></table>	
	</para>
	</sect2>
	<sect2>
		<title>Setting up the SqlMap</title>
		<para>
			Using iBATIS SqlMaps involves creating SqlMap configuration files containing statements
			and result maps. Spring takes care of loading those using the <literal>SqlMapFactoryBean</literal>
			or <literal>SqlMapClientFactoryBean</literal> where the latter is to be used in combination
			with SqlMaps 2.0.
		</para>
		<para>
			<programlisting><![CDATA[		
public class Account {
	private String name;
	private String email;
	
	public String getName() {
		return this.name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getEmail() {
		return this.email;
	}
	
	public void setEmail(String email) {
		this.email = email;
	}
}]]></programlisting>
			Suppose we would want to map this class. We'd have to create the following SqlMap.
			Using the query, we can later on retrieve users through their email addresses.
			<literal>Account.xml</literal>:
			<programlisting><![CDATA[
<sql-map name="Account">
	<result-map name="result" class="examples.Account">
		<property name="name" column="NAME" columnIndex="1"/>
		<property name="email" column="EMAIL" columnIndex="2"/>
	</result-map>
	
	<mapped-statement name="getAccountByEmail" result-map="result">
		select
			  ACCOUNT.NAME,
			  ACCOUNT.EMAIL
		from ACCOUNT
		where ACCOUNT.EMAIL = #value#
	</mapped-statement>
	
	<mapped-statement name="insertAccount">
		insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
	</mapped-statement>
</sql-map>
]]></programlisting>
			After having defined the Sql Map, we have to create a configuration file for iBATIS
			(<literal>sqlmap-config.xml</literal>):
<programlisting><![CDATA[
<sql-map-config>

	<sql-map resource="example/Account.xml"/>

</sql-map-config>
]]></programlisting>
			iBATIS loads resources from the classpath so be sure to add the Account.xml file to the
			classpath somewhere.
		</para>
		<para>
			Using Spring, we can now very easily set up the SqlMap, using the
			<literal>SqlMapFactoryBean</literal>:
<programlisting><![CDATA[
<bean id="sqlMap" class="org.springframework.orm.ibatis.SqlMapFactoryBean">
	<property name="configLocation"><value>WEB-INF/sqlmap-config.xml</value></property>
</bean>
]]></programlisting>
		</para>		
	</sect2>
	<sect2>
		<title>Using <literal>SqlMapDaoSupport</literal></title>
		<para>
			The <literal>SqlMapDaoSupport</literal> class offers a supporting class similar to
			the <literal>HibernateDaoSupport</literal> and the <literal>JdbcDaoSupport</literal> types.
			Let's implement a DAO:
<programlisting><![CDATA[
public class SqlMapAccountDao extends SqlMapDaoSupport implements AccountDao {

	public Account getAccount(String email) throws DataAccessException {
		Account acc = new Account();
		acc.setEmail();
		return (Account)getSqlMapTemplate().executeQueryForObject("getAccountByEmail", email);
	}

	public void insertAccount(Account account) throws DataAccessException {
		getSqlMapTemplate().executeUpdate("insertAccount", account);
	}
}
]]></programlisting>
			As you can see, we're using the SqlMapTemplate to execute the query. Spring has initialized
			the SqlMap for us using the SqlMapFactoryBean and when setting up the SqlMapAccountDao
			as follows, you're all set to go:
<programlisting><![CDATA[
<!-- for more information about using datasource, have a look at the JDBC chapter -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
	<property name="driverClassName"><value>${jdbc.driverClassName}</value></property>
	<property name="url"><value>${jdbc.url}</value></property>
	<property name="username"><value>${jdbc.username}</value></property>
	<property name="password"><value>${jdbc.password}</value></property>
</bean>

<bean id="accountDao" class="example.SqlMapAccountDao">
	<property name="dataSource"><ref local="dataSource"/></property>
	<property name="sqlMap"><ref local="sqlMap"/></property>
</bean>
]]></programlisting>
		</para>
	</sect2>
	<sect2>
		<title>Transaction management</title>
		<para>
			It's pretty easy to add declarative transaction management to applications using
			iBATIS. Basically the only thing you need to do is adding a transaction 
			manager to you application context and declaratively set your transaction boundaries using
			for example the <literal>TransactionProxyFactoryBean</literal>. More on this can be found
			in <xref linkend="transaction"/>
		</para>
		<para>
			TODO elaborate!
		</para>
	</sect2>	
  </sect1>
</chapter>