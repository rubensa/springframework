<?xml version="1.0" encoding="UTF-8"?>
<chapter id="orm">
  <title>Data Access using O/R Mappers</title>

  <sect1 id="orm-introduction">
    <title>Introduction</title>

    <para>Spring provides integration with <emphasis>Hibernate, JDO, Oracle
    TopLink, Apache OJB</emphasis> and <emphasis>iBATIS SQL Maps</emphasis>:
    in terms of resource management, DAO implementation support, and
    transaction strategies. For Hibernate there is first-class support with
    lots of IoC convenience features, addressing many typical Hibernate
    integration issues. All of these comply with Spring's generic transaction
    and DAO exception hierarchies.</para>

    <para>Spring's adds significant support when using the O/R mapping layer
    of your choice to create data-access applications. First of all you should
    know that once you started using Spring's support for O/R mapping, you
    don't have to go all the way. No matter to what extent, you're invited to
    review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside an ApplicationContext does provide additional benefits in
    terms of ease of configuration and deployment; as such, most examples in
    this section show configuration inside an ApplicationContext.</para>

    <para>Some of the the benefits of using Spring to create your O/R mapping
    applications include:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Ease of testing</emphasis>. Spring's inversion of
        control approach makes it easy to swap the implementations and config
        locations of Hibernate SessionFactory instances, JDBC DataSources,
        transaction managers, and mapper object implementations (if needed).
        This makes it much easier to isolate and test each piece of
        persistence-related code in isolation.</para>
      </listitem>

      <listitem>
        <para><emphasis>General resource management.</emphasis> Spring
        application contexts can handle the location and configuration of
        Hibernate SessionFactory instances, JDBC DataSources, iBATIS SQL Maps
        configuration objects, and other related resources. This makes these
        values easy to manage and change. Spring offers efficient, easy and
        safe handling of Hibernate Sessions. Related code using Hibernate
        generally needs to use the same Hibernate Session object for
        efficiency and proper transaction handling. Spring makes it easy to
        transparently create and bind a Session to the current thread, using
        either a declarative, AOP method interceptor approach, or by using an
        explicit, template wrapper class at the Java code level. Thus Spring
        solves many of the issues that repeatedly arise from typical Hibernate
        usage.</para>
      </listitem>

      <listitem>
        <para><emphasis>Common data access exceptions. </emphasis>Spring can
        wrap exceptions from you O/R mapping tool of choice, converting them
        from proprietary (potentially checked) exceptions to a common runtime
        DataAccessException hierarchy. This allows you to handle most
        persistence exceptions, which are non-recoverable, only in the
        appropriate layers, without annoying boilerplate catches/throws, and
        exception declarations. You can still trap and handle exceptions
        anywhere you need to. Remember that JDBC exceptions (including DB
        specific dialects) are also converted to the same hierarchy, meaning
        that you can perform some operations with JDBC within a consistent
        programming model.</para>
      </listitem>

      <listitem>
        <para><emphasis>Integrated transaction management.</emphasis> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc.) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate/JDO related code being affected. As
        an added benefit, JDBC-related code can fully integrate
        transactionally with the code you use to do O/R mapping. This is
        useful for handling functionality not implemented in, for example,
        Hibernate or iBATIS.</para>
      </listitem>

      <listitem>
        <para><emphasis>To avoid vendor lock-in, and allow mix-and-match
        implementation strategies.</emphasis> While Hibernate is powerful,
        flexible, open source and free, it still uses a proprietary API.
        Furthermore one could argue that iBatis is a bit lightweight, although
        it's excellent for use in application that don't require complex O/R
        mapping strategies. Given the choice, it's usually desirable to
        implement major application functionality using standard or abstracted
        APIs, in case you need to switch to another implementation for reasons
        of functionality, performance, or any other concerns. For example,
        Spring's abstraction of Hibernate Transactions and Exceptions, along
        with its IoC approach which allows you to easily swap in mapper/DAO
        objects implementing data access functionality, makes it easy to
        isolate all Hibernate-specific code in one area of your application,
        without sacrificing any of the power of Hibernate. Higher level
        service code dealing with the DAOs has no need to know anything about
        their implementation. This approach has the additional benefit of
        making it easy to intentionally implement data-access with a
        mix-and-match approach (i.e. some data access performed using
        Hibernate, and some using JDBC, others using iBatis) in a
        non-intrusive fashion, potentially providing great benefits in terms
        of continuing to use legacy code or leveraging the strength of each
        technology.</para>
      </listitem>
    </itemizedlist>

    <para>The PetClinic sample in the Spring distribution offers alternative
    DAO implementations and application context configurations for JDBC,
    Hibernate, Oracle TopLink, and Apache OJB. PetClinic can therefore serve
    as working sample app that illustrates the use of Hibernate, TopLink and
    OJB in a Spring web application. It also leverages declarative transaction
    demarcation with different transaction strategies.</para>

    <para>The JPetStore sample illustrates the use of iBATIS SQL Maps in a
    Spring environment. It also features two web tier versions: one based on
    Spring Web MVC, one based on Struts.</para>

    <para>Beyond the samples shipped with Spring, there is a variety of
    Spring-based O/R mapping samples provided by specific vendors: for
    example, the JDO implementations JPOX (<link
    linkend="???">http://www.jpox.org</link>) and Kodo (<link
    linkend="???">http://www.solarmetric.com</link>).</para>
  </sect1>

  <sect1 id="orm-hibernate">
    <title>Hibernate</title>

    <para>We will start with a coverage of Hibernate (<link
    linkend="???">http://www.hibernate.org</link>) in a Spring environment,
    using it to demonstrate the approach that Spring takes towards integrating
    O/R mappers. This section will cover many issues in detail and show
    different variations of DAO implementations and transaction demarcations.
    Most of these patterns can be directly translated to all other supported
    O/R mapping tools. The following sections in this chapter will then cover
    the other O/R mappers, showing briefer examples there.</para>

    <para>The following discussion focuses on "classic" Hibernate: that is,
    Hibernate 2.1, which has been supported in Spring since its inception. All
    of this can be applied to Hibernate 3.0 as-is, using the analogous
    Hibernate 3 support package introduced in Spring 1.2 final:
    <literal>org.springframework.orm.hibernate3</literal>, mirroring
    <literal>org.springframework.orm.hibernate</literal> with analogous
    support classes for Hibernate 3. Furthermore, all references to the
    <literal>net.sf.hibernate</literal> package need to be replaced with
    <literal>org.hibernate</literal>, following the root package change in
    Hibernate 3. Simply adapt the package names (as used in the examples)
    accordingly.</para>

    <sect2>
      <title>Resource management</title>

      <para>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling: Inversion of control via
      templating, i.e. infrastructure classes with callback interfaces, or
      applying AOP interceptors. The infrastructure cares for proper resource
      handling, and for appropriate conversion of specific API exceptions to
      an unchecked infrastructure exception hierarchy. Spring introduces a DAO
      exception hierarchy, applicable to any data access strategy. For direct
      JDBC, the <classname>JdbcTemplate</classname> class mentioned in a
      previous section cares for connection handling, and for proper
      conversion of <classname>SQLException</classname> to the
      <classname>DataAccessException</classname> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers.</para>

      <para>Spring also offers Hibernate and JDO support, consisting of a
      <classname>HibernateTemplate</classname> /
      <classname>JdoTemplate</classname> analogous to
      <classname>JdbcTemplate</classname>, a
      <classname>HibernateInterceptor</classname> /
      <classname>JdoInterceptor</classname>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business service dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring app,
      many important objects are JavaBeans: data access templates, data access
      objects (that use the templates), transaction managers, business
      services (that use the data access objects and transaction managers),
      web view resolvers, web controllers (that use the business services),
      etc.</para>
    </sect2>

    <sect2>
      <title>SessionFactory setup in a Spring application context</title>

      <para>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources like a JDBC DataSource or a
      Hibernate SessionFactory as beans in an application context. Application
      objects that need to access resources just receive references to such
      pre-defined instances via bean references (the DAO definition in the
      next section illustrates this). The following excerpt from an XML
      application context definition shows how to set up a JDBC
      <classname>DataSource</classname> and a Hibernate
      <classname>SessionFactory</classname> on top of it:</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
    &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="username" value="sa"/&gt;
    &lt;property name="password" value=""/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

   ...
&lt;/beans&gt;</programlisting>

      <para>Note that switching from a local Jakarta Commons DBCP
      <classname>BasicDataSource</classname> to a JNDI-located
      <classname>DataSource</classname> (usually managed by the J2EE server)
      is just a matter of configuration:</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</programlisting>

      <para>You can also access a JNDI-located
      <classname>SessionFactory</classname>, using Spring's
      JndiObjectFactoryBean to retrieve and expose it. However, that's
      typically not necessary outside an EJB context. See the "container
      resources versus local resources" section for a discussion.</para>
    </sect2>

    <sect2>
      <title>Inversion of Control: HibernateTemplate and
      HibernateCallback</title>

      <para>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      service. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <classname>SessionFactory</classname>. It can get the latter from
      anywhere, but preferably as bean reference from a Spring application
      context - via a simple <literal>setSessionFactory</literal> bean
      property setter. The following snippets show a DAO definition in a
      Spring application context, referencing the above defined
      <classname>SessionFactory,</classname> and an example for a DAO method
      implementation.</para>

      <programlisting>&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) {
        HibernateTemplate hibernateTemplate =
            new HibernateTemplate(this.sessionFactory);

        return (Collection) hibernateTemplate.execute(
            new HibernateCallback() {
                public Object doInHibernate(Session session) throws HibernateException {
                    List result = session.find(
                        "from test.Product product where product.category=?",
                        category, Hibernate.STRING);
                    // do some further stuff with the result list
                    return result;
                }
            }
        );
    }
}</programlisting>

      <para>A callback implementation can effectively be used for any
      Hibernate data access. <classname>HibernateTemplate</classname> will
      ensure that <classname>Session</classname>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single step
      actions like a single find, load, saveOrUpdate, or delete call,
      <classname>HibernateTemplate</classname> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <classname>HibernateDaoSupport</classname> base class that provides a
      <literal>setSessionFactory</literal> method for receiving a
      <classname>SessionFactory</classname>, and
      <literal>getSessionFactory</literal> and
      <literal>getHibernateTemplate</literal> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</para>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) {
        return getHibernateTemplate().find(
            "from test.Product product where product.category=?", category);
    }
}</programlisting>
    </sect2>

    <sect2>
      <title>Using the Hibernate API directly in DAO implementations</title>

      <para>As alternative to using Spring's
      <classname>HibernateTemplate</classname> to implement DAOs, data access
      code can also be written against plain Hibernate API, without wrapping
      the Hibernate access code in a callback. Spring's
      <literal>HibernateDaoSupport</literal> base class offers methods to
      access the current transactional Session and to convert exceptions in
      such a scenario; similar methods are also available as static helpers on
      the <literal>SessionFactoryUtils</literal> class. Note that such code
      will usually pass "false" into <literal>getSession</literal>'s the
      "allowCreate" flag, to enforce running within a transaction (which
      avoids the need to close the returned Session, as it its lifecycle is
      managed by the transaction).</para>

      <para><programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws MyException {
        Session session = getSession(getSessionFactory(), false);
        try {
            List result = session.find(
                "from test.Product product where product.category=?",
                category, Hibernate.STRING);
            if (result == null) {
                throw new MyException("invalid search result");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw convertHibernateAccessException(ex);
        }
    }
}</programlisting></para>

      <para>The major advantage of such direct Hibernate access code is that
      it allows any checked application exception to be thrown within the data
      access code, while <literal>HibernateTemplate</literal> is restricted to
      unchecked exceptions within the callback. Note that one can often defer
      the corresponding checks and the throwing of application exceptions to
      after the callback, which still allows working with
      <literal>HibernateTemplate</literal>. In general,
      <classname>HibernateTemplate</classname>'s convenience methods are
      simpler and more convenient for many scenarios.</para>

      <para>In principle, a plain
      <literal>SessionFactory.openSession()</literal> call can be used as well,
      with a corresponding <literal>close</literal> call at the end of the
      operation, and converting <literal>HibernateException</literal> to some
      custom DAO exception. This does not involve any Spring-specific API, but
      won't participate in Spring's transactional <literal>Session</literal>,
      and won't conform to Spring's generic
      <literal>DataAccessException</literal> hierarchy. Hence, this is not
      recommended for newly written code (in general).</para>

      <para>As a special feature, the <literal>getCurrentSession()</literal>
      method that Hibernate 3.0.1 introduced on the
      <literal>SessionFactory</literal> interface is supported by Spring's
      <literal>LocalSessionFactoryBean</literal> as well, returning the
      current Spring-managed transactional <literal>Session</literal> even
      with <literal>HibernateTransactionManager</literal>. Of course, the
      standard behavior of that method remains: returning the current
      <literal>Session</literal> associated with the ongoing JTA transaction,
      if any. This allows to write DAOs against plain Hibernate API, while
      still participating in Spring-managed transactions. However, conversion
      to Spring's <literal>DataAccessException</literal> would still have to
      happen explicitly (if desired).</para>
    </sect2>

    <sect2>
      <title>Programmatic transaction demarcation</title>

      <para>On top of such lower-level data access services, transactions can
      be demarcated in a higher level of the application, spanning any number
      of operations. There are no restrictions on the implementation of the
      surrounding business service here as well, it just needs a Spring
      <classname>PlatformTransactionManager</classname>. Again, the latter can
      come from anywhere, but preferably as bean reference via a
      <methodname>setTransactionManager</methodname> method - just like the
      <classname>productDAO</classname> should be set via a
      <methodname>setProductDao</methodname> method. The following snippets
      show a transaction manager and a business service definition in a Spring
      application context, and an example for a business method
      implementation.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductServiceImpl implements ProductService {

    private PlatformTransactionManager transactionManager;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        TransactionTemplate transactionTemplate = new TransactionTemplate(this.transactionManager);
        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        transactionTemplate.execute(
            new TransactionCallbackWithoutResult() {
                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = productDAO.loadProductsByCategory(category);
                    ...
                }
            }
        );
    }
}</programlisting>
    </sect2>

    <sect2>
      <title>Declarative transaction demarcation</title>

      <para>Alternatively, one can use Spring's AOP TransactionInterceptor,
      replacing the transaction demarcation code with an interceptor
      configuration in the application context. This allows you to keep
      business services free of repetitive transaction demarcation code in
      each business method. Furthermore, transaction semantics like
      propagation behavior and isolation level can be changed in a
      configuration file and do not affect the business service
      implementations.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
    ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxInterceptor"
	    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="transactionAttributeSource"&gt;
      &lt;value&gt;
        product.ProductService.increasePrice*=PROPAGATION_REQUIRED
        product.ProductService.someOtherBusinessMethod=PROPAGATION_MANDATORY
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;
      &lt;value&gt;product.ProductService&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;value&gt;myTxInterceptor&lt;/value&gt;
        &lt;value&gt;myProductServiceTarget&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDAO.loadProductsByCategory(category);
        ...
    }

    ...
}</programlisting>

      <para><classname>TransactionInterceptor</classname> allows any checked
      application exception to be thrown with the callback code, while
      <classname>TransactionTemplate</classname> is restricted to unchecked
      exceptions within the callback.
      <classname>TransactionTemplate</classname> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <classname>TransactionStatus</classname>).
      <classname>TransactionInterceptor</classname> behaves the same way by
      default but allows configurable rollback policies per method. A
      convenient alternative way of setting up declarative transactions is
      <classname>TransactionProxyFactoryBean</classname>, particularly if
      there are no other AOP interceptors involved.
      <classname>TransactionProxyFactoryBean</classname> combines the proxy
      definition itself with transaction configuration for a particular target
      bean. This reduces the configuration effort to one target bean plus one
      proxy bean. Furthermore, you do not need to specify which interfaces or
      classes the transactional methods are defined in.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
	    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Transaction management strategies</title>

      <para>Both <classname>TransactionTemplate</classname> and
      <classname>TransactionInterceptor</classname> delegate the actual
      transaction handling to a
      <classname>PlatformTransactionManager</classname> instance, which can be
      a <classname>HibernateTransactionManager</classname> (for a single
      Hibernate SessionFactory, using a ThreadLocal Session under the hood) or
      a <classname>JtaTransactionManager</classname> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <classname>PlatformTransactionManager</classname>
      implementation. So switching from native Hibernate transaction
      management to JTA, i.e. when facing distributed transaction requirements
      for certain deployments of your application, is just a matter of
      configuration. Simply replace the Hibernate transaction manager with
      Spring's JTA transaction implementation. Both transaction demarcation
      and data access code will work without changes, as they just use the
      generic transaction management APIs.</para>

      <para>For distributed transactions across multiple Hibernate session
      factories, simply combine <classname>JtaTransactionManager</classname>
      as a transaction strategy with multiple
      <classname>LocalSessionFactoryBean</classname> definitions. Each of your
      DAOs then gets one specific SessionFactory reference passed into its
      respective bean property. If all underlying JDBC data sources are
      transactional container ones, a business service can demarcate
      transactions across any number of DAOs and any number of session
      factories without special regard, as long as it is using
      <classname>JtaTransactionManager</classname> as the strategy.</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

  &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName value="java:comp/env/jdbc/myds1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource1"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource2"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.OracleDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
    &lt;property name="inventoryDao" ref="myInventoryDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
	    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>

      <para>Both <classname>HibernateTransactionManager</classname> and
      <classname>JtaTransactionManager</classname> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions).</para>

      <para><classname>HibernateTransactionManager</classname> can export the
      JDBC Connection used by Hibernate to plain JDBC access code, for a
      specific DataSource. This allows for high-level transaction demarcation
      with mixed Hibernate/JDBC data access completely without JTA, as long as
      just accessing one database! HibernateTransactionManager will
      automatically expose the Hibernate transaction as JDBC transaction if
      the passed-in SessionFactory has been set up with a DataSource (through
      LocalSessionFactoryBean's "dataSource" property). Alternatively, the
      DataSource that the transactions are supposed to be exposed for can also
      be specified explicitly, through HibernateTransactionManager's
      "dataSource" property.</para>

      <para>Note, for an alternative approach to using
      <classname>TransactionProxyFactoryBean</classname> to declaratively
      demarcate transactions, please see <xref
      linkend="beannameautoproxycreator-for-transactions" />.</para>
    </sect2>

    <sect2>
      <title>Container resources versus local resources</title>

      <para>Spring's resource management allows for simple switching between a
      JNDI SessionFactory and a local one, same for a JNDI DataSource, without
      having to change a single line of application code. Whether to keep the
      resource definitions in the container or locally within the application,
      is mainly a matter of the transaction strategy being used. Compared to a
      Spring-defined local SessionFactory, a manually registered JNDI
      SessionFactory does not provide any benefits. Deploying a SessionFactory
      through Hibernate's JCA connector provides the added value of
      participating in the J2EE server's management infrastructure, but does
      not add actual value beyond that.</para>

      <para>An important benefit of Spring's transaction support is that it
      isn't bound to a container at all. Configured to any other strategy than
      JTA, it will work in a standalone or test environment too. Especially
      for the typical case of single-database transactions, this is a very
      lightweight and powerful alternative to JTA. When using local EJB
      Stateless Session Beans to drive transactions, you depend both on an EJB
      container and JTA - even if you just access a single database anyway,
      and just use SLSBs for declarative transactions via CMT. The alternative
      of using JTA programmatically requires a J2EE environment as well. JTA
      does not just involve container dependencies in terms of JTA itself and
      of JNDI DataSources. For non-Spring JTA-driven Hibernate transactions,
      you have to use the Hibernate JCA connector, or extra Hibernate
      transaction code with the TransactionManagerLookup being configured -
      for proper JVM-level caching.</para>

      <para>Spring-driven transactions can work with a locally defined
      Hibernate SessionFactory nicely, just like with a local JDBC DataSource
      - if accessing a single database, of course. Therefore you just have to
      fall back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as e.g. WebLogic
      Express does not provide JCA. A Spring app with local resources and
      transactions spanning one single database will work in any J2EE web
      container (without JTA, JCA, or EJB) - like Tomcat, Resin, or even plain
      Jetty. Additionally, such a middle tier can be reused in desktop
      applications or test suites easily.</para>

      <para>All things considered: If you do not use EJB, stick with local
      SessionFactory setup and Spring's
      <classname>HibernateTransactionManager</classname> or
      <classname>JtaTransactionManager</classname>. You will get all benefits
      including proper transactional JVM-level caching and distributed
      transactions, without any container deployment hassle. JNDI registration
      of a Hibernate SessionFactory via the JCA connector only adds value for
      use within EJBs.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>JDO</title>

    <para>Spring supports the standard JDO 1.0/2.0 API as data access
    strategy, following the same style as the Hibernate support. The
    corresponding integration classes reside in the
    <literal>org.springframework.orm.jdo</literal> package.</para>

    <sect2>
      <title>PersistenceManagerFactory setup</title>

      <para>Spring provides a
      <classname>LocalPersistenceManagerFactoryBean</classname> class that
      allows for defining a local JDO PersistenceManagerFactory within a
      Spring application context:</para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

  &lt;bean id="myPmf" class="org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean"&gt;
    &lt;property name="configLocation" value="classpath:kodo.properties"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</programlisting></para>

      <para>Alternatively, a <literal>PersistenceManagerFactory</literal> can
      also be set up through direct instantiation of a
      <literal>PersistenceManagerFactory</literal> implementation class. A JDO
      <literal>PersistenceManagerFactory</literal> implementation class is
      supposed to follow the JavaBeans pattern, just like a JDBC
      <literal>DataSource</literal> implementation class, which is a natural
      fit for a Spring bean definition. This setup style usually supports a
      Spring-defined JDBC <literal>DataSource</literal>, passed into the
      "connectionFactory" property. For example, for the open source JDO
      implementation JPOX (<link
      linkend="???">http://www.jpox.org</link>):</para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
   &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
   &lt;property name="url" value="${jdbc.url}"/&gt;
   &lt;property name="username" value="${jdbc.username}"/&gt;
   &lt;property name="password" value="${jdbc.password}"/&gt;
 &lt;/bean&gt;

 &lt;bean id="myPmf" class="org.jpox.PersistenceManagerFactoryImpl" destroy-method="close"&gt;
   &lt;property name="connectionFactory" ref="dataSource"/&gt;
   &lt;property name="nontransactionalRead" value="true"/&gt;
 &lt;/bean&gt;
   
 ...
&lt;/beans&gt;</programlisting></para>

      <para>A JDO <literal>PersistenceManagerFactory</literal> can also be set
      up in the JNDI environment of a J2EE application server, usually through
      the JCA connector provided by the particular JDO implementation.
      Spring's standard <literal>JndiObjectFactoryBean</literal> can be used
      to retrieve and expose such a
      <literal>PersistenceManagerFactory</literal>. However, outside an EJB
      context, there is often no compelling benefit in holding the
      <literal>PersistenceManagerFactory</literal> in JNDI: only choose such
      setup for a good reason. See "container resources versus local
      resources" in the Hibernate section for a discussion; the arguments
      there apply to JDO as well.</para>
    </sect2>

    <sect2>
      <title>JdoTemplate and JdoDaoSupport</title>

      <para>Each JDO-based DAO will then receive the
      <literal>PersistenceManagerFactory</literal> through dependency
      injection, i.e. through a bean property setter or through a constructor
      argument. Such a DAO could be coded against the plain JDO API, working
      with the given <literal>PersistenceManagerFactory</literal>, but will
      usually rather be used with Spring's
      <literal>JdoTemplate</literal>:</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl implements ProductDao {
  
    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(final String category) {
        JdoTemplate jdoTemplate = new JdoTemplate(this.persistenceManagerFactory);
        return (Collection) jdoTemplate.execute(
            new JdoCallback() {
                public Object doInJdo(PersistenceManager pm) throws JDOException {
                    Query query = pm.newQuery(Product.class, "category = pCategory");
                    query.declareParameters("String pCategory"); 
                    List result = query.execute(category);
                    // do some further stuff with the result list
                    return result;
                }
            }
        );
    }
}</programlisting>

      <para>A callback implementation can effectively be used for any JDO data
      access. <classname>JdoTemplate</classname> will ensure that
      <classname>PersistenceManager</classname>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <literal>find</literal>,
      <literal>load</literal>, <literal>makePersistent</literal>, or
      <literal>delete</literal> call, <classname>JdoTemplate</classname>
      offers alternative convenience methods that can replace such one line
      callback implementations. Furthermore, Spring provides a convenient
      <classname>JdoDaoSupport</classname> base class that provides a
      <literal>setPersistenceManagerFactory</literal> method for receiving a
      <classname>PersistenceManagerFactory</classname>, and
      <literal>getPersistenceManagerFactory</literal> and
      <literal>getJdoTemplate</literal> for use by subclasses. In combination,
      this allows for very simple DAO implementations for typical
      requirements:</para>

      <para><programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl extends JdoDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) {
        return getJdoTemplate().find(
            Product.class, "category = pCategory", "String category", new Object[] {category});
    }
}</programlisting></para>

      <para>As alternative to working with Spring's
      <literal>JdoTemplate</literal>, you can also code your JDO data access
      against the plain JDO API, explictly opening and closing a
      <literal>PersistenceManager</literal>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <literal>JdoDaoSupport</literal> offers a variety of support methods for
      this scenario, for fetching and releasing a transactional
      <literal>PersistenceManager</literal> as well as for converting
      exceptions.</para>

      <para>DAOs can also be written against the plain JDO API, without any
      Spring dependencies, directly using the injected
      <literal>PersistenceManagerFactory</literal>. To still access a
      Spring-managed transactional <literal>PersistenceManager</literal>,
      consider defining a
      <literal>TransactionAwarePersistenceManagerFactoryProxy</literal> (as
      included in Spring) in front of your target
      <literal>PersistenceManagerFactory</literal>, passing the proxy into
      your DAOs. Your data access code will then receive a transactional
      <literal>PersistenceManager</literal> (if any) from the
      <literal>PersistenceManagerFactory.getPersistenceManager()</literal>
      method.</para>
    </sect2>

    <sect2>
      <title>Transaction management</title>

      <para>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <literal>TransactionProxyFactoryBean</literal> for a
      ProductService, which in turn delegates to the JDO-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.jdo.JdoTransactionManager"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
	    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting></para>

      <para>Note that JDO requires an active transaction when modifying a
      persistent object. There is no concept like a non-transactional flush in
      JDO, in contrast to Hibernate. For this reason, the chosen JDO
      implementation needs to be set up for a specific environment: in
      particular, it needs to be explicitly set up for JTA synchronization, to
      detect an active JTA transaction itself. This is not necessary for local
      transactions as performed by Spring's
      <literal>JdoTransactionManager</literal>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <literal>JtaTransactionManager</literal> or by EJB CMT / plain
      JTA).</para>

      <para><literal>JdoTransactionManager</literal> is capable of exposing a
      JDO transaction to JDBC access code that accesses the same JDBC
      <literal>DataSource</literal>, provided that the registered
      <literal>JdoDialect</literal> supports retrieval of the underlying JDBC
      <literal>Connection</literal>. This is by default the case for
      JDBC-based JDO 2.0 implementations; for JDO 1.0 implementations, a
      custom <literal>JdoDialect</literal> needs to be used. See next section
      for details on the <literal>JdoDialect</literal> mechanism.</para>
    </sect2>

    <sect2>
      <title>JdoDialect</title>

      <para>As an advanced feature, both <literal>JdoTemplate</literal> and
      <literal>JdoTransactionManager</literal> support a custom
      <literal>JdoDialect</literal>, to be passed into the "jdoDialect" bean
      property. In such a scenario, the DAOs won't receive a
      <literal>PersistenceManagerFactory</literal> reference but rather a full
      <literal>JdoTemplate</literal> instance instead (for example, passed
      into <literal>JdoDaoSupport</literal>'s "jdoTemplate" property). A
      <literal>JdoDialect</literal> implementation can enable some advanced
      features supported by Spring, usually in a vendor-specific
      manner:</para>

      <itemizedlist>
        <listitem>
          <para>applying specific transaction semantics (such as custom
          isolation level or transaction timeout)</para>
        </listitem>

        <listitem>
          <para>retrieving the transactional JDBC
          <literal>Connection</literal> (for exposure to JDBC-based
          DAOs)</para>
        </listitem>

        <listitem>
          <para>applying query timeouts (automatically calculated from
          Spring-managed transaction timeout)</para>
        </listitem>

        <listitem>
          <para>eagerly flushing a <literal>PersistenceManager</literal> (to
          make transactional changes visible to JDBC-based data access
          code)</para>
        </listitem>

        <listitem>
          <para>advanced translation of <literal>JDOExceptions</literal> to
          Spring <literal>DataAccessExceptions</literal></para>
        </listitem>
      </itemizedlist>

      <para>This is particularly valuable for JDO 1.0 implementations, where
      none of those features are covered by the standard API. On JDO 2.0, most
      of those features are supported in a standard manner: Hence, Spring's
      <literal>DefaultJdoDialect</literal> uses the corresponding JDO 2.0 API
      methods by default (as of Spring 1.2). For special transaction semantics
      and for advanced translation of exception, it is still valuable to
      derive vendor-specific <literal>JdoDialect</literal> subclasses.</para>

      <para>See the <literal>JdoDialect</literal> javadoc for more details on
      its operations and how they are used within Spring's JDO support.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Oracle TopLink</title>

    <para>Since Spring 1.2, Spring supports Oracle TopLink (<link
    linkend="???">http://www.oracle.com/technology/products/ias/toplink</link>)
    as data access strategy, following the same style as the Hibernate
    support. Both TopLink 9.0.4 (the production version as of Spring 1.2) and
    10.1.3 (still in beta as of Spring 1.2) are supported. The corresponding
    integration classes reside in the
    <literal>org.springframework.orm.toplink</literal> package.</para>

    <para>Spring's TopLink support has been co-developed with the Oracle
    TopLink team. Many thanks to the TopLink team, in particular to Jim Clark
    who helped to clarify details in all areas!</para>

    <sect2>
      <title>SessionFactory abstraction</title>

      <para>TopLink itself does not ship with a SessionFactory abstraction.
      Instead, multi-threaded access is based on the concept of a central
      <literal>ServerSession</literal>, which in turn is able to spawn
      <literal>ClientSession</literal>s for single-threaded usage. For
      flexible setup options, Spring defines a
      <literal>SessionFactory</literal> abstraction for TopLink, enabling to
      switch between different <literal>Session</literal> creation
      strategies.</para>

      <para>As a one-stop shop, Spring provides a
      <classname>LocalSessionFactoryBean</classname> class that allows for
      defining a TopLink <literal>SessionFactory</literal> with bean-style
      configuration. It needs to be configured with the location of the
      TopLink session configuration file, and usually also receives a
      Spring-managed JDBC <literal>DataSource</literal> to use.</para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.toplink.LocalSessionFactoryBean"&gt;
    &lt;property name="configLocation" value="toplink-sessions.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</programlisting></para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;toplink-configuration&gt;

  &lt;session&gt;
    &lt;name&gt;Session&lt;/name&gt;
    &lt;project-xml&gt;toplink-mappings.xml&lt;/project-xml&gt;
    &lt;session-type&gt;
      &lt;server-session/&gt;
    &lt;/session-type&gt;
    &lt;enable-logging&gt;true&lt;/enable-logging&gt;
    &lt;logging-options/&gt;
  &lt;/session&gt;

&lt;/toplink-configuration&gt;</programlisting>Usually,
      <literal>LocalSessionFactoryBean</literal> will hold a multi-threaded
      TopLink <literal>ServerSession</literal> underneath and create
      appropriate client <literal>Session</literal>s for it: either a plain
      <literal>Session</literal> (typical), a managed
      <literal>ClientSession</literal>, or a transaction-aware
      <literal>Session</literal> (the latter are mainly used internally by
      Spring's TopLink support). It might also hold a single-threaded TopLink
      <literal>DatabaseSession</literal>; this is rather unusual,
      though.</para>
    </sect2>

    <sect2>
      <title>TopLinkTemplate and TopLinkDaoSupport</title>

      <para>Each TopLink-based DAO will then receive the
      <literal>SessionFactory</literal> through dependency injection, i.e.
      through a bean property setter or through a constructor argument. Such a
      DAO could be coded against the plain TopLink API, fetching a
      <literal>Session</literal> from the given
      <literal>SessionFactory</literal>, but will usually rather be used with
      Spring's <literal>TopLinkTemplate</literal>:</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl implements ProductDao {
  
    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) {
        TopLinkTemplate tlTemplate = new TopLinkTemplate(this.sessionFactory);
        return (Collection) tlTemplate.execute(
            new TopLinkCallback() {
                public Object doInTopLink(Session session) throws TopLinkException {
                    ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
                    findOwnersQuery.addArgument("Category");
                    ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
                    findOwnersQuery.setSelectionCriteria(
                        builder.get("category").like(builder.getParameter("Category")));

                    Vector args = new Vector();
                    args.add(category);
                    List result = session.executeQuery(findOwnersQuery, args);
                    // do some further stuff with the result list
                    return result;
                }
            }
        );
    }
}</programlisting>

      <para>A callback implementation can effectively be used for any TopLink
      data access. <classname>TopLinkTemplate</classname> will ensure that
      <classname>Session</classname>s are properly opened and closed, and
      automatically participate in transactions. The template instances are
      thread-safe and reusable, they can thus be kept as instance variables of
      the surrounding class. For simple single-step actions such as a single
      <literal>executeQuery</literal>, <literal>readAll</literal>,
      <literal>readById</literal>, or <literal>merge</literal> call,
      <classname>JdoTemplate</classname> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <classname>TopLinkDaoSupport</classname> base class that provides a
      <literal>setSessionFactory</literal> method for receiving a
      <classname>SessionFactory</classname>, and
      <literal>getSessionFactory</literal> and
      <literal>getTopLinkTemplate</literal> for use by subclasses. In
      combination, this allows for simple DAO implementations for typical
      requirements:</para>

      <para><programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl extends TopLinkDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        return getTopLinkTemplate().executeQuery(findOwnersQuery, new Object[] {category});
    }
}</programlisting></para>

      <para>Side note: TopLink query objects are thread-safe and can be cached
      within the DAO, i.e. created on startup and kept in instance
      variables.</para>

      <para>As alternative to working with Spring's
      <literal>TopLinkTemplate</literal>, you can also code your TopLink data
      access against the plain TopLink API, explictly opening and closing a
      <literal>Session</literal>. As elaborated in the corresponding Hibernate
      section, the main advantage of this approach is that your data access
      code is able to throw checked exceptions.
      <literal>TopLinkDaoSupport</literal> offers a variety of support methods
      for this scenario, for fetching and releasing a transactional
      <literal>Session</literal> as well as for converting exceptions.</para>

      <para>DAOs can also be written against the plain TopLik API, without any
      Spring dependencies, directly using an injected TopLink
      <literal>Session</literal>. The latter will usually be a
      <literal>ServerSession</literal> that is aware of Spring-managed
      transactions, defined by a <literal>LocalSessionFactoryBean</literal>
      and exposed for bean references of type <literal>Session</literal>
      through Spring's <literal>TransactionAwareSessionAdapter</literal>. The
      <literal>getActiveSession()</literal> method defined on TopLink's
      <literal>Session</literal> interface will return the current
      transactional <literal>Session</literal> in such a scenario, both for
      Spring-managed transactions and for JTA / EJB CMT transactions.</para>
    </sect2>

    <sect2>
      <title>Transaction management</title>

      <para>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <literal>TransactionProxyFactoryBean</literal> for a
      ProductService, which in turn delegates to the TopLink-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.toplink.TopLinkTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
	    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting></para>

      <para>Note that TopLink requires an active <literal>UnitOfWork</literal>
      for modifying a persistent object. (You should never modify objects
      returned by a plain TopLink <literal>Session</literal> - those are
      usually read-only objects, directly taken from the second-level cache!)
      There is no concept like a non-transactional flush in TopLink, in
      contrast to Hibernate. For this reason, TopLink needs to be set up for a
      specific environment: in particular, it needs to be explicitly set up
      for JTA synchronization, to detect an active JTA transaction itself and
      expose a corresponding active <literal>Session</literal> and
      <literal>UnitOfWork</literal>. This is not necessary for local
      transactions as performed by Spring's
      <literal>TopLinkTransactionManager</literal>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <literal>JtaTransactionManager</literal> or by EJB CMT / plain
      JTA).</para>

      <para>Within your TopLink-based DAO code, use the
      <literal>Session.getActiveUnitOfWork()</literal> method to access the
      current <literal>UnitOfWork</literal> and perform write operations
      through it. This will only work within an active transaction (both
      within Spring-managed transactions and plain JTA transactions). For
      special needs, you can also acquire separate UnitOfWork instances that
      won't participate in the current transaction; this is hardly needed,
      though.</para>

      <para><literal>TopLinkTransactionManager</literal> is capable of
      exposing a TopLink transaction to JDBC access code that accesses the
      same JDBC <literal>DataSource</literal>, provided that TopLink works
      with JDBC in the backend and is thus able to expose the underlying JDBC
      <literal>Connection</literal>. The <literal>DataSource</literal> to
      expose the transactions for needs to be specified explicitly; it won't
      be autodetected.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Apache OJB</title>

    <para>Apache OJB (<link linkend="???">http://db.apache.org/ojb</link>)
    offers multiple API levels, such as ODMG and JDO. Aside from supporting
    OJB through JDO, Spring also supports OJB's lowe-level PersistenceBroker
    API as data access strategy. The corresponding integration classes reside
    in the <literal>org.springframework.orm.ojb</literal> package.</para>

    <sect2>
      <title>OJB setup in a Spring environment</title>

      <para>In contrast to Hibernate or JDO, OJB does not follow a factory
      object pattern for its resources. Instead, an OJB PersistenceBroker has
      to be obtained from the static PersistenceBrokerFactory class. That
      factory initializes itself from an OJB.properties file, residing in the
      root of the class path.</para>

      <para>In addition to supporting OJB's default initialization style,
      Spring also provides a <classname>Local</classname>OjbConfigurer class
      that allows for using Spring-managed <literal>DataSource</literal>
      instances as OJB connection providers. The <literal>DataSource</literal>
      instances are referenced in the OJB repository descriptor (the mapping
      file), through the "jcd-alias" defined there: each such alias is matched
      against the Spring-managed bean of the same name.</para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="ojbConfigurer" class="org.springframework.orm.ojb.support.LocalOjbConfigurer"/&gt;
   
  ...
&lt;/beans&gt;</programlisting></para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;descriptor-repository version="1.0"&gt;

  &lt;jdbc-connection-descriptor jcd-alias="dataSource" default-connection="true" ...&gt;
        ...
  &lt;/jdbc-connection-descriptor&gt;

  ...
&lt;/descriptor-repository&gt;</programlisting></para>

      <para>A PersistenceBroker can then be opened through standard OJB API,
      specifying a corresponding "PBKey", usually through the corresponding
      "jcd-alias" (or relying on the default connection).</para>
    </sect2>

    <sect2>
      <title>PersistenceBrokerTemplate and PersistenceBrokerDaoSupport</title>

      <para>Each OJB-based DAO will be configured with a "PBKey" through
      bean-style configuration, i.e. through a bean property setter. Such a
      DAO could be coded against the plain OJB API, working with OJB's static
      PersistenceBrokerFactory, but will usually rather be used with Spring's
      PersistenceBrokerTemplate:</para>

      <programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="jcdAlias" value="dataSource"/&gt;  &lt;!-- can be omitted (default) --&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</programlisting>

      <programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl implements ProductDao {
  
    private String jcdAlias;

    public void setJcdAlias(String jcdAlias) {
        this.jcdAlias = jcdAlias;
    }

    public Collection loadProductsByCategory(final String category) {
        PersistenceBrokerTemplate pbTemplate =
                new PersistenceBrokerTemplate(new PBKey(this.jcdAlias);
        return (Collection) pbTemplate.execute(
            new PersistenceBrokerCallback() {
                public Object doInPersistenceBroker(PersistenceBroker pb)
                        throws PersistenceBrokerException {

                    Criteria criteria = new Criteria();
                    criteria.addLike("category", category + "%");
                    Query query = new QueryByCriteria(Product.class, criteria);

                    List result = pb.getCollectionByQuery(query);
                    // do some further stuff with the result list
                    return result;
                }
            }
        );
    }
}</programlisting>

      <para>A callback implementation can effectively be used for any OJB data
      access. <classname>PersistenceBrokerTemplate</classname> will ensure
      that <classname>PersistenceBroker</classname>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <literal>getObjectById</literal>,
      <literal>getObjectByQuery</literal>, <literal>store</literal>, or
      <literal>delete</literal> call,
      <classname>PersistenceBrokerTemplate</classname> offers alternative
      convenience methods that can replace such one line callback
      implementations. Furthermore, Spring provides a convenient
      <classname>PersistenceBrokerDaoSupport</classname> base class that
      provides a <literal>setJcdAlias</literal> method for receiving an OJB
      JCD alias, and <literal>getPersistenceBrokerTemplate</literal> for use
      by subclasses. In combination, this allows for very simple DAO
      implementations for typical requirements:</para>

      <para><programlisting format="linespecific" xml:space="preserve">public class ProductDaoImpl extends PersistenceBrokerDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) {
        Criteria criteria = new Criteria();
        criteria.addLike("category", category + "%");
        Query query = new QueryByCriteria(Product.class, criteria);

        return getPersistenceBrokerTemplate().getCollectionByQuery(query);
    }
}</programlisting></para>

      <para>As alternative to working with Spring's
      <literal>PersistenceBrokerTemplate</literal>, you can also code your OJB
      data access against the plain OJB API, explictly opening and closing a
      <literal>PersistenceBroker</literal>. As elaborated in the corresponding
      Hibernate section, the main advantage of this approach is that your data
      access code is able to throw checked exceptions.
      <literal>PersistenceBrokerDaoSupport</literal> offers a variety of
      support methods for this scenario, for fetching and releasing a
      transactional <literal>PersistenceBroker</literal> as well as for
      converting exceptions.</para>
    </sect2>

    <sect2>
      <title>Transaction management</title>

      <para>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <literal>TransactionProxyFactoryBean</literal> for a
      ProductService, which in turn delegates to the OJB-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</para>

      <para><programlisting format="linespecific" xml:space="preserve">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.ojb.PersistenceBrokerTransactionManager"&gt;
    &lt;property name="jcdAlias" value="dataSource"/&gt;  &lt;!-- can be omitted (default) --&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
	    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting></para>

      <para>Note that OJB's PersistenceBroker level does not track changes of
      loaded objects. Therefore, a PersistenceBroker transaction is
      essentially simply a database transaction at the PersistenceBroker
      level, just with an additional first-level cache for persistent objects.
      Lazy loading will work both with and without the PersistenceBroker being
      open, in contrast to Hibernate and JDO (where the original Session or
      PersistenceManager, respectively, needs to remain open).</para>

      <para><literal>PersistenceBrokerTransactionManager</literal> is capable
      of exposing an OJB transaction to JDBC access code that accesses the
      same JDBC <literal>DataSource</literal>. The
      <literal>DataSource</literal> to expose the transactions for needs to be
      specified explicitly; it won't be autodetected.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>iBATIS SQL Maps</title>

    <para>Through the <literal>org.springframework.orm.ibatis</literal>
    package, Spring supports iBATIS SQL Maps 1.x and 2.x (<link
    linkend="???">http://www.ibatis.com</link>). The iBATIS support much
    resembles the JDBC / Hibernate support in that it supports the same
    template style programming and just as with JDBC or Hibernate, the iBATIS
    support works with Spring's exception hierarchy and let's you enjoy the
    all IoC features Spring has.</para>

    <para>Transaction management can be handled through Spring's standard
    facilities, for example through
    <literal>TransactionProxyFactoryBean</literal>. There are no special
    transaction strategies for iBATIS, as there is no special transactional
    resource involved other than a JDBC <literal>Connection</literal>. Hence,
    Spring's standard JDBC <literal>DataSourceTransactionManager</literal> or
    <literal>JtaTransactionManager</literal> are perfectly sufficient.</para>

    <sect2>
      <title>Overview and differences between iBATIS 1.x and 2.x</title>

      <para>Spring supports both iBATIS SQL Maps 1.x and 2.x. First let's have
      a look at the differences between the two.</para>

      <para>The XML config files have changed a bit, node and attribute names.
      Also the Spring classes you need to extend are different, as are some
      method names.<table frame="all">
          <title>iBATIS SQL Maps supporting classes for 1.x and 2.x</title>

          <tgroup cols="3">
            <colspec colname="c1" colwidth="4*" />

            <colspec colname="c2" colwidth="2*" />

            <colspec colname="c3" colwidth="2*" />

            <thead>
              <row>
                <entry>Feature</entry>

                <entry>1.x</entry>

                <entry>2.x</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Creation of SqlMap(Client)</entry>

                <entry><literal>SqlMapFactoryBean</literal></entry>

                <entry><literal>SqlMapClientFactoryBean</literal></entry>
              </row>

              <row>
                <entry>Template-style helper class</entry>

                <entry><literal>SqlMapTemplate</literal></entry>

                <entry><literal>SqlMapClientTemplate</literal></entry>
              </row>

              <row>
                <entry>Callback to use MappedStatement</entry>

                <entry><literal>SqlMapCallback</literal></entry>

                <entry><literal>SqlMapClientCallback</literal></entry>
              </row>

              <row>
                <entry>Super class for DAOs</entry>

                <entry><literal>SqlMapDaoSupport</literal></entry>

                <entry><literal>SqlMapClientDaoSupport</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>

    <sect2>
      <title>iBATIS SQL Maps 1.x</title>

      <sect3>
        <title>Setting up the SqlMap</title>

        <para>Using iBATIS SQL Maps involves creating SqlMap configuration
        files containing statements and result maps. Spring takes care of
        loading those using the <literal>SqlMapFactoryBean</literal>.</para>

        <para><programlisting>public class Account {

    private String name;
    private String email;
    
    public String getName() {
        return this.name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return this.email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}</programlisting>Suppose we would want to map this class. We'd have to create
        the following SqlMap. Using the query, we can later on retrieve users
        through their email addresses. <literal>Account.xml</literal>:
        <programlisting>&lt;sql-map name="Account"&gt;

  &lt;result-map name="result" class="examples.Account"&gt;
    &lt;property name="name" column="NAME" columnIndex="1"/&gt;
    &lt;property name="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/result-map&gt;
    
  &lt;mapped-statement name="getAccountByEmail" result-map="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/mapped-statement&gt;
    
  &lt;mapped-statement name="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/mapped-statement&gt;

&lt;/sql-map&gt;</programlisting> After having defined the Sql Map, we have to
        create a configuration file for iBATIS
        (<literal>sqlmap-config.xml</literal>): <programlisting>&lt;sql-map-config&gt;

  &lt;sql-map resource="example/Account.xml"/&gt;

&lt;/sql-map-config&gt;</programlisting> iBATIS loads resources from the class
        path, so be sure to add the <literal>Account.xml</literal> file to the
        class path.</para>

        <para>Using Spring, we can now very easily set up the SqlMap, using
        the <literal>SqlMapFactoryBean</literal>: <programlisting>&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMap" class="org.springframework.orm.ibatis.SqlMapFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</programlisting></para>
      </sect3>

      <sect3>
        <title>Using <literal>SqlMapDaoSupport</literal></title>

        <para>The <literal>SqlMapDaoSupport</literal> class offers a
        supporting class similar to the <literal>HibernateDaoSupport</literal>
        and the <literal>JdoDaoSupport</literal> classes. Let's implement a
        DAO: <programlisting>public class SqlMapAccountDao extends SqlMapDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapTemplate().executeQueryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapTemplate().executeUpdate("insertAccount", account);
    }
}</programlisting> As you can see, we're using the
        <literal>SqlMapTemplate</literal> to execute the query. Spring has
        initialized the SqlMap for us using the SqlMapFactoryBean, and when
        setting up the SqlMapAccountDao as follows, you're all set to go. Note
        that with iBATIS SQL Maps 1.x, the JDBC <literal>DataSource</literal>
        is usually specified on the DAO.<programlisting>&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="sqlMap" ref="sqlMap"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting></para>
      </sect3>
    </sect2>

    <sect2>
      <title>iBATIS SQL Maps 2.x</title>

      <sect3>
        <title>Setting up the SqlMapClient</title>

        <para>If we want to map the previous Account class with iBATIS 2.x we
        need to create the following SQL map <literal>Account.xml</literal>:
        <programlisting>&lt;sqlMap namespace="Account"&gt;

  &lt;resultMap id="result" class="examples.Account"&gt;
    &lt;result property="name" column="NAME" columnIndex="1"/&gt;
    &lt;result property="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/resultMap&gt;

  &lt;select id="getAccountByEmail" resultMap="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/select&gt;

  &lt;insert id="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/insert&gt;

&lt;/sqlMap&gt;</programlisting>The configuration file for iBATIS 2 changes a
        bit (<literal>sqlmap-config.xml</literal>): <programlisting>&lt;sqlMapConfig&gt;

  &lt;sqlMap resource="example/Account.xml"/&gt;

&lt;/sqlMapConfig&gt;</programlisting>Remember that iBATIS loads resources
        from the class path, so be sure to add the
        <literal>Account.xml</literal> file to the class path.</para>

        <para>We can use the <literal>SqlMapClientFactoryBean</literal> in the
        Spring application context. Note that with iBATIS SQL Maps 2.0, the
        JDBC <literal>DataSource</literal> is usually specified on the
        <literal>SqlMapClientFactoryBean</literal>, which enables lazy
        loading.<programlisting>&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</programlisting></para>
      </sect3>

      <sect3>
        <title>Using <literal>SqlMapClientDaoSupport</literal></title>

        <para>The <literal>SqlMapClientDaoSupport</literal> class offers a
        supporting class similar to the <literal>SqlMapDaoSupport</literal>.
        We extend it to implement our DAO: <programlisting>public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapClientTemplate().queryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().update("insertAccount", account);
    }
}</programlisting>In the DAO, we use the
        <literal>SqlMapClientTemplate</literal> to execute the queries, after
        setting up the SqlMapAccountDao in the application
        context:<programlisting>&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMap" ref="sqlMap"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting></para>
      </sect3>
    </sect2>
  </sect1>
</chapter>