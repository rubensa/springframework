<preface id="preface">
    <title>Preface</title>
    <para>
        Developing applications alone is hard already, implementing applications
        using platforms that promise everything but turn out to be heavy-weight,
        hard to control and not very efficient during development cycles makes
        it even harder. Spring provides a light-weight solution to 
        build enterprise-ready applications, still supporting the possibility
        of having declarative transaction management, remote access to your
        logic using RMI or webservices, mailing facilities and a decent way
        of persisting your data in a database. Spring provides an MVC framework,
        transparent ways of integrating AOP in your software and a 
        well-structured exception hierarchy for for example JDBC.
    </para>
    <para>
        Spring could potentially be a one-stop-shop for all your enterprise
        applications, however, Spring is modular, allowing you to use
        parts of it, without bothering about the rest. You can use
        the bean container, with Struts on top, but you could also choose to just
        use the Hibernate integration or the JDBC abstraction layer.
        Spring is non-intrusive, meaning you can do without any dependencies
        on the framework at all, thus not tying yourself in to Spring.
    </para>
    <para>
        This document provides a reference guide to Spring's features.
        Since this document is still work-in-progress, if you have any
        requests, comments, please post them on the userlist or on the
        forum at the SourceForge project page:
        <ulink url="http://www.sf.net/projects/springframework"/> 
    </para>
    <para>
        Before we go on a couple some words of gratitude. Chris Bauer
        (Hibernate) prepared and adapted the DocBook-XSL software in order 
        to be able to create Hibernate's reference guide, also allowing
        us to create this one.
    </para>
</preface>

<chapter id="introduction">

    <title>Introduction</title>
    <sect1 id="introduction-overview">
		<title>Overview</title>

		<para>
			Spring contains a lot of functionality and features, which are
			well-organized in seven modules shown in the diagram below.
			This section discusses each the of modules in turn.
		</para>
		<para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/spring-overview.svg" format="SVG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/spring-overview.gif" format="GIF" align="center"/>
				</imageobject>
				<caption>
					<para>Overview of the the Spring Framework
					</para>
				</caption>
			</mediaobject>
		</para>
		<para>
			The <emphasis>Core</emphasis> package is the most fundamental part of the framework and
			provides the Dependency Injection features allowing you to manage
			beans containing functionality. The basic concept here is the 
			BeanFactory, which provides a factory pattern removing the need for
			programmatic singletons and allowing you to decouple the configuration
			and specification of dependencies from your actual logic.            
		</para>
		<para>
			On top of the <emphasis>Core</emphasis> package sits the 
			<emphasis>Context</emphasis> package,
			providing a way to access beans in a framework-style manner,
			somewhat resembling a JNDI-registry. The context package inherits
			its features from the beans package and adds support text messaging using
			e.g. resource bundles, 
			event-propagation, resource-loading and transparent
			creation of contexts by, for example, a servlet container.
		</para>
		<para>
			The <emphasis>DAO</emphasis> package provides a JDBC-abstraction
			layer that removes the need to do tedious JDBC coding and parsing
			database-vendor specific error codes.
			Also, the JDBC package provides a way to do 
			programmatic as well as declarative transaction
			management, not only for classes implementing special interfaces,
			but for <emphasis>all your POJOs</emphasis>.
		</para>
		<para>
			The <emphasis>ORM</emphasis> package provides integration layers
			for popular object-relational mappers, including JDO, Hibernate
			and iBatis. Using the ORM package you can use all those O/R-mappers
			in combination with all the other features Spring offers, like
			simple declarative transaction management mentioned before.
		</para>
		<para>
			Spring's <emphasis>AOP</emphasis> package provides an 
			<emphasis>Aop Alliance</emphasis> compliant aspect-oriented
			programming implementing allowing you to define, for example,
			method-interceptors and pointcuts to cleanly decouple code
			implementing functionality that should logically speaking be separated.
			Using source-level metadata functionality you can 
			incorporate all kinds of behavioral information in your code,
			a little like .NET attributes.
		</para>
		<para>
			Spring's <emphasis>Web</emphasis> package provides the basic 
			web-oriented integration features, like multipart functionality,
			initialization of contexts using servlet listeners and 
			a web-oriented application context. When using
			Spring together with WebWork or Struts, this is the package to 
			integrate with.
		</para>
		<para>
			Spring <emphasis>Web MVC</emphasis> package provides a 
			Model-View-Controller implementation for web-applications. 
			Spring's MVC implementation is not just any implementation,
			it provides a clean separation between domain model code and
			web forms and allows you to use all the other features of the Spring
			Framework like validation.
		</para>
	</sect1>
	
	<sect1 id="overview-usagescenarios">
		<title>Usage scenarios</title>
		<para>
			With the building block described above you can use Spring in all sorts
			of scenarios, from applets up to fully-fledged enterprise application using
			Spring's transaction management functionality and for example Spring's Web framework.
		</para>
		<para>			
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/full.svg" format="SVG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/full.gif" format="GIF" align="center"/>
				</imageobject>
				<caption>
					<para>Typical full-fledged Spring web application
					</para>
				</caption>
			</mediaobject>
		</para>
		<para>
			A typical web application using most of Spring's features. Using
			<literal>TransactionProxyFactoryBeans</literal> the web application is fully transactional,
			just as it would be when using container managed transaction as provided by Enterprise
			JavaBeans. All your custom business logic can be implemented using simple POJOs, managed
			by Spring's Dependency Injection container. Additional services like sending email and
			validation, independent of the web-layer enable you to choose where to execute
			validation rules. Spring's ORM support is integrated with Hibernate, JDO and iBatis.  Using
			for example <literal>HibernateDaoSupport</literal>, you can re-use your existing Hibernate
			mappings. Form controllers seamlessly integrate the web-layer with the domain model, removing
			the need for <literal>ActionForms</literal> or other classes that transform
			HTTP parameters to values for your domain model.
		</para>
		
		<para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/thirdparty-web.svg" format="SVG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/thirdparty-web.gif" format="GIF" align="center"/>
				</imageobject>
				<caption>
					<para>Spring middle-tier using a third-party web framework
					</para>
				</caption>
			</mediaobject>
		</para>
		
		<para>
			Sometimes the situation does not allow you completely switch to a
			different framework.  Spring does not enforce you to use
			everything, it's not an <emphasis>all-or-nothing</emphasis>
			solution. Existing frontends using WebWork or Struts can be
			integrated perfectly well with a Spring-based middle-tier,
			allowing you to use the transaction features that Spring
			offers. The only thing you need to do is wire up your business
			logic using an <literal>ApplicationContext</literal> and
			integrating your Struts frontend using a
			<literal>WebApplicationContext</literal>.
		
		</para>
		
		<para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/remoting.svg" format="SVG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/remoting.gif" format="GIF" align="center"/>
				</imageobject>
				<caption>
					<para>Remoting usage scenario
					</para>
				</caption>
			</mediaobject>
		</para>
		
		<para>			
			When you need to access existing code via webservices, you can use
			Spring's <literal>Hessian-</literal>,
			<literal>Burlap-</literal>, <literal>Rmi-</literal> or <literal>JaxRpcProxyFactory</literal> classes.  Enabling remote access to existing application is all of a sudden not that hard anymore.
		</para>
		
		<para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata fileref="images/ejb.svg" format="SVG" align="center"/>
				</imageobject>
				<imageobject role="html">
					<imagedata fileref="images/ejb.gif" format="GIF" align="center"/>
				</imageobject>
				<caption>
					<para>EJBs - Wrapping existing POJOs
					</para>
				</caption>
			</mediaobject>
		</para>
		
		<para>
			Spring also provide an access-layer and abstraction-layer for Enterprise JavaBeans,
			enabling you to reuse your existing POJOs and wrap them in Stateless SessionBeans,
			for use in scalable failsafe webapplications, that might need declarative security.
		</para>
	</sect1>
	
</chapter>


