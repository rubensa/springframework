<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="scheduling">
	<title>Scheduling jobs using Quartz or Timer</title>
	<section>
		<title>Introduction</title>
		<para>
  			Spring features integration classes for scheduling support. Currently, Spring
  			supports the <classname>Timer</classname>, part of the JDK since 1.3, and the
  			Quartz Scheduler (<ulink url="http://www.quartzscheduler.org" />). Both schedulers
  			are set up using a <interfacename>FactoryBean</interfacename> with optional references
  			to <classname>Timer</classname> or <classname>Trigger</classname> instances, respectively.
  			Furthermore, a convenience class for both the Quartz Scheduler and the <classname>Timer</classname> is
  			available that allows you to invoke a method of an existing target object
			(analogous to normal <classname>MethodInvokingFactoryBean</classname> operation).
  		</para>
	</section>
	<section>
		<title>Using the OpenSymphony Quartz Scheduler</title>
		<para>
  		Quartz uses <classname>Trigger</classname>, <classname>Job</classname> and 
  		<classname>JobDetail</classname> objects to realize scheduling of all kinds of jobs.
  		For the basic concepts behind Quartz, have a look at 
  		<ulink url="http://www.opensymphony.com/quartz" />. For convenience purposes,
  		Spring offers a couple of classes that simplify the usage of Quartz within
  		Spring-based applications.
  	</para>
		<section>
			<title>Using the JobDetailBean</title>
			<para>
  				<classname>JobDetail</classname> objects contain all information needed to
  				run a job. Spring provides a so-called <classname>JobDetailBean</classname>
  				that makes the <classname>JobDetail</classname> more of an actual JavaBean
  				with sensible defaults. Let's have a look at an example:
  			</para>
  			<programlisting><![CDATA[
<bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailBean">
  <property name="jobClass" value="example.ExampleJob" />
  <property name="jobDataAsMap">
    <map>
      <entry key="timeout" value="5" />
    </map>
  </property>
</bean>]]></programlisting>
			<para>
				The job detail bean has all information it needs to run the job (<classname>ExampleJob</classname>).
				The timeout is specified as the job data map. The job data map is
				available through the <classname>JobExecutionContext</classname>
				(passed to you at execution time), but the <classname>JobDetailBean</classname>
				also maps the properties from the job data map to properties of the actual job.
				So in this case, if the <classname>ExampleJob</classname> contains a property
				named <literal>timeout</literal>, the <classname>JobDetailBean</classname> will
				automatically apply it:
			</para>
			<programlisting><![CDATA[package example;

public class ExampleJob extends QuartzJobBean {

  private int timeout;
  
  /**
   * Setter called after the ExampleJob is instantiated
   * with the value from the JobDetailBean (5)
   */ 
  public void setTimeout(int timeout) {
    this.timeout = timeout;
  }
  
  protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {
      ]]><lineannotation>// do the actual work</lineannotation><![CDATA[
  }
}]]></programlisting>
		<para>	
			All additional settings from the job detail bean are of course available to you as well.
		</para>
			<para>
				<emphasis>Note: Using the <literal>name</literal> and <literal>group</literal> properties,
				you can modify the name and the group of the job, respectively. By default the name of
				the job equals the bean name of the job detail bean (in the example above, this is
				<literal>exampleJob</literal>).</emphasis>
			</para>
		</section>
		<section>
			<title>Using the <classname>MethodInvokingJobDetailFactoryBean</classname></title>
			<para>
				Often you just need to invoke a method on a specific object. Using the
				<classname>MethodInvokingJobDetailFactoryBean</classname> you can do exactly this:
			</para>
			<programlisting><![CDATA[<bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
  <property name="targetObject" ref="exampleBusinessObject" />
  <property name="targetMethod" value="doIt" />
</bean>]]></programlisting>
			<para>
				The above example will result in the <literal>doIt</literal> being called on the
				<literal>exampleBusinessObject</literal> (see below):
			</para>
			<programlisting><![CDATA[public class BusinessObject {
  
  ]]><lineannotation>// properties and collaborators</lineannotation><![CDATA[
  
  public void doIt() {
    ]]><lineannotation>// do the actual work</lineannotation><![CDATA[
  }
}]]></programlisting>

			<programlisting><![CDATA[
<bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/>]]></programlisting>
			<para>	
				Using the <classname>MethodInvokingJobDetailFactoryBean</classname> you don't need to
				create one-line jobs that just invoke a method, and you only need to create the actual
				business object and wire up the detail object.
			</para>
			<para>
				By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering
				with each other. If you specify two triggers for the same <classname>JobDetail</classname>,
				it might be possible that before the first job has finished, the second one will start.
				If <classname>JobDetail</classname> classes implement the
				<interfacename>Stateful</interfacename> interface, this won't happen. The second job
				will not start before the first one has finished. To make jobs resulting from the
				<classname>MethodInvokingJobDetailFactoryBean</classname> non-concurrent, set the
				<literal>concurrent</literal> flag to <literal>false</literal>.
			</para>
			<programlisting><![CDATA[
<bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
  <property name="targetObject" ref="exampleBusinessObject" />
  <property name="targetMethod" value="doIt" />
  <property name="concurrent" value="false" />
</bean>
			]]></programlisting>
			<note>
				<para>
					By default, jobs will run in a concurrent fashion.
				</para>
			</note>
		</section>
		<section>
			<title>Wiring up jobs using triggers and the <classname>SchedulerFactoryBean</classname></title>
			<para>
				We've created job details, jobs and we've reviewed the convenience bean
				that allows to you invoke a method on a specific object. Of course, we still need
				to schedule the jobs themselves. This is done using triggers and a 
				<classname>SchedulerFactoryBean</classname>. Several triggers are available
				within Quartz. Spring offers two subclassed triggers with convenient defaults:
				<classname>CronTriggerBean</classname> and <classname>SimpleTriggerBean</classname>.
			</para>
			<para>
				Triggers need to be scheduled. Spring offers a <classname>SchedulerFactoryBean</classname>
				exposing properties to set the triggers. <classname>SchedulerFactoryBean</classname>
				schedules the actual jobs with those triggers.
			</para>
			<para>
				A couple of examples:
			</para>
			<programlisting><![CDATA[<bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean">
    <!-- see the example of method invoking job above -->
    <property name="jobDetail" ref="jobDetail" />
    <!-- 10 seconds -->
    <property name="startDelay" value="10000" />
    <!-- repeat every 50 seconds -->
    <property name="repeatInterval" value="50000" />
</bean>

<bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean">
    <property name="jobDetail" ref="exampleJob" />
    <!-- run every morning at 6 AM -->
    <property name="cronExpression" value="0 0 6 * * ?" />
</bean>	]]></programlisting>
			<para>
				OK, now we've set up two triggers, one running every 50 seconds with a starting delay of
				10 seconds and one every morning at 6 AM. To finalize everything, we need to set up the
				<classname>SchedulerFactoryBean</classname>:
			</para>
			<programlisting><![CDATA[<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
    <property name="triggers">
        <list>
            <ref bean="cronTrigger" />
            <ref bean="simpleTrigger" />
        </list>
    </property>
</bean>]]></programlisting>
			<para>
				More properties are available for the <classname>SchedulerFactoryBean</classname> for you
				to set, such as the	calendars used by the job details, properties to customize Quartz with,
				etc. Have a look at the JavaDoc
				(<ulink url="http://www.springframework.org/docs/api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html" />)
				for more information.
			</para>
		</section>
	</section>
	<section>
		<title>Using JDK Timer support</title>
		<para>
  			The other way to schedule jobs in Spring is using JDK Timer objects.
  			More information about the <classname>Timer</classname> class itself can be found at
  			<ulink url="http://java.sun.com/docs/books/tutorial/essential/threads/timer.html" />.
  			The concepts discussed above also apply to the <classname>Timer</classname> support.
  			You can create custom timers or use the timer that invokes methods. Wiring timers has
  			to be done using the <classname>TimerFactoryBean</classname>.
  		</para>
		<section>
			<title>Creating custom timers</title>
			<para>
  				Using the <classname>TimerTask</classname> you can create customer timer
  				tasks, similar to Quartz jobs:
			</para>
  			<programlisting><![CDATA[public class CheckEmailAddresses extends TimerTask {

  private List emailAddresses;
  
  public void setEmailAddresses(List emailAddresses) {
    this.emailAddresses = emailAddresses;
  }
  
  public void run() {
	]]><lineannotation>// iterate over all email addresses and archive them</lineannotation><![CDATA[
  }
}]]></programlisting>
			<para>
				Wiring it up is simple:
			</para>
			<programlisting><![CDATA[<bean id="checkEmail" class="examples.CheckEmailAddress">
    <property name="emailAddresses">
        <list>
            <value>test@springframework.org</value>
            <value>foo@bar.com</value>
            <value>john@doe.net</value>
        </list>
    </property>
</bean>

<bean id="scheduledTask" class="org.springframework.scheduling.timer.ScheduledTimerTask">
    <!-- wait 10 seconds before starting repeated execution -->
    <property name="delay" value="10000" />
    <!-- run every 50 seconds -->
    <property name="period" value="50000" />
    <property name="timerTask" ref="checkEmail" />
</bean>]]></programlisting>
			<para>
				<emphasis>
					Letting the task only run once can be done by changing the
					<literal>period</literal> property to -1 (or some other	negative value).
				</emphasis>
			</para>
		</section>
		<section>
			<title>Using the <classname>MethodInvokingTimerTaskFactoryBean</classname></title>
			<para>
				Similar to the Quartz support, the <classname>Timer</classname> support also features
				a component that allows you to periodically invoke a method:
			</para>
			<programlisting><![CDATA[<bean id="doIt" class="org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean">
    <property name="targetObject" ref="exampleBusinessObject" />
    <property name="targetMethod" value="doIt" />
</bean>]]></programlisting>
			<para>
				The above example will result in the <literal>doIt</literal> being called on the
				<literal>exampleBusinessObject</literal> (see below):
			</para>
			<programlisting><![CDATA[public class BusinessObject {
  
  ]]><lineannotation>// properties and collaborators</lineannotation><![CDATA[
  
  public void doIt() {
    ]]><lineannotation>// do the actual work</lineannotation><![CDATA[
  }
}]]></programlisting>
			<para>
				Changing the reference of the above example (in which the
				<classname>ScheduledTimerTask</classname> is mentioned) to the
				<literal>doIt</literal> will result in this task being executed.
			</para>
		</section>
		<section>
			<title>Wrapping up: setting up the tasks using the <classname>TimerFactoryBean</classname></title>
			<para>
				The <classname>TimerFactoryBean</classname> is similar to the Quartz
				<classname>SchedulerFactoryBean</classname> in that it serves the same
				purpose: setting up the actual scheduling. The
				<classname>TimerFactoryBean</classname> sets up an actual Timer and
				schedules the tasks it has references to. You can specify whether or not daemon
				threads should be used.
			</para>
			<programlisting><![CDATA[<bean id="timerFactory" class="org.springframework.scheduling.timer.TimerFactoryBean">
    <property name="scheduledTimerTasks">
        <list>
			<!-- see the example above -->
            <ref bean="scheduledTask" />
        </list>
    </property>
</bean>]]></programlisting>
			<para>
				That's all!
			</para>
		</section>
	</section>
</chapter>