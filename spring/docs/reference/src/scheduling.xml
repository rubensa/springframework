<chapter id="scheduling">
  <title>Scheduling jobs using Quartz or Timer</title>
  
  <sect1>
  	<title>Introduction</title>
  	<para>
  		Spring features integration classes for scheduling support. Currently, Spring
  		supports the Timer, built in in the JDK since 1.3 and the Quartz Scheduler
  		(<ulink url="http://www.quartzscheduler.org"/>). Both schedulers are set up
  		using a FactoryBean with optional references to Timers respectively Triggers.
  		Furthermore, a convenience class for both the Quartz Scheduler and the Timer is
  		available that allows you to invoke a method an a target object you can specify
  		yourself (analogous to normal <literal>MethodInvokingFactoryBeans</literal>
  	</para>
  </sect1>
  
  <sect1>
  	<title>Using the OpenSymphony Quartz Scheduler</title>
  	<para>
  		Quartz uses <literal>Triggers</literal>, <literal>Jobs</literal> and 
  		<literal>JobDetail</literal> ro realize scheduling of all kinds of jobs.
  		For the basic concepts behind Quartz, have a look at 
  		<ulink url="http://www.opensymphony.com/quartz"/>. For convenience purposes,
  		Spring offers a couple of classes that simplify usage of Quartz within
  		Spring-based applications.
  	</para>
  	<sect2>
  		<title>Using the JobDetailBean</title>
  		<para>
  			<literal>JobDetail</literal> objects contain all information needed to
  			run a job. Spring provides a so-called <literal>JobDetailBean</literal>
  			that makes the JobDetail more of an actual with sensible defaults.
  			Let's have a look at an example:
  			<programlisting><![CDATA[
<bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailBean">
  <property name="jobClass">
    <value>example.ExampleJob</value>
  </property>
  <property name="jobDataAsMap">
    <map>
      <entry key="timeout"><value>5</value></entry>
    </map>
  </property>
</bean>
			]]></programlisting>
			
			The job detail bean has all information it needs to run the job (ExampleJob).
			The timeout is specified as the job data map. The job data map is
			available through the JobExecutionContext (passed to you at execution time), but
			the <literal>JobDetailBean</literal> also maps the properties from the 
			job data map to properties of the actual job. So in this case, if the ExampleJob contains
			a property named <literal>timeout</literal>, the JobDetailBean will automatically apply it:
			<programlisting><![CDATA[
package example;

public class ExampleJob extends QuartzJobBean {

  private int timeout;
  
  /**
   * Setter called after the ExampleJob is instantiated
   * with the value from the JobDetailBean (5)
   */ 
  public void setTimeout(int timeout) {
    this.timeout = timeout;
  }
  
  protected void executeInternal(JobExecutionContext ctx)
  throws JobExecutionException {
  
      // do the actual work
      
  }
}
			]]></programlisting>
			
			All additional settings from the job detail bean are by the way available to you as well.			
		</para>
		<para>
			<emphasis>Note: Using the <literal>name</literal> and <literal>group</literal> properties,
			you can modify in which group the job runs and using what name. By default the
			name of the job equals the bean name of the job detail bean (in the example above this is
			<literal>exampleJob</literal>).</emphasis>
		</para>
			
	</sect2>
	<sect2>
		<title>Using the MethodInvokingJobDetailFactoryBean</title>
		<para>
			Often times, you just need to invoke a method on a specific object. Using the
			<literal>MethodInvokingJobDetailFactoryBean</literal> you can do exactly this:
			<programlisting><![CDATA[
<bean id="methodInvokingJobDetail" 
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
    <property name="targetObject"><ref bean="exampleBusinessObject"/></property>
    <property name="targetMethod"><value>doIt</value></property>
</bean>
]]></programlisting>
			The above example will result in the <literal>doIt</literal> being called on the exampleBusinessObject
			(see below):
			<programlisting><![CDATA[
public class BusinessObject {
  
  // properties and collaborators
  
  public void doIt() {
    // do the actual work
  }
}
			]]></programlisting>

			<programlisting><![CDATA[
<bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/>
			]]></programlisting>	
			Using the <literal>MethodInvokingJobDetailFactoryBean</literal> you don't need to
			create one-line jobs that just invoke a method, and you only need to create the actual
			business object and wire up the detail object.
		</para>
		<para>
			By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering
			with eachother. If you specify two triggers for the same JobDetail, it might be possible
			that before the first job has finished, the second one will start. If JobDetail objects
			implement the Stateful interface, this won't happen. The second job will not start
			before the first one has finished. To make jobs resulting from the MethodInvokingJobDetailFactoryBEan
			non-concurrent set the <literal>concurrent</literal> flag to <literal>false</literal>.
			<programlisting><![CDATA[
<bean id="methodInvokingJobDetail" 
  class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
    <property name="targetObject"><ref bean="exampleBusinessObject"/></property>
    <property name="targetMethod"><value>doIt</value></property>
</bean>			
			]]></programlisting>	
			<emphasis>Note: By default, jobs will run in a concurrent fashion.</emphasis>
		</para>
	</sect2>
	
	<sect2>
		<title>Wiring up jobs using triggers and the SchedulerFactoryBean</title>
		<para>
			We've created job details, jobs and we've reviewed the convenience bean
			that allows to you invoke a method on a specific object. Of course we still need
			to schedule the jobs themselves. This is done using triggers and a 
			<literal>SchedulerFactoryBean</literal>. Several triggers are available
			within Quartz. Spring offers two subclassed triggers, the <literal>CronTriggerBean</literal>
			and the <literal>SimpleTriggerBean</literal>.
		</para>
		<para>
			Triggers need to be scheduled. Spring offers a SchedulerFactoryBean exposing properties
			to set te triggers. The SchedulerFactoryBean schedules the actual triggers.
		</para>
		<para>
			A couple of examples:
			<programlisting><![CDATA[
<bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean">
  <property name="jobDetail">
    <!-- see the example of method invoking job above -->    
    <ref bean="methodInvokingJobDetail"/>
  </property>
  <property name="startDelay">
    <!-- 10 seconds -->
    <value>10000</value>
  </property>
  <property name="repeatInterval">
    <!-- repeat every 50 seconds -->
    <value>50000</value>
  </property>
</bean>

<bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean">
  <property name="jobDetail">
    <ref bean="exampleJob"/>
  </property>
  <property name="cronExpression">
    <!-- run every morning at 6 am -->
    <value>0 6 * * 1</value>
  </property>
</bean>
			]]></programlisting>
			Ok, now we've set up two triggers, one running every 50 seconds with a starting delay of
			10 seconds and one every morning at 6. To finalize everything we need to set up the 
			SchedulerFactoryBean:
			<programlisting><![CDATA[
<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
  <property name="triggers">
    <list>
      <ref local="cronTrigger"/>
      <ref local="simpleTrigger"/>
    </list>
  </property>
</bean>
			]]></programlisting>
			More properties are available for the SchedulerFactoryBean for you to set, such as the
			Calendars used by the job details, properties to customize Quartz with, etcetera. Have a look
			at the JavaDOC (<ulink url="http://www.springframework.org/docs/api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html"/>) for more information.
		</para>
	</sect2>
  </sect1>	
  
  <sect1>
  	<title>Using JDK Timer support</title>
  	<para>
  		The other way to schedule jobs is using the JDK Timer objects. More information
  		about Timers themselves can be found at
  		<ulink url="http://java.sun.com/docs/books/tutorial/essential/threads/timer.html"/>.
  		The concepts discussed above also apply to the Timer support. You can create
  		custom timers or use the timer that invokes methods. Wiring timers has to be done
  		using the TimerFactoryBean.
  	</para>  	
  	<sect2>
  		<title>Creating custom timers</title>
  		<para>
  			Using the <literal>TimerTask</literal> you can create customer timer tasks, similar to Quartz jobs:
  			<programlisting><![CDATA[
public class CheckEmailAddresses extends TimerTask {

  private List emailAddresses;
  
  public void setEmailAddresses(List emailAddresses) {
    this.emailAddresses = emailAddresses;
  }
  
  public void run() {
  
    // iterate over all email addresses and archive them
    
  }
}
			]]></programlisting>
			
			Wiring it up is simple:
			
			<programlisting><![CDATA[
<bean id="checkEmail" class="examples.CheckEmailAddress">
  <property name="emailAddresses">
    <list>
      <value>test@springframework.org</value>
      <value>foo@bar.com</value>
      <value>john@doe.net</value>
    </list>
  </property>
</bean>

<bean id="scheduledTask" class="org.springframework.scheduling.timer.ScheduledTimerTask">
  <!-- wait 10 seconds before starting repeated execution -->
  <property name="delay">
    <value>10000</value>
  </property>
  <!-- run every 50 seconds -->
  <property name="period">
    <value>50000</value>
  </property>
  <property name="timerTask">
    <ref local="checkEmail"/>
  </property>
</bean>
			]]></programlisting>			
		</para>
	</sect2>
	<sect2>
		<title>Using the MethodInvokingTimerTaskFactoryBean</title>
		<para>
			Just as the Quartz support, the Timer support also features a component that
			allows you to periodically invoke a method:
			<programlisting><![CDATA[
<bean id="methodInvokingTask" 
  class="org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean">
    <property name="targetObject"><ref bean="exampleBusinessObject"/></property>
    <property name="targetMethod"><value>doIt</value></property>
</bean>
]]></programlisting>
			The above example will result in the <literal>doIt</literal> being called on the exampleBusinessObject
			(see below):
			<programlisting><![CDATA[
public class BusinessObject {
  
  // properties and collaborators
  
  public void doIt() {
    // do the actual work
  }
}
			]]></programlisting>
			
			Changing the reference of the above example in which the ScheduledTimerTask is mentioned to the
			<literal>methodInvokingTask</literal> will result in this task to be executed.
		</para>
	</sect2>
	<sect2>
		<title>Wrapping up: setting up the tasks using the TimerFactoryBean</title>
		<para>
			The TimerFactoryBean is similar to the QuartzSchedulerFactoryBean in that is serves the same
			purpose: setting up the actual scheduling. The TimerFactoryBean sets up an actual Timer and
			schedules the tasks it has references to. You can specify whether or not daemon threads should
			be used.
			<programlisting><![CDATA[
<bean id="timerFactory" class="org.springframework.scheduling.timer.TimerFactoryBean">
  <property name="scheduledTimerTasks">
    <list>
      <!-- see the example above -->
      <ref local="scheduledTask"/>
    </list>
  </property>
</bean>
			]]></programlisting>	
			That's all!
		</para>
	</sect2>
  </sect1>
  		
</chapter>