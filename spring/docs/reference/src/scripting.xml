<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="scripting">
	<title>Scripting</title>
	<section>
		<title>Introduction</title>
		<para>
			Spring 2.0 introduces comprehensive support for integrating scripted objects
			into the Spring container.
		</para>
		<para>
            This support allows one to write any number of classes in a supported scripting
            language, and have the Spring container transparently instantiate, configure
            and dependency inject such scripted objects.
            The benefits afforded by this support are of course dependent upon your
            particular application development scenarios, but the scenario that springs
            most readily to mind is that of rapid prototyping. 
        </para>
		<para>
            The scripting languages currently supported are:
        </para>
		<itemizedlist>
			<listitem>
				<para>Groovy</para>
			</listitem>
			<listitem>
				<para>BeanShell</para>
			</listitem>
			<listitem>
				<para>JRuby</para>
			</listitem>
		</itemizedlist>
		<note>
			<para>
				The scripting support detailed in this chapter is <emphasis>only</emphasis>
				available in Spring versions 2.0 and above. There are currently
				<emphasis>no</emphasis> plans to backport the scripting support to the
				previous versions of Spring (most notably the 1.2.x line).
            </para>
		</note>
		<para>
            Fully worked examples of where this scripting support can be immediately useful
            are described in the section entitled <xref linkend="scripting-scenarios" />.
        </para>
	</section>
	<section id="scripting-a-first-example">
		<title>A first example</title>
		<para>
			This bulk of this chapter is concerned with describing the scripting support
			in detail. Before diving into all of the gory ins and outs of said support,
			let's look at a quick example of a scripted bean.
		</para>
        <para>
            The script language for this first bean is Groovy (the basis for this example
            was taken from the Spring test suite, so if you want to see equivalent examples
            in any of the other supported languages, direct yourself to the source code).
        </para>
        <para>
            Let's look at the <interfacename>Messenger</interfacename> interface that the
            Groovy bean is going to be implementing; note that this interface is defined
            in plain Java... dependant objects that are injected with a reference to the
            <interfacename>Messenger</interfacename> won't know that the underlying
            implementation is a Groovy bean. Also note that there is no requirement for
            scripted beans to implement an interface... it just happens to be the case
            in this example.
        </para>
        <programlisting><![CDATA[package org.springframework.scripting;

public interface Messenger {

    String getMessage();
}]]></programlisting>
        <para>
            And here is the definition of a class that has a dependency on said
            <interfacename>Messenger</interfacename> interface.
        </para>
        <programlisting><![CDATA[package org.springframework.scripting;

public class DefaultBookingService implements BookingService {

    private Messenger messenger;

    public void setMessenger(Messenger messenger) {
        this.messenger = messenger;
    }

    public void processBooking() {
        // use the injected Messenger object...
    }
}]]></programlisting>
        <para>
            Here is the implementation of the <interfacename>Messenger</interfacename>
            interface in Groovy.
        </para>
        <programlisting><![CDATA[// from the file 'Messenger.groovy'
package org.springframework.scripting.groovy;

// import the Messenger interface (written in Java) that is to be implemented
import org.springframework.scripting.Messenger

// define the implementation in Groovy
class GroovyMessenger implements Messenger {

	@Property String message;
}]]></programlisting>
        <para>
            And here (finally!) are the bean definitions that will effect the injection
            of the Groovy-scripted <interfacename>Messenger</interfacename> implementation
            into an instance of the <classname>BookingService</classname> class.
        </para>
        <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd">
<beans>

    <!-- this is the workhorse that effects the scripting support (explained in detail later) -->
    <bean class="org.springframework.scripting.support.ScriptFactoryPostProcessor"/>

    <!-- and this is the bean definition for the Groovy-based Messenger implementation -->
    <bean id="messenger"
          class="org.springframework.scripting.groovy.GroovyScriptFactory">
        <constructor-arg value="classpath:Messenger.groovy"/>
        <property name="message" value="I Can Do The Frug"/>
    </bean>

    <bean id="bookingService" class="x.y.DefaultBookingService">
        <property name="messenger" ref="messenger"/>
    </bean>

</beans>]]></programlisting>
        <para>
            The <literal>bookingService</literal> bean (a
            <classname>DefaultBookingService</classname>) can now use it's private
            <literal>messenger</literal> member variable as normal... because the
            <interfacename>Messenger</interfacename> instance that was injected
            into it <emphasis>is</emphasis> a Messenger instance. There is nothing
            special going on here, this is just plain Java and plain Groovy.
        </para>
        <para>
            Keep reading for the details explaining just why that
            <classname>ScriptFactoryPostProcessor</classname> bean had to be defined (and
            what exactly it is doing).
        </para>
	</section>
	<section id="scripting-beans">
		<title>Defining scripted beans</title>
		<para>
            This section describes exactly how one defines Spring managed beans in any of
            the supported scripting languages.
        </para>
		<para>
            Please note that this section does not attempt to explain the syntax and idioms of
            the supported scripting languages. The assumption is that if you want to use Groovy
            (for example) to write certain (or all) of the classes in your application, then
            you already know Groovy. If you need further details about the scripting languages
            themselves, please do consult the section entitled
            <xref linkend="scripting-resources" /> at the end of this chapter.
        </para>
		<section id="scripting-beans-concepts">
			<title>Common concepts</title>
			<para>
				The steps involved in using beans that are backed by scripts are as follows:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						Define a
						<classname>org.springframework.scripting.support.ScriptFactoryPostProcessor</classname>
						bean in your configuration.
					</para>
				</listitem>
				<listitem>
					<para>
						Then, for every scripted bean, define an appropriate
						<interfacename>org.springframework.scripting.ScriptFactory</interfacename>
						implementation.
					</para>
				</listitem>
			</itemizedlist>
			<para>
			    With regard to the first step, a
			    <classname>ScriptFactoryPostProcessor</classname> is an implementation
			    of the <interfacename>BeanPostProcessor</interfacename> interface; it
			    contains all of the logic necessary to instantiate and configure
			    scripted beans.
			</para>
			<para>
			    You only need to define one <classname>ScriptFactoryPostProcessor</classname>
			    bean, and you don't need to give it an <literal>id</literal> or
			    <literal>name</literal>; it is enough that it is simply defined. In a
			    typical scenario, the <classname>ScriptFactoryPostProcessor</classname>
			    class has no dependencies or configuration that needs to be set by an
			    application developer... simply define the bean and you're done.
			</para>
			<para>
		        However, the <classname>ScriptFactoryPostProcessor</classname> class does have
		        some additional configuration properties that come into play if you want to
		        have <emphasis>refreshable</emphasis> beans. That is, beans that are reloaded
		        and reconfigured whenever the underlying script resource is modified. See the
		        section entitled <xref linkend="scripting-refreshable-beans"/> for a full
		        treatment of this topic.
			</para>
			<para>
		        The second step involves defining scripted bean definitions, one for each
		        bean that you want to configure (this is no different to normal Java bean
		        configuration). However, instead of specifying the fully qualified classname
		        of the class that is to be instantiated and configured by the container,
		        one specifies instead the fully qualified classname of the
		        script-language-specific <interfacename>ScriptFactory</interfacename>
		        implementation class that will create an object from an arbitrary script.
		    </para>
			<para>
		        A <interfacename>ScriptFactory</interfacename> defines a factory-style
		        interface for creating
				Java objects from an arbitrary script resource. In the case of Groovy, the
				particular <interfacename>ScriptFactory</interfacename> required is the
				<classname>org.springframework.scripting.groovy.GroovyScriptFactory</classname>
				class. (See the language specific sections below for the details of what
				particular <interfacename>ScriptFactory</interfacename> implementation
				class is required for each language.)
			</para>
			<para>
				There is one <emphasis>very</emphasis> important thing to be aware of
				with regard to Spring's scripting support. Namely, it is not (currently)
				possible to supply constructor arguments to scripted beans (and hence
				constructor-injection is not available for scripted beans). Constructor
				arguments defined on an <literal>xxxScriptFactory</literal>
				are instead passed to the actual <literal>xxxScriptFactory</literal>
				instance itself... and conversely, any and all property values are
				<emphasis>passed straight through</emphasis> to the scripted bean
				once it has been instantiated. In all of the
				<interfacename>ScriptFactory</interfacename> implementations that
				Spring provides, one of the constructor arguments is
				always a path to the script file (see also the section entitled
				<xref linkend="scripting-beans-concepts-inline"/>).
			</para>
			<para>
	            Finally, if it is not immediately obvious, all of the usual Spring
	            container lifecycles apply to scripted beans. That is, the beans themselves
	            can be defined as singletons and prototypes, and the classes of such
	            beans can implement lifecycle callback interfaces such as Spring's
	            <interfacename>InitializingBean</interfacename> and
	            <interfacename>DisposableBean</interfacename>. 
			</para>
			<section id="scripting-refreshable-beans">
				<title>Refreshable beans</title>
				<para>
		            [TODO]
				</para>
			</section>
			<section id="scripting-beans-concepts-inline">
				<title>Inline scripts</title>
				<para>
					The scripting support can also cater for scripts that are embedded
					directly in Spring bean definitions. More specifically, the
					<literal>inline:</literal> prefix allows one to define a script
					immediately inside a Spring configuration file (the beans in Spring
					containers are typically configured via XML files; the
					<literal>inline:</literal> script prefix can of course be utilised in
		            other configuration scenarios). An example will perhaps make the
		            inline script feature crystal clear:
		        </para>
				<programlisting><![CDATA[<bean id="messageService"
      class="org.springframework.scripting.groovy.GroovyScriptFactory">
    <constructor-arg>
        <value>inline:
package org.springframework.scripting.groovy;

import org.springframework.scripting.Messenger

class GroovyMessenger implements Messenger {

	@Property String message;

}</value>
    </constructor-arg>
</bean>]]></programlisting>
				<para>
					If we put to one side the issues surrounding whether it is good practice
					to define a script inside a Spring configuration file, the
					<literal>inline:</literal> notation can be useful in some scenarios; for
					instance we might want to quickly add a Spring
					<interfacename>Validator</interfacename> implementation to a Spring MVC
					<interfacename>Controller</interfacename>... this is a moments work
					using an inline script. (See the section entitled
					<xref linkend="scripting-scenarios-validators"/>  for just such	an example.)
				</para>
				<para>
		            Also don't forget that in the case of more complex classes than the one
		            shown above, you may have to surround the inline script in a
		            <literal>&lt;![CDATA[]]&gt;</literal> region.
				</para>
				<note>
					<para>
			            Do <emphasis>not</emphasis> have any text such as whitespace preceding
			            the <literal>inline:</literal> notation. If you do, the text will
			            <emphasis>not</emphasis> be recognized as an inline script source, and
			            normal <interfacename>Resource</interfacename> loading rules will apply:
			            this will lead to a nasty exception the root cause of which will not
			            be immediately obvious.
					</para>
				</note>
				<para>
		            Find below an example of defining the script for a JRuby-based bean
		            directly in a Spring XML configuration file using the
		            <literal>inline:</literal> notation. (Notice the use of the <![CDATA[&lt;]]>
		            characters to denote a <literal>'&lt;'</literal> character.)
				</para>
				<programlisting><![CDATA[    <bean id="messenger" class="org.springframework.scripting.jruby.JRubyScriptFactory">
        <constructor-arg>
            <value>inline:require 'java'

include_class 'org.springframework.scripting.Messenger'

class RubyMessenger &lt; Messenger

 def setMessage(message)
  @@message = message
 end

 def getMessage
  @@message
 end
end
RubyMessenger.new</value>
        </constructor-arg>
        <constructor-arg value="org.springframework.scripting.Messenger"/>
        <property name="message" value="Hello World!"/>
    </bean>]]></programlisting>
			</section>
		</section>
		<section id="scripting-beans-groovy">
			<title>Groovy beans</title>
			<para>
				From the Groovy homepage...
			</para>
			<quote>
				<emphasis>Groovy is an agile dynamic language for the Java 2 Platform that has
				many of the	features that people like so much in languages like Python, Ruby
				and Smalltalk, making them available to Java developers using a Java-like syntax.
				</emphasis>
			</quote>
			<para>
				The core class in Spring's Groovy support is the Groovy-specific implementation
				of the <interfacename>ScriptFactory</interfacename> interface: the
				<classname>GroovyScriptFactory</classname>. The
				<classname>GroovyScriptFactory</classname> has one constructor that takes a
				single argument that is a path to the script resource containing the
				Groovy script. Any of the usual <interfacename>Resource</interfacename>
				<footnote id="scripting-resources-footnote">
					<para>
			            See the section entitled <xref linkend="resources"/> for a full
			            treatment of Spring's low level resource handling abstraction.
					</para>
				</footnote>
				path strings can be used here, in addition to the scripting-specific
				<literal>inline:</literal> notation for inline scripts.
			</para>
			<para>
	            Any properties that are defined on the bean definition will be set on the
	            object that is returned by the <classname>GroovyScriptFactory</classname>.
	            You will also need to have the <filename>groovy.jar</filename> file (and all
	            of its dependencies) on your classpath if you want to use Groovy and Spring
	            in this fashion.
			</para>
			<para>
	            It is important that you <emphasis>do not</emphasis> define more than one
	            class per Groovy script. While this is perfectly legal in Groovy, it is
	            (arguably) a bad practice: one should (in the opinion of this author)
	            respect the standard Java conventions of one (public) class per source file.
	            If you do define more than one class per Groovy script (again, it must be
	            pointed out that this is not encouraged), then do make sure that the class
	            you are going to expose via the <classname>GroovyScriptFactory</classname>
	            is defined <emphasis>first</emphasis> in said script (otherwise a nasty and
	            probably not very helpful exception will be thrown when the Spring IoC container
	            starts either trying to inject dependencies into the scripted object or
	            tries to inject the scripted object into other collaborators as a dependency
	            itself).
			</para>
			<para>
	            That is pretty much it so far as Groovy-based beans go; there is not a whole
	            lot more that can be added. It really is a case of defining one
	            <classname>GroovyScriptFactory</classname> for each Groovy-based bean that
	            you want to configure. The underlying Groovy implementation takes care of
	            all the hard details such as parsing and compiling the script and
	            instantiating an instance of the Groovy-based class. Groove on!
			</para>
			<para>
				See the section entitled <xref linkend="scripting-scenarios" /> for
				some scenarios where one might want to use Groovy-based beans.
			</para>
		</section>
		<section id="scripting-beans-bsh">
			<title>BeanShell beans</title>
			<para>
				From the BeanShell homepage...
			</para>
			<quote>
				<emphasis>BeanShell is a small, free, embeddable Java source interpreter
				with object scripting language features, written in Java. BeanShell
				dynamically executes standard Java syntax and extends it with common
				scripting conveniences such as loose types, commands, and method closures
				like those in Perl and JavaScript.</emphasis>
			</quote>
			<para>
	            [TODO]
			</para>
			<para>
				See the section entitled <xref linkend="scripting-scenarios" /> for some
				scenarios where one might want to use BeanShell-based beans.
			</para>
		</section>
		<section id="scripting-beans-jruby">
			<title>JRuby beans</title>
			<para>
				From the JRuby homepage...
			</para>
			<quote>
				<emphasis>[JRuby is an] Effort to recreate the Ruby interpreter written
				in Java, and a Ruby to Java bytecode compiler.</emphasis>
			</quote>
			<para>
				The core class in Spring's JRuby support is the JRuby-specific implementation
				of the <interfacename>ScriptFactory</interfacename> interface: the
				<classname>JRubyScriptFactory</classname>. The
				<classname>JRubyScriptFactory</classname> has one constructor that takes as
				its arguments a path to the script resource containing the
				JRuby script, and a <classname>Class[]</classname> array containing the
				interfaces that the bean is to implement. Any of the usual
				<interfacename>Resource</interfacename>
				<footnoteref linkend="scripting-resources-footnote"/> path strings can be
				used here, in addition to the scripting-specific <literal>inline:</literal>
				notation for inline scripts.
			</para>
			<para>
	            Any properties that are defined on the bean definition will be set on the
	            object that is returned by the <classname>JRubyScriptFactory</classname>.
	            You will also need to have the <filename>jruby.jar</filename> file (and all
	            of its dependencies) on your classpath if you want to use JRuby and Spring
	            in this fashion.
			</para>
			<para>
	            Let's look at a fully working example of using a JRuby-based bean. Here is
	            the JRuby implementation of the <interfacename>Messenger</interfacename>
	            interface that was defined earlier in this chapter (for your convenience it
	            is repeated below).
			</para>
        <programlisting><![CDATA[package org.springframework.scripting;

public interface Messenger {

    String getMessage();
}]]></programlisting>
	        <programlisting><![CDATA[require 'java'

include_class 'org.springframework.scripting.Messenger'

class RubyMessenger < Messenger

 def setMessage(message)
  @@message = message
 end

 def getMessage
  @@message
 end
end
RubyMessenger.new]]></programlisting>
			<para>
	            And here is the Spring XML that defines an instance of the
	            <classname>RubyMessenger</classname> JRuby bean.
			</para>
			<programlisting><![CDATA[    <bean id="messageService" class="org.springframework.scripting.jruby.JRubyScriptFactory">
        <constructor-arg value="classpath:scripts/RubyMessenger.rb"/>
        <constructor-arg value="org.springframework.scripting.Messenger"/>
        <property name="message" value="Hello World!"/>
    </bean>]]></programlisting>
			<para>
				Take especial notice of the last line of that JRuby script. When using JRuby
				in the context of Spring's scripting support, it is <emphasis>vitally</emphasis>
				important that you return a new instance of the JRuby class that you want to
				expose as a scripted bean as the result of the execution of your script. You
				can achieve this by simply instantiating a new instance of your JRuby class
				on the last line of the script like so:
	        </para>
	        <programlisting><![CDATA[require 'java'

include_class 'org.springframework.scripting.Messenger'

# class definition same as above...

# this last line is required! if omitted, bad things will happen
RubyMessenger.new]]></programlisting>
	        <para>
				If you forget to do this, an opaque <classname>ScriptCompilationException</classname>
				will be thrown immediately after the JRuby script is executed by the JRuby interpeter.
				The key text that identifies this as the root cause of an exception can be found
				immediately below (so if your Spring container throws an exception at startup and the
				following text is there, you can pretty much identify the cause immediately):
			</para>
			<programlisting><![CDATA[org.springframework.scripting.ScriptCompilationException: Compilation of JRuby script returned '']]></programlisting>
			<para>
	            To rectify this, simply instantiate a new instance of whatever class you want
	            to expose as a JRuby-scripted bean (as shown above). Please also note that you
	            can actually define as many classes and objects as you want in your JRuby script...
	            what is important is that the script as a whole must return an object (for Spring
	            to configure), and the easiest way to do that in JRuby is to simply instantiate
	            a new instance of your JRuby class on the last line of the script.
			</para>
			<para>
	            And that is it... it's really just a case of defining one
	            <classname>JRubyScriptFactory</classname> for each JRuby-based bean that
	            you want to configure. The underlying JRuby implementation takes care of
	            all the hard details such as parsing and compiling the script and
	            instantiating an instance of the JRuby-based class.
			</para>
			<para>
				See the section entitled <xref linkend="scripting-scenarios" /> for some
				scenarios where one might want to use JRuby-based beans.
			</para>
		</section>
	</section>
	<section id="scripting-extending">
		<title>Adding support for other scripting languages</title>
		<para>
            Although Spring supports (arguably) the most popular Java scripting languages
            straight out of the box, you may wish to add support for another scripting
            language. This section describes the classes and work that would be
            involved in adding support for your favourite scripting language to Spring.
        </para>
        <para>
            [TODO]
        </para>
	</section>
	<section id="scripting-scenarios">
		<title>Scenarios</title>
		<para>
            The possible scenarios where defining Spring managed beans in a scripting
            language would be beneficial are, of course, many and varied. This section
            describes some use cases for the scripting support in Spring.
        </para>
		<section id="scripting-scenarios-controllers">
			<title>Scripted Spring MVC Controllers</title>
			<para>
				[TODO]
			</para>
		</section>
		<section id="scripting-scenarios-validators">
			<title>Scripted Validators</title>
			<para>
				[TODO]
			</para>
		</section>
	</section>
	<section id="scripting-resources">
		<title>Further Resources</title>
		<para>
            Find below links to further resources about the various scripting languages
            described in this chapter.
        </para>
		<itemizedlist>
			<listitem>
				<para>The <ulink url="http://groovy.codehaus.org/">Groovy</ulink> homepage</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://www.beanshell.org/">BeanShell</ulink> homepage</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://jruby.sourceforge.net/">JRuby</ulink> homepage</para>
			</listitem>
		</itemizedlist>
	</section>
</chapter>
