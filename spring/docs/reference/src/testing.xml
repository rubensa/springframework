<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="testing">
	<title>Testing</title>
	<section id="testing-introduction">
		<title>Introduction</title>
		<para>The Spring team considers developer testing to be an absolutely
		integral part of enterprise software development. A thorough treatment
		of testing in the enterprise is beyond the scope of this chapter;
		rather, the focus here is on the value add that the adoption of the
		IoC principle can bring to <link linkend="unit-testing">unit testing</link>;
		and on the benefits that the Spring Framework provides in
		<link linkend="integration-testing">integration testing</link>.</para>
	</section>
	<section id="unit-testing">
		<title>Unit testing</title>
		<para>One of the main benefits of Dependency Injection is that your code
		should really depend far less on the container than in traditional J2EE
		development. The POJOs that comprise your application should be testable
		in JUnit tests, with objects simply instantiated using the
		<literal>new</literal> operator, <emphasis>without Spring or any other
		container</emphasis>. You can use mock objects (in conjunction with many
		other valuable testing techniques) to test your code in isolation. If you
		follow the architecture recommendations around Spring you will find that
		the resulting clean layering and componentization of your codebase will
		naturally faciliate <emphasis>easier</emphasis> unit testing. For example,
		you will be able to test service layer objects by stubbing or mocking DAO
		interfaces, without any need to access persistent data while running unit
		tests.</para>
		<para>True unit tests typically will run extremely quickly, as there is no
		runtime infrastructure to set up, whether application server, database, ORM
		tool, or whatever. Thus emphasizing true unit tests as part of your
		development methodology will boost your productivity. The upshot of this is
		that you do not need this section of the testing chapter to help you write
		effective <emphasis>unit</emphasis> tests for your IoC-based applications.</para>
	</section>
	<section id="integration-testing">
		<title>Integration testing</title>
		<para>However, it is also important to be able to perform some integration
		testing without requiring deployment to your application server or
		connecting to other enterprise infrastructure. This will enable you to test
		things such as:</para>
		<itemizedlist>
			<listitem>
				<para>The correct wiring of your Spring IoC container contexts.</para>
			</listitem>
			<listitem>
				<para>Data access using JDBC or an ORM tool. This would include
				such things such as the correctness of SQL statements / or Hibernate
				XML mapping files.</para>
			</listitem>
		</itemizedlist>
		<para>The Spring Framework provides first class support for integration
		testing in the form of the classes that are packaged in the
		<filename class="libraryfile">spring-mock.jar</filename> library.
		<emphasis>Please note that these test classes are JUnit-specific.</emphasis></para>
		<para>The <literal>org.springframework.test</literal> package provides
		valuable JUnit <classname>TestCase</classname> superclasses for integration
		testing using a Spring container, while at the same time not being reliant
		on an application server or other deployed environment. They will be slower
		to run than unit tests, but much faster to run than the equivalent Cactus
		tests or remote tests relying on deployment to an application server.</para>
		<para>These superclasses provide the following functionality:</para>
		<itemizedlist>
			<listitem>
				<para><link linkend="testing-ctx-management">Spring IoC container caching</link>
				between test case execution.</para>
			</listitem>
			<listitem>
				<para>The pretty-much-transparent
				<link linkend="testing-fixture-di">Dependency Injection of test fixture instances</link>
				(this is nice).</para>
			</listitem>
			<listitem>
				<para><link linkend="testing-tx">Transaction management</link>
				appropriate to integration testing (this is even nicer).</para>
			</listitem>
			<listitem>
				<para>A number of Spring-specific
				<link linkend="testing-superclasses">inherited instance variables</link>
				that are really useful when integration testing.</para>
			</listitem>
		</itemizedlist>
		<section id="testing-ctx-management">
			<title>Context management and caching</title>
			<para>The <literal>org.springframework.test</literal> package provides
			support for consistent loading of Spring contexts, and caching of loaded
			contexts. Support for the caching of loaded contexts is important,
			because if you are working on a large project, startup time may become
			an issue - not because of the overhead of Spring itself, but because the
			objects instantiated by the Spring container will themselves take time
			to instantiate. For example, a project with 50-100 Hibernate mapping
			files might take 10-20 seconds to load the mapping files, and incurring
			that cost before running every single test case in every single test
			fixture will lead to slower overall test runs that could reduce productivity.</para>
			<para>To address this issue, the
			<classname>AbstractDependencyInjectionSpringContextTests</classname> has an
			<literal>protected</literal> method that subclasses must implement
			to provide the location of context definition files:</para>
		    <programlisting><![CDATA[protected String[] getConfigLocations();]]></programlisting>
			<para>Implementations of this method must provide an array containing the
			resource locations of XML configuration metadata - typically on the
			classpath - used to configure the application. This will be the same, or
			nearly the same, as the list of configuration locations specified in
			<literal>web.xml</literal> or other deployment configuration.</para>
			<para>By default, once loaded, the configuration fileset will be reused
			for each test case. Thus the setup cost will be incurred only once (per
			test fixture), and subsequent test execution will be much faster. In
			the unlikely case that a test may 'dirty' the config location, requiring
			reloading - for example, by changing a bean definition or the state of
			an application object - you can call the
			<methodname>setDirty()</methodname>	method on
			<classname>AbstractDependencyInjectionSpringContextTests</classname> to
			cause the test fixture to reload the configurations and rebuild the
			application context before executing the next test case.</para>
		</section>
		<section id="testing-fixture-di">
			<title>Dependency Injection of test fixtures</title>
			<para>When <classname>AbstractDependencyInjectionSpringContextTests</classname>
			(and subclasses) load your application context, they can optionally
			configure instances of your test classes by Setter Injection. All you
			need to do is to define instance variables and the corresponding
			setters. <classname>AbstractDependencyInjectionSpringContextTests</classname>
			will automatically locate the corresponding object in the set of
			configuration files specified in the <methodname>getConfigLocations()</methodname>
			method.</para>
			<para>Consider the scenario where we have a class,
			<classname>HibernateTitleDao</classname>, that performs data access
			logic for say, the <classname>Title</classname> domain object. We want
			to write integration tests that test all of the following areas:</para>
			<itemizedlist>
				<listitem>
					<para>The Spring configuration; basically, is everything related
					to the configuration of the
					<classname>HibernateTitleDao</classname> bean correct and present?</para>
				</listitem>
				<listitem>
					<para>The Hibernate mapping file configuration; is everything
					mapped correctly and are the correct lazy-loading settings in place?</para>
				</listitem>
				<listitem>
					<para>The logic of the <classname>HibernateTitleDao</classname>;
					does the configured instance of this class perform as anticipated?</para>
				</listitem>
			</itemizedlist>
			<para>Let's look at the test class itself (we will look at the
			configuration immediately afterwards).</para>
			<programlisting><![CDATA[public final class HibernateTitleDaoTests ]]><emphasis role="bold">extends AbstractDependencyInjectionSpringContextTests</emphasis><![CDATA[  {

    ]]><lineannotation>// this instance will be (automatically) dependency injected</lineannotation><![CDATA[    
    private HibernateTitleDao titleDao;

    ]]><lineannotation>// a setter method to enable DI of the 'titleDao' instance variable</lineannotation><![CDATA[
    public void setTitleDao(HibernateTitleDao titleDao) {
        this.titleDao = titleDao;
    }

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }

    ]]><lineannotation>// specifies the Spring configuration to load for this test fixture</lineannotation><![CDATA[
    protected String[] getConfigLocations() {
        return new String[] { "classpath:com/foo/daos.xml" };
    }

}]]></programlisting>
			<para>The file referenced by the
			<methodname>getConfigLocations()</methodname> method
			(<literal>'classpath:com/foo/daos.xml'</literal>) looks like this:</para>
			<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC  "-//SPRING//DTD BEAN 2.0//EN"
    "http://www.springframework.org/dtd/http://www.springframework.org/dtd/spring-beans-2.0.dtd">
<beans>

    ]]><lineannotation>&lt;!-- this bean will be injected into the <classname>HibernateTitleDaoTests</classname> class --&gt;</lineannotation><![CDATA[
    <bean id="titleDao" class="com.foo.dao.hibernate.HibernateTitleDao">
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>
    
    <bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
        ]]><lineannotation>&lt;!-- dependencies elided for clarity --&gt;</lineannotation><![CDATA[
    </bean>

</beans>]]></programlisting>
			<para>The <classname>AbstractDependencyInjectionSpringContextTests</classname>
			classes uses
			<link linkend="beans-factory-autowire"><emphasis>autowire by type</emphasis></link>.
			Thus if you have multiple bean definitions of the same type, you cannot
			rely on this approach for those particular beans. In that case, you can
			use the inherited <literal>applicationContext</literal> instance variable,
			and explicit lookup using (for example) an explicit call to
			<methodname>applicationContext.getBean("titleDao")</methodname>.</para>
			<para>If you don't want dependency injection applied to your test cases,
			simply don't declare any setters. Alternatively, you can extend the
			<classname>AbstractSpringContextTests</classname> - the root of the class
			hierarchy in the <literal>org.springframework.test</literal> package.
			It merely contains convenience methods to load Spring contexts, and
			performs no Dependency Injection of the test fixture.</para>
			<section id="testing-fixture-di-field">
				<title>Field level injection</title>
				<para>If, for whatever reason, you don't fancy having setter
				methods in your test fixtures, Spring can (in this one case)
				inject dependencies into <literal>protected</literal> fields.
				Find below a reworking of the previous example to use field level
				injection (the Spring XML configuration does not need to change,
				merely the test fixture).</para>
				<programlisting><![CDATA[public final class HibernateTitleDaoTests ]]><emphasis role="bold">extends AbstractDependencyInjectionSpringContextTests</emphasis><![CDATA[  {

    public HibernateTitleDaoTests() {
    	]]><lineannotation>// switch on field level injection</lineannotation><![CDATA[
        setPopulateProtectedVariables(true);
    }

    ]]><lineannotation>// this instance will be (automatically) dependency injected</lineannotation><![CDATA[
    ]]><lineannotation><emphasis>protected</emphasis></lineannotation><![CDATA[ HibernateTitleDao ]]><lineannotation><emphasis>titleDao</emphasis></lineannotation><![CDATA[;

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }

    ]]><lineannotation>// specifies the Spring configuration to load for this test fixture</lineannotation><![CDATA[
    protected String[] getConfigLocations() {
        return new String[] { "classpath:com/foo/daos.xml" };
    }

}]]></programlisting>
				<para>In the case of field injection, there is no autowiring going on:
				the name of your <literal>protected</literal> instances variable(s)
				are used as the lookup bean name in the configured Spring container.</para>
			</section>
		</section>
		<section id="testing-tx">
			<title>Transaction management</title>
			<para>One common issue in tests that access a real database is their
			affect on the state of the persistence store. Even when you're using
			a development database, changes to the state may affect future tests.
			Also, many operations - such as inserting to or modifying
			persistent data - cannot be done (or verified) outside a transaction.</para>
			<para>The
			<classname>org.springframework.test.AbstractTransactionalDataSourceSpringContextTests</classname>
			superclass (and subclasses) exist to meet this need. By default, they
			create and roll back a transaction for each test. You simply write
			code that can assume the existence of a transaction. If you call
			transactionally proxied objects in your tests, they will behave
			correctly, according to their transactional semantics. </para>
			<para> <classname>AbstractTransactionalSpringContextTests</classname>
			depends on a <classname>PlatformTransactionManager</classname> bean being
			defined in the application context. The name doesn't matter, due to the
			use of autowire by type.</para>
			<para>Typically you will extend the subclass,
			<classname>AbstractTransactionalDataSourceSpringContextTests</classname>.
			This also requires that a <classname>DataSource</classname> bean
			definition - again, with any name - be present in the configurations. It
			creates a <classname>JdbcTemplate</classname> instance variable that is
			useful for convenient querying, and provides handy methods to delete the
			contents of selected tables (remember that the transaction will roll
			back by default, so this is safe to do).</para>
			<para>If you want a transaction to commit - unusual, but occasionally
			useful when you want a particular test to populate the database - you can
			call the <methodname>setComplete()</methodname> method inherited from
			<classname>AbstractTransactionalSpringContextTests</classname>. This will
			cause the transaction to commit instead of roll back.</para>
			<para>There is also convenient ability to end a transaction before the
			test case ends, through calling the <methodname>endTransaction()</methodname> method.
			This will roll back the transaction by default, and commit it only if
			<methodname>setComplete()</methodname> had previously been called. This
			functionality is useful if you want to test the behavior of
			'disconnected' data objects, such as Hibernate-mapped objects
			that will be used in a web or remoting tier outside a transaction.
			Often, lazy loading errors are discovered only through UI testing; if
			you call <methodname>endTransaction()</methodname> you can ensure correct
			operation of the UI through your JUnit test suite.</para>
		</section>
		<section id="testing-superclasses">
			<title>Convenience variables</title>
			<para>When you extend the
			<classname>AbstractTransactionalDataSourceSpringContextTests</classname>
			class you will have access to the following <literal>protected</literal>
			instance variables:</para>
			<itemizedlist>
				<listitem>
					<para><literal>applicationContext</literal>
					(a <interfacename>ConfigurableApplicationContext</interfacename>):
					inherited from the
					<classname>AbstractDependencyInjectionSpringContextTests</classname>
					superclass. Use this to perfom explicit bean lookup, or test the
					state of the context as a whole.</para>
				</listitem>
				<listitem>
					<para><literal>jdbcTemplate</literal>: inherited from
					<classname>AbstractTransactionalDataSourceSpringContextTests</classname>.
					Useful for querying to confirm state. For example, you might query
					before and after testing application code that creates an object and
					persists it using an ORM tool, to verify that the data appears in
					the database. (Spring will ensure that the query runs in the scope
					of the same transaction.) You will need to tell your ORM tool to
					'flush' its changes for this to work correctly, for example
					using the <methodname>flush()</methodname> method on Hibernate's
					<classname>Session</classname> interface.</para>
				</listitem>
			</itemizedlist>
			<para>Often you will provide an application-wide superclass for
			integration tests that provides further useful instance variables
			used in many tests.</para>
		</section>
		<section id="testing-java5-support">
			<title>Java5+ specific support</title>
			<para>If you are developing against Java5 or greater, there are
			some additional annotations and support classes that you can use
			in your testing. The <classname>AbstractAnnotationAwareTransactionalTests</classname>
			class extends the <classname>AbstractTransactionalDataSourceSpringContextTests</classname>
			makes the text fixtures that you write that inherit from it aware of a number
			of (Spring-specific) annotations.</para>
			<section id="testing-java5-support-annotations">
				<title>Annotations</title>
				<para>The Spring Framework provides a number of annotations to
				help when writing integration tests. Please note that these annotations
				<emphasis>must</emphasis> be used in conjunction with the
				aforementioned
				<classname>AbstractAnnotationAwareTransactionalTests</classname> in
				order for the presence of these annotations to have any effect.</para>
				<itemizedlist>
					<listitem>
						<para><interfacename>@DirtiesContext</interfacename>.</para>
						<para>The presence
						of this annotation on a text method indicates that the
						underlying Spring container is 'dirtied' during the execution of
					    of the test method, and thus must be rebuilt after the test
						method finishes execution (regardless of whether the test
						passed or not). Has the same effect as a regular
						<methodname>setDirty()</methodname> invocation.</para>
						<programlisting><![CDATA[@DirtiesContext
public void testProcess() {
	]]><lineannotation>// some logic that results in the Spring container being dirtied</lineannotation><![CDATA[
}]]></programlisting>
					</listitem>
					<listitem>
						<para><interfacename>@ExpectedException</interfacename>.</para>
						<para>Indicates that the annotated test method is expected to throw
						an exception during execution. The type of the expected
						exception is provided in the annotation, and if an an instance
						of the exception is thrown during the test method execution then
						the test passes. Likewise if an instance
						of the exception is <emphasis>not</emphasis> thrown during the
						test method execution then the test fails.</para>
						<programlisting><![CDATA[@ExpectedException(SomeBusinessException.class)
public void testProcessRainyDayScenario() {
	]]><lineannotation>// some logic that results in an <classname>Exception</classname> being thrown</lineannotation><![CDATA[
}]]></programlisting>
					</listitem>
					<listitem>
						<para><interfacename>@NotTransactional</interfacename>.</para>
						<para>Simply indicates that the annotated test method must
						<emphasis>not</emphasis> execute in a transactional context.</para>
						<programlisting><![CDATA[@NotTransactional
public void testProcess() {
	]]><lineannotation>// ...</lineannotation><![CDATA[
}]]></programlisting>
					</listitem>
					<listitem>
						<para><interfacename>@Repeat</interfacename></para>
						<para>Indicates that the annotated test method must be
						executed repeatedly. The number of times that the test
						method is to be executed is specified in the annotation.</para>
						<programlisting><![CDATA[@Repeat(10)
public void testProcessRepeatedly() {
	]]><lineannotation>// ...</lineannotation><![CDATA[
}]]></programlisting>
					</listitem>
				</itemizedlist>
			</section>
		</section>
		<section id="testing-examples-petclinic">
			<title>PetClinic example</title>
			<para>The PetClinic sample application included with the Spring
			distribution illustrates the use of these test superclasses. Most
			test functionality is included in the
			<classname>AbstractClinicTests</classname>,	for which a partial
			listing is shown below:</para>
			<programlisting><![CDATA[public abstract class AbstractClinicTests
               extends AbstractTransactionalDataSourceSpringContextTests {

   protected Clinic clinic;

   public void setClinic(Clinic clinic) {
      this.clinic = clinic;
   }

   public void testGetVets() {
      Collection vets = this.clinic.getVets();
      assertEquals('JDBC query must show the same number of vets',
         jdbcTemplate.queryForInt('SELECT COUNT(0) FROM VETS'), 
         vets.size());
      Vet v1 = (Vet) EntityUtils.getById(vets, Vet.class, 2);
      assertEquals('Leary', v1.getLastName());
      assertEquals(1, v1.getNrOfSpecialties());
      assertEquals('radiology', ((Specialty) v1.getSpecialties().get(0)).getName());
      Vet v2 = (Vet) EntityUtils.getById(vets, Vet.class, 3);
      assertEquals('Douglas', v2.getLastName());
      assertEquals(2, v2.getNrOfSpecialties());
      assertEquals('dentistry', ((Specialty) v2.getSpecialties().get(0)).getName());
      assertEquals('surgery', ((Specialty) v2.getSpecialties().get(1)).getName());
}]]></programlisting>
			<para>Notes:</para>
			<itemizedlist>
				<listitem>
					<para>This test case extends the
					<classname>AbstractTransactionalDataSourceSpringContextTests</classname>
					class, from which it inherits Dependency Injection and transactional
					behavior.</para>
				</listitem>
				<listitem>
					<para>The <literal>clinic</literal> instance variable - the application object
					being tested - is set by Dependency Injection through the
					<methodname>setClinic(..)</methodname> method.</para>
				</listitem>
				<listitem>
					<para>The <methodname>testGetVets()</methodname> method illustrates how the
					inherited <literal>JdbcTemplate</literal> variable can be used to verify
					correct behavior of the application code being tested. This allows
					for stronger tests, and lessens dependency on the exact test data.
					For example, you can add additional rows in the database without
					breaking tests. </para>
				</listitem>
				<listitem>
					<para>Like many integration tests using a database, most of the
					tests in <classname>AbstractClinicTests</classname> depend on a minimum
					amount of data already in the database before the test cases run.
					You might, however, choose to populate the database in your test
					cases also - again, within the one transaction.</para>
				</listitem>
			</itemizedlist>
			<para>The PetClinic application supports four data access
			technologies - JDBC, Hibernate, TopLink, and JPA. Thus the
			<classname>AbstractClinicTests</classname> class does not itself specify the
			context locations - this is deferred to subclasses,
			that implement the necessary protected abstract method from
			<classname>AbstractDependencyInjectionSpringContextTests</classname>.</para>
			<para>For example, the Hibernate implementation of the PetClinic tests
			contains the following implementation:</para>
			<programlisting><![CDATA[public final class HibernateClinicTests extends AbstractClinicTests {

   protected String[] getConfigLocations() {
      return new String[] { 
         "/org/springframework/samples/petclinic/hibernate/applicationContext-hibernate.xml" 
      };
   }
}]]></programlisting>
			<para>As the PetClinic is a very simple application, there is only one
			Spring configuration file. Of course, more complex applications will
			typically break their Spring configuration across multiple files.
			Instead of being defined in a leaf class, config locations will
			often be specified in a common base class for all application-specific
			integration tests. This may also add useful instance
			variables - populated by Dependency Injection, naturally - such as a
			<classname>HibernateTemplate</classname>, in the case of an application
			using Hibernate.</para>
			<para>As far as possible, you should have exactly the same Spring
			configuration files in your integration tests as in the deployed
			environment. One likely point of difference concerns database connection
			pooling and transaction infrastructure. If you are deploying to a
			full-blown application server, you will probably use its connection pool
			(available through JNDI) and JTA implementation. Thus in production you
			will use a <classname>JndiObjectFactoryBean</classname> for the
			<classname>DataSource</classname>, and <classname>JtaTransactionManager</classname>.
			JNDI and JTA will not be available in out-of-container integration
			tests, so you should use a combination like the Commons DBCP
			<classname>BasicDataSource</classname> and <classname>DataSourceTransactionManager</classname>
			or <classname>HibernateTransactionManager</classname> for them. You can
			factor out this variant behavior into a single XML file, having the
			choice between application server and 'local' configuration
			separated from all other configuration, which will not vary between the
			test and production environments.</para>
		</section>
	</section>
	<section id="testing-resources">
		<title>Further Resources</title>
        <para>This section contains links to further resources about testing in general.</para>
		<itemizedlist>
			<listitem>
				<para>The <ulink url="http://www.junit.org/index.htm">JUnit homepage</ulink>.
				The Spring Framework's unit test suite is written using JUnit as the testing
				framework.</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://www.easymock.org/">EasyMock homepage</ulink>.
				The Spring Framework uses EasyMock extensively in it's test suite.</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://www.jmock.org/">JMock homepage</ulink>.</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://dbunit.sourceforge.net/">DbUnit homepage</ulink>.</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://grinder.sourceforge.net/">Grinder homepage</ulink> (load testing framework).</para>
			</listitem>
		</itemizedlist>
	</section>
</chapter>