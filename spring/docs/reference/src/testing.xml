<?xml version="1.0" encoding="UTF-8"?>
<chapter id="testing">
  <title>Testing</title>

  <sect1 id="unit-testing">
    <title>Unit testing</title>

    <para>You don&#39;t need this manual to help you write effective unit
    tests for Spring-based applications.</para>

    <para>One of the main benefits of Dependency Injection is that your code
    should depend far less on the container than in traditional J2EE
    development.</para>

    <para>The POJOs that comprise your application should be testable in JUnit
    tests, with objects simply instantiated using the new operator,
    <emphasis>without Spring or any other container</emphasis>. You can use
    mock objects or many other valuable testing techniques, to test your code
    in isolation. If you follow the architecture recommendations around
    Spring--for example, those in <emphasis>J2EE without EJB</emphasis>--you
    will find that the resulting clean layering will also greatly facilitate
    testing. For example, you will be able to test service layer objects by
    stubbing or mocking DAO interfaces, without any need to access persistent
    data while running unit tests.</para>

    <para>True unit tests will run extremely quickly, as there is no runtime
    infrastructure to set up, whether application server, database, ORM tool
    etc. Thus emphasizing true unit tests will boost your productivity.</para>
  </sect1>

  <sect1 id="integration-testing">
    <title>Integration testing</title>

    <para>However, it&#39;s also important to be able to perform some
    integration testing without deployment to your application server. This
    will test things such as:</para>

    <itemizedlist>
      <listitem>
        <para>Correct wiring of your Spring contexts.</para>
      </listitem>

      <listitem>
        <para>Data access using JDBC or ORM tool--correctness of SQL
        statements. For example, you can test your DAO implementation classes.</para>
      </listitem>
    </itemizedlist>

    <para>Thus Spring provides valuable support for integration testing, in
    the <literal>spring-mock.jar.</literal> This can be thought of as a
    significantly superior alternative to in-container testing using tools
    such as Cactus. </para>

    <para>The <literal>org.springframework.test </literal>package provides
    valuable superclasses for integration tests using a Spring container, but
    not dependent on an application server or other deployed environment. Such
    tests can run in JUnit--even in an IDE--without any special deployment
    step. They will be slower to run than unit tests, but much faster to run
    than Cactus tests or remote tests relying on deployment to an application
    server.</para>

    <para>The superclasses in this package provide the following
    functionality:</para>

    <itemizedlist>
      <listitem>
        <para>Context caching.</para>
      </listitem>

      <listitem>
        <para>Dependency Injection for test classes.</para>
      </listitem>

      <listitem>
        <para>Transaction management appropriate to tests.</para>
      </listitem>

      <listitem>
        <para>Inherited instance variables useful for testing.</para>
      </listitem>
    </itemizedlist>

    <para>Numerous Interface21 and other projects since late 2004 have
    demonstrated the power and utility of this approach. Let&#39;s look at
    some of the important areas of functionality in detail.</para>

    <sect2>
      <title>Context management and caching</title>

      <para>The <literal>org.springframework.test</literal> package provides
      support for consistent loading of Spring contexts, and caching of loaded
      contexts. The latter is important, because if you are working on a large
      project startup time may become an issue--not because of the overhead of
      Spring itself, but because the objects instantiated by the Spring
      container will themselves take time to instantiate. For example, a
      project with 50-100 Hibernate mapping files might take 10-20 seconds to
      load them, and incurring that cost before running every test case will
      greatly reduce productivity.</para>

      <para>Thus, <literal>AbstractDependencyInjectionSpringContextTests</literal>
      has an abstract protected method that subclasses must implement, to
      provide the location of contexts:</para>

      <para><programlisting>protected abstract String[] getConfigLocations();</programlisting></para>

      <para>This should provide a list of the context locations--typically on
      the classpath--used to configure the application. This will be the same,
      or nearly the same, as the list of config locations specified in web.xml
      or other deployment configuration.</para>

      <para>By default, once loaded, the set of configs will be reused for
      each test case. Thus the setup cost will be incurred only once, and
      subsequent test execution will be much faster.</para>

      <para>In the unlikely case that a test may &#34;dirty&#34; the config
      location, requiring reloading--for example, by changing a bean
      definition or the state of an application object--you can call the
      <literal>setDirty()</literal> method on <literal>AbstractDependencyInjectionSpringContextTests</literal>
      to cause it to reload the configurations and rebuild the application
      context before executing the next test case.</para>
    </sect2>

    <sect2>
      <title>Dependency Injection of test class instances</title>

      <para>When <literal>AbstractDependencyInjectionSpringContextTests</literal>
      (and subclasses) load your application context, they can optionally
      configure instances of yourr test classes by Setter Injection. All you
      need to do is to define instance variables and the corresponding
      setters. <literal>AbstractDependencyInjectionSpringContextTests</literal>
      will automatically locate the corresponding object in the set of
      configuration files specified in the<literal> getConfigLocations()
      </literal>method. </para>

      <para>The superclasses use <emphasis>autowire by type</emphasis>. Thus
      if you have multiple bean definitions of the same type, you cannot rely
      on this approach for those particular beans. In that case, you can use
      the inherited <literal>applicationContext</literal> instance variable,
      and explicit lookup using <literal>getBean()</literal>.</para>

      <para>If you don&#39;t want Setter Injection applied to your test cases,
      don&#39;t declare any setters. Or extend <literal>AbstractSpringContextTests</literal>--the
      root of the class hierarchy in the <literal>org.springframework.test</literal>
      package. It merely contains convenience methods to load Spring contexts,
      and performs no Dependency Injection.</para>
    </sect2>

    <sect2>
      <title>Transaction management</title>

      <para>One common problem in tests that access a real database is their
      effect on the state of the persistence store. Even when you&#39;re using
      a development database, changes to the state may affect future tests.</para>

      <para>Also, many operations--such as inserting to or modifying
      persistence data--can&#39;t be done (or verified) outside a transaction.</para>

      <para>The <literal>org.springframework.test.AbstractTransactionalDataSourceSpringContextTests</literal>
      superclass (and subclasses) exist to meet this need. By default, they
      create and roll back a transaction for each test case. You simply write
      code that can assume the existence of a transaction. If you call
      transactionally proxied objects in your tests, they will behave
      correctly, according to their transactional semantics.</para>

      <para><literal>AbstractTransactionalSpringContextTests</literal> depends
      on a <literal>PlatformTransactionManager</literal> bean being defined in
      the application context. The name doesn&#39;t matter, due to the use of
      autowire by type.</para>

      <para>Typically you will extend the subclass, <literal>AbstractTransactionalDataSourceSpringContextTests</literal>.
      This also requires a <literal>DataSource</literal> bean
      definition--again, with any name--is present in the configurations. It
      creates a <literal>JdbcTemplate</literal> instance variable that is
      useful for convenient querying, and provides handy methods to delete the
      contents of selected tables. (Remember that the transaction will roll
      back by default, so this is safe.)</para>

      <para>If you want a transaction to commit--unusual, but useful if you
      want a particular test to populate the database, for example--you can
      call the <literal>setComplete()</literal> method inherited from
      <literal>AbstractTransactionalSpringContextTests</literal>. This will
      cause the transaction to commit instead of roll back.</para>

      <para>There is also convenient ability to end a transaction before the
      test case ends, through calling the <literal>endTransaction() </literal>method.
      This will roll back the transaction by default, and commit it only if
      <literal>setComplete() </literal>had previously been called. This
      functionality is useful if you want to test the behaviour of
      &#34;disconnected&#34; data objects, such as Hibernate-mapped objects
      that will be used in a web or remoting tier outside a transaction.
      Often, lazy loading errors are discovered only through UI testing; if
      you call <literal>endTransaction()</literal> you can ensure correct
      operation of the UI through your JUnit test suite.</para>

      <para><remark>Note that these test support classes are designed to work
      with a single database.</remark></para>
    </sect2>

    <sect2>
      <title>Convenience variables</title>

      <para>When you extend org.springframework.test package you will have
      access to the following protected instance variables:</para>

      <itemizedlist>
        <listitem>
          <para><literal>applicationContext</literal> (<literal>ConfigurableApplicationContext</literal>):
          inherited from AbstractDependencyInjectionSpringContextTests. Use
          this to perfom explicit bean lookup, or test the state of the
          context as a whole.</para>
        </listitem>

        <listitem>
          <para><literal>jdbcTemplate</literal>: inherited from
          <literal>AbstractTransactionalDataSourceSpringContextTests</literal>.
          Useful for querying to confirm state. For example, you might query
          before and after testing application code that creates an object and
          persists it using an ORM tool, to verify that the data appears in
          the database. (Spring will ensure that the query runs in the scope
          of the same transaction.) You will need to tell your ORM tool to
          &#34;flush&#34; its changes for this to work correctly, for example
          using the <literal>flush() </literal>method on Hibernate&#39;s
          <literal>Session</literal> interface.</para>
        </listitem>
      </itemizedlist>

      <para>Often you will provide an application-wide superclass for
      integration tests that provides further useful instance variables used
      in many tests.</para>
    </sect2>

    <sect2>
      <title>Example</title>

      <para>The PetClinic sample application included with the Spring
      distribution illustrates the use of these test superclasses (Spring
      1.1.5 and above).</para>

      <para>Most test functionality is included in <literal>AbstractClinicTests</literal>,
      for which a partial listing is shown belong:</para>

      <para><programlisting>public abstract class AbstractClinicTests extends AbstractTransactionalDataSourceSpringContextTests {

   protected Clinic clinic;

   public void setClinic(Clinic clinic) {
      this.clinic = clinic;
   }

   public void testGetVets() {
      Collection vets = this.clinic.getVets();
      assertEquals(&#34;JDBC query must show the same number of vets&#34;,
         jdbcTemplate.queryForInt(&#34;SELECT COUNT(0) FROM VETS&#34;), 
         vets.size());
      Vet v1 = (Vet) EntityUtils.getById(vets, Vet.class, 2);
      assertEquals(&#34;Leary&#34;, v1.getLastName());
      assertEquals(1, v1.getNrOfSpecialties());
      assertEquals(&#34;radiology&#34;, ((Specialty) v1.getSpecialties().get(0)).getName());
      Vet v2 = (Vet) EntityUtils.getById(vets, Vet.class, 3);
      assertEquals(&#34;Douglas&#34;, v2.getLastName());
      assertEquals(2, v2.getNrOfSpecialties());
      assertEquals(&#34;dentistry&#34;, ((Specialty) v2.getSpecialties().get(0)).getName());
      assertEquals(&#34;surgery&#34;, ((Specialty) v2.getSpecialties().get(1)).getName());
}</programlisting></para>

      <para>Notes:</para>

      <itemizedlist>
        <listitem>
          <para>This test case extends <literal>org.springframework.AbstractTransactionalDataSourceSpringContextTests</literal>,
          from which it inherits Dependency Injection and transactional
          behaviour.</para>
        </listitem>

        <listitem>
          <para>The <literal>clinic</literal> instance variable--the
          application object being tested--is set by Dependency Injection
          through the setClinic() method.</para>
        </listitem>

        <listitem>
          <para>The testGetVets() method illustrates how the inherited
          <literal>JdbcTemplate</literal> variable can be used to verify
          correct behaviour of the application code being tested. This allows
          for stronger tests, and lessens dependency on the exact test data.
          For example, you can add additional rows in the database without
          breaking tests.</para>
        </listitem>

        <listitem>
          <para>Like many integration tests using a database, most of the
          tests in <literal>AbstractClinicTests</literal> depend on a minimum
          amount of data already in the database before the test cases run.
          You might, however, choose to populate the database in your test
          cases also--again, within the one transaction.</para>
        </listitem>
      </itemizedlist>

      <para>The PetClinic application supports three data access
      technologies--JDBC, Hibernate and Apache OJB. Thus <literal>AbstractClinicTests</literal>
      does not specify the context locations--this is deferred to subclasses,
      that implement the necessary protected abstract method from
      <literal>AbstractDependencyInjectionSpringContextTests</literal>.</para>

      <para>For example, the JDBC implementation of the PetClinic tests
      contains the following method:</para>

      <programlisting>public class HibernateClinicTests extends AbstractClinicTests {

   protected String[] getConfigLocations() {
      return new String[] { 
         &#34;/org/springframework/samples/petclinic/hibernate/applicationContext-hibernate.xml&#34; 
      };
   }
}</programlisting>

      <para>As the PetClinic is a very simple application, there is only one
      Spring configuration file. Of course, more complex applications will
      typically break their Spring configuration across multiple files.</para>

      <para>Instead of being defined in a leaf class, config locations will
      often be specified in a common base class for all application-specific
      integration tests. This may also add useful instance
      variables--populated by Dependency Injection, naturally--such as a
      <literal>HibernateTemplate</literal>, in the case of an application
      using Hibernate.</para>

      <para>As far as possible, you should have exactly the same Spring
      configuration files in your integration tests as in the deployed
      environment. One likely point of difference concerns database connection
      pooling and transaction infrastructure. If you are deploying to a
      full-blown application server, you will probably use its connection pool
      (available through JNDI) and JTA implementation. Thus in production you
      will use a <literal>JndiObjectFactoryBean</literal> for the
      <literal>DataSource</literal>, and <literal>JtaTransactionManager</literal>.
      JNDI and JTA will not be available in out-of-container integration
      tests, so you should use a combination like the Commons DBCP
      <literal>BasicDataSource</literal> and <literal>DataSourceTransactionManager</literal>
      or <literal>HibernateTransactionManager</literal> for them. You can
      factor out this variant behaviour into a single XML file, having the
      choice between application server and &#34;local&#34; configuration
      separated from all other configuration, which will not vary between the
      test and production environments.</para>
    </sect2>

    <sect2>
      <title>Running integration tests</title>

      <para>Integration tests naturally have more environmental dependencies
      than plain unit tests. Such integration testing is an additional form of
      testing, not a substitute for unit testing.</para>

      <para>The main dependency will typically be on a development database
      containing a complete schema used by the application. This may also
      contain test data, set up by a a tool such as a DBUnit, or an import
      using your database&#39;s tool set.</para>
    </sect2>
  </sect1>
</chapter>