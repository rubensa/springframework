<?xml version="1.0" encoding="UTF-8"?>
<chapter id="transaction">
  <title>Transaction management</title>

  <sect1>
    <title>The Spring transaction abstraction</title>

    <para>Spring provides a consistent abstraction for transaction management.
    This abstraction is one of the most important of Spring&#39;s
    abstractiions, and delivers the following benefits:<itemizedlist><listitem><para>Provides
    a consistent programming model across different transaction APIs such as
    JTA, JDBC, Hibernate, iBATIS Database Layer and JDO.</para></listitem><listitem><para>Provides
    a simpler, easier to use, API for programmatic transaction management than
    most of these transaction APIs</para></listitem><listitem><para>Integrates
    with the Spring data access abstraction</para></listitem><listitem><para>Supports
    Spring declarative transaction management</para></listitem></itemizedlist></para>

    <para>Traditionally, J2EE developers have had two choices for transaction
    management: to use <emphasis>global</emphasis> or <emphasis>local</emphasis>
    transactions. Global transactions are managed by the application server,
    using JTA. Local transactions are resource-specific: for example, a
    transaction associated with a JDBC connection. This choice had profound
    implications. Global transactions provide the ability to work with
    multiple transactional resources. With local transactions, the application
    server is not involved in transaction management, and cannot help ensure
    correctness across multiple resources.</para>

    <para>Global transactions have a significant downside. Code needs to use
    JTA: a cumbersome API to use (partly due to its exception model).
    Furthermore, a JTA <literal>UserTransaction</literal> normally needs to be
    obtained from JNDI: meaning that we need to use <emphasis>both</emphasis>
    JNDI and JTA to use JTA. Obviously all use of global transactions limits
    the reusability of application code, as JTA is normally only available in
    an application server environment.</para>

    <para>The preferred way to use global transactions was via EJB
    <emphasis>CMT</emphasis> (<emphasis>Container Managed Transaction</emphasis>):
    a form of <emphasis role="bold">declarative transaction management</emphasis>
    (as distinguished from <emphasis role="bold">programmatic transaction
    management</emphasis>). EJB CMT removes the need for JNDI lookups. It
    removes most--not all--need to write Java code to control transactions.
    The significant downside is that CMT is (obviously) tied to JTA and an
    application server environment; and that it&#39;s only available if we
    choose to implement business logic in EJBs, or at least behind a
    transactional EJB facade. The negatives around EJB are so great that this
    is not an attractive proposition, when there are alternatives for
    declarative transaction management.</para>

    <para>Local transactions may be easier to use, but also have significant
    disadvantages: they cannot work across multiple transactional resources,
    and tend to invade the programming model. For example, code that manages
    transactions using a JDBC connection cannot run within a global JTA
    transaction.</para>

    <para>Spring resolves these problems. It enables application developers to
    use a consistent programming model <emphasis>in any environment</emphasis>.
    You write your code once, and it can benefit from different transaction
    management strategies in different environments. Spring provides both
    declarative and programmatic transaction management, although declarative
    transaction management is preferred by most users, and recommended in most
    cases.</para>

    <para>With programmatic transaction management developers work with the
    Spring transaction abstraction, which can run over any underlying
    transaction infrastructure. With the preferred, declarative, model,
    developers typically write little or no code related to transaction
    management, and hence don&#39;t depend on Spring&#39;s or any other
    transaction API.</para>
  </sect1>

  <sect1>
    <title>Transaction strategies</title>

    <para>The key to the Spring transaction abstraction is the notion of a
    <emphasis>transaction strategy</emphasis>.</para>

    <para>This is captured in the <literal>org.springframework.transaction.PlatformTransactionManager</literal>
    interface, shown below:</para>

    <para><programlisting>public interface PlatformTransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition)
        throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}</programlisting></para>

    <para>This is primarily an SPI interface, although it can be used
    programmatically. Note that in keeping with Spring&#39;s philosophy, this
    is an <emphasis>interface</emphasis>. Thus it can easily be mocked or
    stubbed if necessary. It is also not tied to a lookup strategy such as
    JNDI: PlatformTransactionManager implementations are defined like any
    other object in a Spring IoC container. This benefit alone makes this a
    worthwhile abstraction even when working with JTA: transactional code can
    be tested much more easily than if it directly used JTA.</para>

    <para>In keeping with Spring&#39;s philosophy, <literal>TransactionException</literal>
    is unchecked. Failures of the transaction infrastructure are almost
    invariably fatal. In rare cases where application code can recover from
    them, the application developer can still choose to catch and handle
    TransactionException.</para>

    <para>The getTransaction() method returns a TransactionStatus object,
    depending on a TransactionDefinition parameter. The returned
    TransactionStatus might represent a new or existing transaction (if there
    was a matching transaction in the current call stack).</para>

    <para>As with J2EE transaction contexts, a TransactionStatus is associated
    with a thread of execution.</para>

    <para>The TransactionDefinition interface specifies:</para>

    <itemizedlist>
      <listitem>
        <para>Transaction isolation:</para>
      </listitem>

      <listitem>
        <para>Transaction propagation:</para>
      </listitem>

      <listitem>
        <para>Transaction timeout:</para>
      </listitem>

      <listitem>
        <para>Read-only status:</para>
      </listitem>
    </itemizedlist>

    <para>The TransactionStatus interface provides a simple way for
    transactional code to control transaction execution and query transaction
    status. The concepts should be familiar, as they are common to all
    transaction APIs:</para>

    <para><programlisting>public interface TransactionStatus {

    boolean isNewTransaction();

    void setRollbackOnly();

    boolean isRollbackOnly();
}</programlisting></para>

    <para>er</para>

    <para>Defining platform transaction managers: HEADING</para>

    <para>er</para>

    <para>dataAccessContext-local.xml from jPetStore</para>

    <para><programlisting>&#60;bean id=&#34;dataSource&#34; 
    class=&#34;org.apache.commons.dbcp.BasicDataSource&#34; destroy-method=&#34;close&#34;&#62;
    &#60;property name=&#34;driverClassName&#34;&#62;&#60;value&#62;${jdbc.driverClassName}&#60;/value&#62;&#60;/property&#62;
    &#60;property name=&#34;url&#34;&#62;&#60;value&#62;${jdbc.url}&#60;/value&#62;&#60;/property&#62;
    &#60;property name=&#34;username&#34;&#62;&#60;value&#62;${jdbc.username}&#60;/value&#62;&#60;/property&#62;
    &#60;property name=&#34;password&#34;&#62;&#60;value&#62;${jdbc.password}&#60;/value&#62;&#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

    <para>er</para>

    <para><programlisting>&#60;bean id=&#34;transactionManager&#34; 
    class=&#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&#34;&#62;
    &#60;property name=&#34;dataSource&#34;&#62;&#60;ref local=&#34;dataSource&#34;/&#62;&#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

    <para>with JTA, dataAccessContext-jta.xml:</para>

    <para><programlisting>&#60;bean id=&#34;dataSource&#34; class=&#34;org.springframework.jndi.JndiObjectFactoryBean&#34;&#62;
    &#60;property name=&#34;jndiName&#34;&#62;&#60;value&#62;jdbc/jpetstore&#60;/value&#62;&#60;/property&#62;
&#60;/bean&#62;</programlisting></para>

    <para>er</para>

    <para><programlisting>&#60;bean id=&#34;transactionManager&#34; 
    class=&#34;org.springframework.transaction.jta.JtaTransactionManager&#34;/&#62;</programlisting></para>

    <para>er</para>

    <para>show Hibernate also from PetClinic</para>

    <para></para>

    <para>How are resources associated with a transaction? HEADING 2</para>

    <para>DataSourceUtils formula, same for Hibernate</para>

    <para>Of course, once you&#39;ve used Spring&#39;s JDBC support or
    Hibernate support you won&#39;t want to use DataSourceUtils or the other
    helper classes, because you&#39;ll be much happier working via the Spring
    abstraction than directly with the relevant APIs.</para>
  </sect1>

  <sect1>
    <title>Programmatic transaction management</title>

    <para>Spring provides two means of programmatic transaction management:</para>

    <itemizedlist>
      <listitem>
        <para>Using the <literal>TransactionTemplate</literal></para>
      </listitem>

      <listitem>
        <para>Using a <literal>PlatformTransactionManager</literal>
        implementation directly</para>
      </listitem>
    </itemizedlist>

    <para>The first approach is recommended, so we&#39;ll focus on it here.</para>

    <para>The second approach is similar to using the JTA <literal>UserTransaction</literal>
    API.</para>

    <para>The TransactionTemplate adopts the same approach as other Spring
    <emphasis>templates</emphasis> such as JdbcTemplate and HibernateTemplate.
    It uses a callback approach. Like other templates, a TransactionTemplate
    is threadsafe.</para>

    <para>Application code that must execute in a transaction context uses</para>

    <para><programlisting>Object result = tt.execute(new TransactionCallback() {
    public Object doInTransaction(TransactionStatus status) {
        updateOperation1();
        return resultOfUpdateOperation2();
    }
});</programlisting></para>

    <para>er</para>

    <para><programlisting>tt.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});</programlisting></para>

    <para>er</para>

    <para></para>

    <para>er</para>
  </sect1>

  <sect1>
    <title>Declarative transaction management</title>

    <para>Spring also offers declarative transaction management. This is
    enabled by Spring AOP.</para>

    <remark>Most Spring users choose declarative transaction management. It is
    the option with least impact on application code, and hence is most
    consistent with the ideals of a non-invasive lightweight container.</remark>

    <para>It may be helpful to begin by considering EJB CMT and explaining the
    similarities and differences with Spring declarative transaction
    management. The basic approach is similar: it&#39;s possible to specify
    transaction behaviour (or lack of it) down to individual methods. It&#39;s
    possible to make a setRollbackOnly() call within a transaction context if
    necessary. The differences are:</para>

    <itemizedlist>
      <listitem>
        <para>Unlike EJB CMT, which is tied to JTA, Spring declarative
        transaction management works in any environment. It can work with
        JDBC, JDO, Hibernate or other transactions under the covers, with
        configuration changes only.</para>
      </listitem>

      <listitem>
        <para>Spring enables declarative transaction mangement to be applied
        to any POJO, not just special classes such as EJBs.</para>
      </listitem>

      <listitem>
        <para>Spring offers declarative <emphasis>rollback rules</emphasis>: a
        feature with no EJB equivalent, which we&#39;ll discuss below.</para>
      </listitem>

      <listitem>
        <para></para>
      </listitem>

      <listitem>
        <para>Spring does not support propagation of transaction contexts
        across remote calls, as do high-end application servers. If you need
        this feature, we recommend that you use EJB. However, don&#39;t use
        this feature lightly. Normally we don&#39;t want transactions to span
        remote calls.</para>
      </listitem>
    </itemizedlist>

    <para>RR HEADING</para>

    <para>While the EJB default behaviour is the for the EJB container to
    automatically roll back the transaction on a <emphasis>system exception</emphasis>
    (usually a runtime exception), EJB CMT does not roll back the transaction
    automatically on an <emphasis>application exception</emphasis> (checked
    exception other than <literal>java.rmi.RemoteException</literal>).</para>

    <para>The performance of Spring declarative transaction management exceeds
    that of EJB CMT, in benchmarks we have run.</para>

    <para>ConFIGURATION</para>

    <para>AUTOPROXYING</para>
  </sect1>

  <sect1>
    <title>Choosing between programmatic and declarative transaction
    management</title>

    <para>Why would you choose?</para>

    <para>Programmatic transaction management is usually a good idea only if
    you have a small number of transaction operations</para>
  </sect1>

  <sect1>
    <title>Do you need an application server for transaction management?</title>

    <para>Spring&#39;s transaction management capabilities--and especially its
    declarative transaction management--significantly changes traditional
    thinking as to when a J2EE application requires an application server.</para>

    <para>In particular, you don&#39;t need an application server just to have
    declarative transactions via EJB. In fact, even if you have an application
    server with powerful JTA capabilities, you may well decide that Spring
    declarative transactions offer more power and a much more productive
    programming model than EJB CMT.</para>

    <para>You need an application server&#39;s JTA capability only if you need
    to enlist multiple transactional resources. Many applications don&#39;t
    face this requirement. For example, many high-end applications use a
    single, highly scalable, database such as Oracle 9i RAC.</para>

    <para>Of course you may need other application server capabilities such as
    JMS and JCA. However, if you need only JTA, you could also consider an
    open source JTA add-on such as JOTM. (Spring integrates with JOTM out of
    the box.) However, as of early 2004, high-end application servers provide
    more robust support for XA transactions.</para>

    <para>The most important point is that with Spring <emphasis>you can
    choose when to scale your application up to a full-blown application
    server</emphasis>. Gone are the days when the only alternative to using
    EJB CMT or JTA was to write coding using local transactions such as those
    on JDBC connections, and face a hefty rework if you ever needed that code
    to run within global, container-managed transactions. With Spring only
    configuration needs to change: your code doesn&#39;t.</para>
  </sect1>

  <sect1>
    <title>Common problems</title>

    <para>Developers should take care to use the correct
    PlatformTransactionManager for their requirements.</para>

    <para>It&#39;s important to understand how the Spring transaction
    abstraction works with JTA global transactions. Used properly, there is no
    conflict here: Spring merely provides a simplifying, portable abstraction.</para>

    <para>If you are using global transactions, you <emphasis>must</emphasis>
    use the Spring <literal>org.springframework.transaction.jta.JtaTransactionManager</literal>
    for all your for all your transactional operations. Otherwise Spring will
    attempt to perform local transactions on resources such as container
    DataSources. Such local transactions don&#39;t make sense, and a good
    application server will treat them as errors. <literal></literal></para>
  </sect1>
</chapter>