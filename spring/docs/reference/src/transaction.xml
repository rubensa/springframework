<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="transaction">
    <title>Transaction management</title>
    <section>
        <title>Introduction</title>
        <para>One of the most compelling reasons to use Spring is the transaction support.
        Spring provides a consistent abstraction for transaction management that delivers
        the following benefits:</para>
        <itemizedlist>
            <listitem>
                <para>Provides a consistent programming model across different
                transaction APIs such as JTA, JDBC, Hibernate, JPA, and JDO.</para>
            </listitem>
            <listitem>
                <para>Supports declarative transaction management.</para>
            </listitem>
            <listitem>
                <para>Provides a simpler, easier to use, API for programmatic
                transaction management than a number of disparate transaction APIs such as JTA.</para>
            </listitem>
            <listitem>
                <para>Integrates with Spring's various data access abstractions.</para>
            </listitem>
        </itemizedlist>
        <para>This chapter is divided up into a number of sections; these sections are
        described below, along with a link so that you can navigate directly to the
        section which interests you.</para>
        <itemizedlist>
            <listitem>
                <para>The first section, entitled
                <link linkend="transaction-motivation">Motivations</link>,
                describes <emphasis>why</emphasis> one would want to use
                Spring's transaction abstraction as opposed to EJB CMT
                or driving transactions via a proprietary API such
                as Hibernate.</para>
            </listitem>
            <listitem>
                <para>The second section, entitled
                <link linkend="transaction-strategies">Key abstractions</link>
                outlines the core classes in Spring's transaction support, as well
                as how to configure and obtain <interfacename>DataSource</interfacename>
                instances from a variety of sources.</para>
            </listitem>
            <listitem>
                <para>The third section, entitled
                <link linkend="transaction-declarative">Declarative transaction management</link>
                covers, Spring's support for declarative transaction
                management.</para>
            </listitem>
            <listitem>
                <para>The fourth section, entitled
                <link linkend="transaction-programmatic">Programmatic transaction management</link>
                covers, Spring's support for programmatic (i.e. explicitly
                coded) transaction management.</para>
            </listitem>
        </itemizedlist>
        <para>The chapter closes up with some discussion of best practices
        surrounding transaction management (for example, choosing between
        declarative and programmatic transaction management).</para>
    </section>
    <section id="transaction-motivation">
        <title>Motivations</title>
        <sidebar>
            <title>Is an application server needed for transaction management?</title>
            <para>Spring's transaction management support significantly changes
            traditional thinking as to when a J2EE application requires an application
            server.</para>
            <para>In particular, you don't need an application server just to have
            declarative transactions via EJB. In fact, even if you have an application
            server with powerful JTA capabilities, you may well decide that Spring's
            declarative transactions offer more power and a much more productive
            programming model than EJB CMT.</para>
            <para>You need an application server's JTA capability only if you need to
            enlist multiple transactional resources, and for many applications being able
            to handle transactions across multiple resources isn't a requirement. 
            For example, many high-end applications use a single, highly scalable 
            database (such as Oracle 9i RAC).</para>
            <para>Of course you may need other application server capabilities such as
            JMS and JCA.</para>
            <para>The most important point is that with Spring <emphasis>you can
            choose when to scale your application up to a full-blown application
            server</emphasis>. Gone are the days when the only alternative to using
            EJB CMT or JTA was to write code using local transactions such as those
            on JDBC connections, and face a hefty rework if you ever needed that code
            to run within global, container-managed transactions. With Spring, only
            configuration needs to change so that your code doesn't have to.</para>
        </sidebar>
        <para>Traditionally, J2EE developers have had two choices for transaction
        management: <emphasis>global</emphasis> or <emphasis>local</emphasis> transactions.
        Global transactions are managed by the application server, using the Java Transaction 
        API (JTA). Local transactions are resource-specific: the most common example would
        be a transaction associated with a JDBC connection. This choice has profound
        implications. For instance, global transactions provide the ability to work with multiple
        transactional resources (typically relational databases and message queues).
        With local transactions, the application server is not involved in
        transaction management and cannot help ensure correctness across multiple
        resources. (It is worth noting that most applications use a single transaction
        resource.)</para>
        <formalpara>
            <title>Global Transactions</title>
            <para>Global transactions have a significant downside, in that code needs
            to use JTA, and JTA is a cumbersome API to use (partly due to its exception
            model). Furthermore, a JTA <interfacename>UserTransaction</interfacename>
            normally needs to be sourced from JNDI: meaning that we need to use
            <emphasis>both</emphasis> JNDI <emphasis>and</emphasis> JTA to use JTA.
            Obviously all use of global transactions limits the reusability of application
            code, as JTA is normally only available in an application server environment. </para>
            <para> Previously, the preferred way to use global transactions was via EJB
            <emphasis>CMT</emphasis> (<emphasis>Container Managed Transaction</emphasis>):
            CMT is a form of <emphasis role="bold">declarative transaction management</emphasis>
            (as distinguished from <emphasis role="bold">programmatic transaction management</emphasis>).
            EJB CMT removes the need for transaction-related JNDI lookups - although of course
            the use of EJB itself necessitates the use of JNDI. It removes most of the need (although
            not entirely) to write Java code to control transactions. The significant
            downside is that CMT is tied to JTA and an application server
            environment. Also, it is only available if one chooses to implement
            business logic in EJBs, or at least behind a transactional EJB facade. The
            negatives around EJB in general are so great that this is not an
            attractive proposition, especially in the face of compelling alternatives for
            declarative transaction management.</para>
        </formalpara>
        <formalpara>
            <title>Local Transactions</title>
            <para>Local transactions may be easier to use, but have significant
            disadvantages: they cannot work across multiple transactional resources.
	    For example, code that manages transactions using a JDBC connection cannot 
	    run within a global JTA transaction. Another downside is that local 
	    transactions tend to be invasive of the programming model.</para>
        </formalpara>
        <para>Spring resolves these problems. It enables application developers to
        use a <emphasis>consistent</emphasis> programming model <emphasis>in any
        environment</emphasis>. You write your code once, and it can benefit from
        different transaction management strategies in different environments.
        Spring provides both declarative and programmatic transaction management.
        Declarative transaction management is preferred by most users, and is
        recommended in most cases.</para>
        <para>With programmatic transaction management, developers work with the
        Spring transaction abstraction, which can run over any underlying
        transaction infrastructure. With the preferred declarative model,
        developers typically write little or no code related to transaction
        management, and hence don't depend on Spring's transaction API (or indeed
        on any other transaction API).</para>
    </section>
    <section id="transaction-strategies">
        <title>Key abstractions</title>
        <para>The key to the Spring transaction abstraction is the notion of a
        <emphasis>transaction strategy</emphasis>. A transaction strategy is
        defined by the
        <interfacename>org.springframework.transaction.PlatformTransactionManager</interfacename>
        interface, shown below:</para>
        <programlisting><![CDATA[public interface PlatformTransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition)
        throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}]]></programlisting>
        <para>This is primarily an SPI interface, although it can be used
        <link linkend="transaction-programmatic-ptm">programmatically</link>.
        Note that in keeping with Spring's philosophy, 
        <interfacename>PlatformTransactionManager</interfacename> is
        an <emphasis>interface</emphasis>, and can thus be easily mocked or stubbed
        as necessary. Nor is it tied to a lookup strategy such as JNDI:
        <interfacename>PlatformTransactionManager</interfacename> implementations
        are defined like any other object (or bean) in a Spring IoC container.
        This benefit alone makes it a worthwhile abstraction even when working
        with JTA: transactional code can be tested much more easily than if it
        used JTA directly.</para>
        <para>Again in keeping with Spring's philosophy, the <classname>TransactionException</classname>
        that can be thrown by any of the <interfacename>PlatformTransactionManager</interfacename>
        interface's methods is <emphasis>unchecked</emphasis> (i.e. it extends the
        <classname>java.lang.RuntimeException</classname> class). Transaction infrastructure
        failures are almost invariably fatal. In rare cases where application code can actually
        recover from a transaction failure, the application developer can still choose to catch
        and handle <classname>TransactionException</classname>. The salient point is
        that developers are not <emphasis>forced</emphasis> to do so.</para>
        <para>The <literal>getTransaction()</literal>method returns a
        <interfacename>TransactionStatus</interfacename> object, depending on a
        <interfacename>TransactionDefinition</interfacename> parameter. The returned
        <interfacename>TransactionStatus</interfacename> might represent a new or
        existing transaction (if there were a matching transaction in the current
        call stack - with the implication being that (as with J2EE transaction contexts)
        a <interfacename>TransactionStatus</interfacename> is associated with a
        <emphasis role="bold">thread</emphasis> of execution).</para>
        <para>The <interfacename>TransactionDefinition</interfacename> interface
        specifies:</para>
        <itemizedlist>
            <listitem>
                <para><emphasis role="bold">Isolation</emphasis>: the
                degree of isolation this transaction has from the work of other
                transactions. For example, can this transaction see uncommitted
                writes from other transactions?</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">Propagation</emphasis>:
                normally all code executed within a transaction scope will run in that
                transaction. However, there are several options specifying behavior if
                a transactional method is executed when a transaction context already
                exists: for example, simply running in the existing transaction (the
                most common case); or suspending the existing transaction and creating
                a new transaction. Spring offers all of the transaction propagation
                options familiar from EJB CMT.</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">Timeout</emphasis>: how long
                this transaction may run before timing out (and automatically being
                rolled back by the underlying transaction infrastructure).</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">Read-only status</emphasis>: a read-only
                transaction does not modify any data. Read-only transactions can be a
                useful optimization in some cases (such as when using Hibernate).</para>
            </listitem>
        </itemizedlist>
        <para>These settings reflect standard transactional concepts. If necessary,
        please refer to a resource discussing transaction isolation levels and other
        core transaction concepts: understanding such core concepts is essential to
        using Spring or indeed any other transaction management solution.</para>
        <para>The <interfacename>TransactionStatus</interfacename> interface provides a simple
        way for transactional code to control transaction execution and query
        transaction status. The concepts should be familiar, as they are common to
        all transaction APIs:</para>
        <programlisting><![CDATA[public interface TransactionStatus {

    boolean isNewTransaction();

    void setRollbackOnly();

    boolean isRollbackOnly();
}]]></programlisting>
        <para>Regardless of whether you opt for declarative or programmatic transaction
        management in Spring, defining the correct
        <interfacename>PlatformTransactionManager</interfacename> implementation is
        absolutely essential. In good Spring fashion, this important definition typically
        is made using IoC.</para>
        <para><interfacename>PlatformTransactionManager</interfacename> implementations
        normally require knowledge of the environment in which they work: JDBC, JTA,
        Hibernate, etc The following examples from the
        <literal>dataAccessContext-local.xml</literal> file from Spring's 
        <emphasis role="bold">jPetStore</emphasis> sample application show how a local
        <interfacename>PlatformTransactionManager</interfacename> implementation can be
        defined. (This will work with plain JDBC.)</para>
        <para>We must define a JDBC <interfacename>DataSource</interfacename>, and
        then use the Spring <classname>DataSourceTransactionManager</classname>, giving
        it a reference to the <interfacename>DataSource</interfacename>.</para>
        <programlisting><![CDATA[<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
  <property name="driverClassName" value="${jdbc.driverClassName}" />
  <property name="url" value="${jdbc.url}" />
  <property name="username" value="${jdbc.username}" />
  <property name="password" value="${jdbc.password}" />
</bean>]]></programlisting>
        <para>The related <interfacename>PlatformTransactionManager</interfacename> bean
        definition will look like this:</para>
        <programlisting><![CDATA[<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
  <property name="dataSource" ref="dataSource"/>
</bean>]]></programlisting>
        <para>If we use JTA, as in the <literal>dataAccessContext-jta.xml</literal> file
        from the same sample application, we need to use a container
        <interfacename>DataSource</interfacename>, obtained via JNDI, and a
        <classname>JtaTransactionManager</classname> implementation. The
        <classname>JtaTransactionManager</classname> doesn't need to know about the
        <interfacename>DataSource</interfacename>, or any other specific resources, as
        it will use the  container's global transaction management infrastructure.</para>
        <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jndi="http://www.springframework.org/schema/jndi"
xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd">

  <jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/> 

  <bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />
  
  ]]><lineannotation>&lt;!-- other <literal>&lt;bean/&gt;</literal> definitions here --&gt;</lineannotation><![CDATA[

</beans>]]></programlisting>
        <note>
            <para>The above definition of the <literal>'dataSource'</literal> bean uses the
            <literal>'jndi-lookup'</literal> tag from the <literal>'jee'</literal> namespace.
            For more information on schema-based configuration, see <xref linkend="xsd-config"/>,
            and for more information on the <literal>&lt;jee/&gt;</literal> tags
            see the section entitled <xref linkend="xsd-config-body-schemas-jee"/>.</para>
        </note>
        <para>We can use Hibernate local transactions easily, as shown in the
        following examples from the Spring <emphasis role="bold">PetClinic</emphasis>
        sample application. In this case, we need to define a Hibernate
        <classname>LocalSessionFactoryBean</classname>, which application code will
        use to obtain Hibernate <interfacename>Session</interfacename> instances.</para>
        <para>The <interfacename>DataSource</interfacename> bean definition will be
        similar to one of the above examples, and is not shown. (If it is a container
        <interfacename>DataSource</interfacename>, it should be non-transactional as
        Spring, rather than the container, will manage transactions.)</para>
        <para>The <literal>'txManager'</literal> bean in this case is of class
        <classname>HibernateTransactionManager</classname>. In the same way as the
        <classname>DataSourceTransactionManager</classname> needs a reference to the
        <interfacename>DataSource</interfacename>, the
        <classname>HibernateTransactionManager</classname> needs a reference to the
        <interfacename>SessionFactory</interfacename>.</para>
        <programlisting><![CDATA[<bean id="sessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean">
  <property name="dataSource" ref="dataSource" />
  <property name="mappingResources">
    <list>
      <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
    </list>
  </property>
  <property name="hibernateProperties">
    <value>
	  hibernate.dialect=${hibernate.dialect}
	</value>
  </property>
</bean>

<bean id="txManager" class="org.springframework.orm.hibernate.HibernateTransactionManager">
  <property name="sessionFactory" ref="sessionFactory" />
</bean>]]></programlisting>
        <para>With Hibernate and JTA transactions, we can simply use the
            <classname>JtaTransactionManager</classname> as with JDBC or any other resource strategy.</para>
        <programlisting><![CDATA[<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>]]></programlisting>
        <para>Note that this is identical to JTA configuration for any resource,
            as these are global transactions, which can enlist any transactional
            resource.</para>
        <para>
            <remark>In all these cases, application code won't need to change at
            all. We can change how transactions are managed merely by changing
            configuration, even if that change means moving from local to global
            transactions or vice versa.</remark>
        </para>
    </section>
    <section>
        <title>Resource synchronization with transactions</title>
        <para>It should now be clear how different transaction managers are
        created, and how they are linked to related resources which need to be
        synchronized to transactions (i.e. <classname>DataSourceTransactionManager</classname>
        to a JDBC <interfacename>DataSource</interfacename>,
        <classname>HibernateTransactionManager</classname> to a Hibernate
        <interfacename>SessionFactory</interfacename>, etc). There remains the question
        however of how the application code, directly or indirectly using a
        persistence API (JDBC, Hibernate, JDO, etc), ensures that these resources
        are obtained and handled properly in terms of proper
        creation/reuse/cleanup and trigger (optionally) transaction
        synchronization via the relevant
        <interfacename>PlatformTransactionManager</interfacename>.</para>
        <section>
            <title>High-level approach</title>
            <para>The preferred approach is to use Spring's highest level
            persistence integration APIs. These do not replace the native APIs, but
            internally handle resource creation/reuse, cleanup, optional
            transaction synchronization of the resources and exception mapping so
            that user data access code doesn't have to worry about these concerns at
            all, but can concentrate purely on non-boilerplate persistence logic.
            Generally, the same<emphasis> template</emphasis> approach is used
            for all persistence APIs, with examples such as
            <classname>JdbcTemplate</classname>, <classname>HibernateTemplate</classname>,
            <classname>JdoTemplate</classname>, etc These integration classes are
            detailed in subsequent chapters of this reference documentation.</para>
        </section>
        <section>
            <title>Low-level approach</title>
            <para>At a lower level exist classes such as
            <classname>DataSourceUtils</classname> (for JDBC),
            <classname>SessionFactoryUtils</classname> (for Hibernate),
            <classname>PersistenceManagerFactoryUtils</classname> (for JDO), and so on.
            When it is preferable for application code to deal directly with the
            resource types of the native persistence APIs, these classes ensure that
            proper Spring-managed instances are obtained, transactions are
            (optionally) synchronized, and exceptions which happen in the process
            are properly mapped to a consistent API.</para>
            <para>For example, in the case of JDBC, instead of the traditional JDBC approach of
            calling the <literal>getConnection()</literal> method on the
            <interfacename>DataSource</interfacename>, you would instead use Spring's
            <classname>org.springframework.jdbc.datasource.DataSourceUtils</classname>
            class as follows:</para>
            <programlisting><![CDATA[Connection conn = DataSourceUtils.getConnection(dataSource);]]></programlisting>
            <para>If an existing transaction exists, and already has a connection
            synchronized (linked) to it, that instance will be returned. Otherwise,
            the method call will trigger the creation of a new connection, which
            will be (optionally) synchronized to any existing transaction, and
            made available for subsequent reuse in that same transaction. As mentioned,
            this has the added advantage that any <classname>SQLException</classname>
            will be wrapped in a Spring
            <classname>CannotGetJdbcConnectionException</classname> - one of Spring's
            hierarchy of unchecked DataAccessExceptions. This gives you more
            information than can easily be obtained from the
            <classname>SQLException</classname>, and ensures portability across
            databases: even across different persistence technologies.</para>
            <para>It should be noted that this will also work fine without Spring
            transaction management (transaction synchronization is optional), so you
            can use it whether or not you are using Spring for transaction
            management.</para>
            <para>Of course, once you've used Spring's JDBC support or Hibernate
            support, you will generally prefer not to use
            <classname>DataSourceUtils</classname> or the other helper classes, because
            you'll be much happier working via the Spring abstraction than directly
            with the relevant APIs. For example, if you use the Spring
            <classname>JdbcTemplate</classname> or <literal>jdbc.object</literal>
            package to simplify your use of JDBC, correct connection retrieval happens
            behind the scenes and you won't need to write any special code.</para>
        </section>
        <section>
            <title><classname>TransactionAwareDataSourceProxy</classname></title>
            <para>At the very lowest level exists the
            <classname>TransactionAwareDataSourceProxy</classname> class. This is a
            proxy for a target <interfacename>DataSource</interfacename>, which wraps the
            target <interfacename>DataSource</interfacename> to add awareness of Spring-managed
            transactions. In this respect, it is similar to a transactional JNDI
            <interfacename>DataSource</interfacename> as provided by a J2EE server.</para>
            <para>It should almost never be necessary or desirable to use this
            class, except when existing code exists which must be called and passed
            a standard JDBC <interfacename>DataSource</interfacename> interface implementation.
            In that case, it's possible to still have this code be usable, but
            participating in Spring managed transactions. It is preferable to write
            your new code using the higher level abstractions mentioned
            above.</para>
        </section>
    </section>
    <section id="transaction-declarative">
        <title>Declarative transaction management</title>
        <remark>Most Spring users choose declarative transaction management. It is
        the option with the least impact on application code, and hence is most
        consistent with the ideals of a <emphasis>non-invasive</emphasis>
        lightweight container.</remark>
        <para>Spring's declarative transaction management is made possible with Spring AOP,
        although, as the transactional aspects code comes with Spring and may be used
        in a boilerplate fashion, AOP concepts do not generally have to be understood
        to make effective use of this code.</para>
        <para>It may be helpful to begin by considering EJB CMT and explaining the
        similarities and differences with Spring declarative transaction
        management. The basic approach is similar: it is possible to specify
        transaction behavior (or lack of it) down to individual method level. It is
        possible to make a <literal>setRollbackOnly()</literal> call within a
        transaction context if necessary. The differences are:</para>
        <itemizedlist>
            <listitem>
                <para>Unlike EJB CMT, which is tied to JTA, Spring declarative
                transaction management works in any environment. It can work with
                JDBC, JDO, Hibernate or other transactions under the covers, with
                configuration changes only.</para>
            </listitem>
            <listitem>
                <para>Spring enables declarative transaction management to be applied
                to any class (and attendant instances of that class), not merely
                special classes such as EJBs.</para>
            </listitem>
            <listitem>
                <para>Spring offers declarative <emphasis>rollback rules</emphasis>: a
                feature with no EJB equivalent, which we'll discuss below. Rollback
                can be controlled declaratively, not merely programmatically.</para>
            </listitem>
            <listitem>
                <para>Spring gives you an opportunity to customize transactional
                behavior, using AOP. For example, if you want to insert custom
                behavior in the case of transaction rollback, you can. You can also
                add arbitrary advice, along with the transactional advice. With EJB
                CMT, you have no way to influence the container's transaction
                management other than <literal>setRollbackOnly()</literal>.</para>
            </listitem>
            <listitem>
                <para>Spring does not support propagation of transaction contexts
                across remote calls, as do high-end application servers. If you need
                this feature, we recommend that you use EJB. However, consider carefully before
                using such a feature. Normally, we do not want transactions to span remote
                calls.</para>
            </listitem>
        </itemizedlist>
        <sidebar>
		<title>Where is <classname>TransactionProxyFactoryBean</classname>?</title>
            <para>Declarative transaction configuration in versions of Spring 2.0 and above
            differs considerably from previous versions of Spring. The main difference is
            that there is no longer any need to configure
            <classname>TransactionProxyFactoryBean</classname> beans.</para>
            <para>The old, pre-Spring 2.0 configuration style is still 100% 
            valid configuration; under the covers think of the new <literal>&lt;tx:tags/&gt;</literal>
            as simply defining <classname>TransactionProxyFactoryBean</classname> beans
            on your behalf.</para>
        </sidebar>
        <para>The concept of rollback rules is important: they enable us to
        specify which exceptions (and throwables) should cause automatic roll
        back. We specify this declaratively, in configuration, not in Java code.
        So, while we can still call <literal>setRollbackOnly() </literal>on the
        <interfacename>TransactionStatus</interfacename> object to roll the current
        transaction back programmatically, most often we can specify a rule that
        <classname>MyApplicationException</classname> should always result in roll
        back. This has the significant advantage that business objects don't need
        to depend on the transaction infrastructure. For example, they typically
        don't need to import any Spring APIs, transaction or other.</para>
        <para>While the EJB default behavior is for the EJB container to
        automatically roll back the transaction on a <emphasis>system
        exception</emphasis> (usually a runtime exception), EJB CMT does not roll
        back the transaction automatically on an <emphasis>application exception</emphasis>
        (i.e. a checked exception other than <classname>java.rmi.RemoteException</classname>).
        While the Spring default behavior for declarative transaction management follows
        EJB convention (roll back is automatic only on unchecked exceptions), it's often useful
        to customize this.</para>
        <section>
            <title>Understanding Spring's declarative transaction implementation</title>
            <para>The aim of this section is to dispel the mystique
            that is sometimes associated with the use of declarative transactions. 
            It is all very well for this reference documentation simply to tell you to annotate 
            your classes with the <interfacename>@Transactional</interfacename> annotation, 
            add the line (<literal>'&lt;tx:annotation-driven/&gt;'</literal>) to your configuration,
            and then expect you to understand how it all works. This section
            will explain the inner workings of Spring's declarative transaction infrastructure to help 
            you navigate your way back upstream to calmer waters in the event of transaction-related issues.</para>
            <tip>
                <para>Looking at the Spring source code is a good way to get a real understanding of 
                Spring's transaction support. You should find the Javadoc informative and complete. We suggest 
                turning the logging level to <literal>'DEBUG'</literal> in your Spring-enabled
                application(s) during development to better see what goes on under the hood.</para>
            </tip>
            <para>The most important concepts to grasp with regard to Spring's declarative transaction
            support are that this support is enabled via AOP <emphasis>proxies</emphasis>, and that the
            transactional advice is driven by <emphasis>metadata</emphasis> (currently XML- or
            annotation-based). The combination of a proxy with transactional metadata yields an
            AOP proxy that uses a <classname>TransactionInterceptor</classname> in conjunction
            with an appropriate <classname>PlatformTransactionManager</classname> implementation
            to drive transactions around <emphasis>method invocations</emphasis>.</para>
            <note>
                <para>Although knowledge of AOP (and specifically Spring AOP) is not required
                in order to use Springs declarative transaction support, it can help.
                Spring AOP is thoroughly covered in the chapter entitled <xref linkend="aop"/>.</para>
            </note>
            <para>Conceptually, calling a method on a transactional proxy looks like this...</para>
		    <para>
			    <mediaobject>
				    <imageobject role="fo">
					    <imagedata fileref="images/tx.png" format="PNG" align="center" />
				    </imageobject>
				    <imageobject role="html">
					    <imagedata fileref="images/tx.png" format="PNG" align="center" />
				    </imageobject>
			    </mediaobject>
		    </para>
		</section>
        <section id="transaction-declarative-first-example">
            <title>A first example</title>
            <para>Consider the following interface, and its attendant implementation.
            The intent is to convey the concepts, and using <literal><emphasis>Foo</emphasis></literal> and
            <literal><emphasis>Bar</emphasis></literal> means that you can concentrate
            on the transaction usage and not have to worry about the domain model.</para>
            <programlisting><lineannotation>&lt;!-- the service (facade) interface that we want to make transactional --&gt;</lineannotation><![CDATA[
            
package x.y.service;
            
public interface FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    void insertFoo(Foo foo);

    void updateFoo(Foo foo);
}]]></programlisting>
            <programlisting><lineannotation>&lt;!-- an implementation of the above interface --&gt;</lineannotation><![CDATA[
            
package x.y.service;

public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        throw new UnsupportedOperationException();
    }

    public Foo getFoo(String fooName, String barName) {
        throw new UnsupportedOperationException();
    }

    public void insertFoo(Foo foo) {
        throw new UnsupportedOperationException();
    }

    public void updateFoo(Foo foo) {
        throw new UnsupportedOperationException();
    }
}]]></programlisting>
            <para><emphasis>(For the purposes of this example, the fact that the implementation class
            (<classname>DefaultFooService</classname>) throws
            <classname>UnsupportedOperationException</classname> instances in the body
            of each implemented method is good; it allows us to see transactions being created
            and then rolled back in response to <classname>UnsupportedOperationException</classname>
            instances being thrown.)</emphasis></para>
            <para>Let's assume that the first two methods of the <interfacename>FooService</interfacename>
            interface (<literal>getFoo(String)</literal> and <literal>getFoo(String, String)</literal>)
            have to execute in the context of a transaction with read-only semantics, and that
            the other methods (<literal>insertFoo(Foo)</literal> and
            <literal>updateFoo(Foo)</literal>) have to execute in the context of
            a transaction with read-write semantics.</para>
            <para>To configure this scenario in a declarative fashion using XML-based metadata,
            you would write the following configuration (don't worry about taking it in all at once; 
            everything will be explained in detail in the next few paragraphs).</para>
            <programlisting><lineannotation>&lt;!-- from the file <literal>'context.xml'</literal> --&gt;</lineannotation><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       ]]><lineannotation><emphasis role="bold">xmlns:tx="http://www.springframework.org/schema/tx"</emphasis></lineannotation><![CDATA[
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       ]]><lineannotation><emphasis role="bold">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</emphasis></lineannotation><![CDATA[
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
  
  ]]><lineannotation>&lt;!-- this is the service object that we want to make transactional --&gt;</lineannotation><![CDATA[
  <bean id="fooService" class="x.y.service.DefaultFooService"/>

  ]]><lineannotation>&lt;!-- the transactional advice (i.e. what 'happens'; see the <literal>&lt;aop:advisor/&gt;</literal> bean below) --&gt;</lineannotation><![CDATA[
  <tx:advice id="txAdvice" transaction-manager="txManager">
    ]]><lineannotation>&lt;!-- the transactional semantics... --&gt;</lineannotation><![CDATA[
    <tx:attributes>
      ]]><lineannotation>&lt;!-- all methods starting with <literal>'get'</literal> are read-only --&gt;</lineannotation><![CDATA[
      <tx:method name="get*" read-only="true"/>
      ]]><lineannotation>&lt;!-- other methods use the default transaction settings (see below) --&gt;</lineannotation><![CDATA[
      <tx:method name="*"/>
    </tx:attributes>
  </tx:advice>
  
  ]]><lineannotation>&lt;!-- ensure that the above transactional advice runs for any execution
      of an operation defined by the <interfacename>FooService</interfacename> interface --&gt;</lineannotation><![CDATA[
  <aop:config>
    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.FooService.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
  </aop:config>
  
  ]]><lineannotation>&lt;!-- don't forget the <interfacename>DataSource</interfacename> --&gt;</lineannotation><![CDATA[
  <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
    <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
    <property name="username" value="scott"/>
    <property name="password" value="tiger"/>
  </bean>

  ]]><lineannotation>&lt;!-- similarly, don't forget the (particular) <interfacename>PlatformTransactionManager</interfacename> --&gt;</lineannotation><![CDATA[
  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
  </bean>
  
  ]]><lineannotation>&lt;!-- other <literal>&lt;bean/&gt;</literal> definitions here --&gt;</lineannotation><![CDATA[

</beans>]]></programlisting>
            <para>Let's pick apart the above configuration. We have a service object
            (the <literal>'fooService'</literal> bean) that we want to make transactional.
            The transaction semantics that we want to apply are encapsulated in the
            <literal>&lt;tx:advice/&gt;</literal> definition. The
            <literal>&lt;tx:advice/&gt;</literal> definition reads as
            <quote><emphasis>... all methods on starting with <literal>'get'</literal> are to execute
            in the context of a read-only transaction, and all other methods are to execute
            with the default transaction semantics</emphasis></quote>. The
            <literal>'transaction-manager'</literal> attribute of the
            <literal>&lt;tx:advice/&gt;</literal> tag is set to the
            name of the <interfacename>PlatformTransactionManager</interfacename> bean
            that is going to actually <emphasis>drive</emphasis> the transactions (in this
            case the <literal>'txManager'</literal> bean).</para>
            <tip>
                <para>You can actually omit the <literal>'transaction-manager'</literal>
                attribute in the transactional advice (&lt;tx:advice/&gt;) 
                if the bean name of the <interfacename>PlatformTransactionManager</interfacename>
                that you want to wire in has the name <literal>'transactionManager'</literal>.
                If the <interfacename>PlatformTransactionManager</interfacename> bean
                that you want to wire in has any other name, then you have to be explicit
                and use the <literal>'transaction-manager'</literal> attribute as in the example above.</para>
            </tip>
            <para>The final piece of the configuration is the <literal>&lt;aop:config/&gt;</literal>
            definition. This ensures that the transactional advice defined by the
            <literal>'txAdvice'</literal> bean actually gets to execute at the appropriate points
            in the application. First we define a pointcut that matches the execution of any
            operation defined in the <interfacename>FooService</interfacename> interface
            (and we called this pointcut <literal>'fooServiceOperation'</literal>). Then we
            combine the pointcut with the <literal>'txAdvice'</literal> using an advisor.
            The result indicates that at the execution of a <literal>'fooServiceOperation'</literal>,
            the advice defined by <literal>'txAdvice'</literal> will be run.</para>
            <para>The expression defined within the <literal>&lt;aop:pointcut/&gt;</literal>
            element is an AspectJ pointcut expression; see the chapter entitled <xref linkend="aop"/>
            for more details on pointcut expressions in Spring 2.0.</para>
            <para>A common requirement is to make an entire service layer transactional.
            The best way to do this is simply to change the pointcut expression to match
            any operation in your service layer. For example:</para>
            <programlisting><![CDATA[<aop:config>
    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
  </aop:config>]]></programlisting>
            <para><emphasis>(This example assumes that all your service interfaces are defined
            in the <literal>'x.y.service'</literal> package, again, see the chapter entitled
            <xref linkend="aop"/> for more details.)</emphasis></para>
            <para>Now that we've analyzed the configuration, you may be asking
            yourself, <quote><emphasis>Okay... but what does all this configuration actually
            <emphasis role="bold">do</emphasis>?</emphasis></quote>.</para>
            <para>What the above configuration is going to do is create
            a transactional proxy around the object that is created from the
            <literal>'fooService'</literal> bean definition. The proxy will be configured
            with the transactional advice, so that when an appropriate method is invoked
            <emphasis>on the proxy</emphasis>, a transaction <emphasis>may</emphasis>
            be started, suspended, be marked as read-only, etc, depending on the
            transaction semantics associated with that method.</para>
            <para>Let's consider the following driver program to test the above
            configuration.</para>
            <programlisting><![CDATA[public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
        FooService fooService = (FooService) ctx.getBean("fooService");
        fooService.insertFoo (new Foo());
    }
}]]></programlisting>
            <para>The output from running the above program will look something
            like this. <emphasis>(Please note that the Log4J output and the attendant stacktrace
            from the <classname>UnsupportedOperationException</classname> thrown by the
            <literal>insertFoo(..)</literal> method of the
            <classname>DefaultFooService</classname> class have been truncated in
            the interest of clarity.)</emphasis></para>
            <programlisting>    <lineannotation><emphasis role="bold">&lt;!-- the Spring container is starting up... --&gt;</emphasis></lineannotation><![CDATA[
[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy
        for bean 'fooService' with 0 common interceptors and 1 specific interceptors
    ]]><lineannotation><emphasis role="bold">&lt;!-- the <classname>DefaultFooService</classname> is actually proxied --&gt;</emphasis></lineannotation><![CDATA[
[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

    ]]><lineannotation><emphasis role="bold">&lt;!-- ... the <literal>insertFoo(..)</literal> method is now being invoked on the proxy --&gt;</emphasis></lineannotation><![CDATA[

[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo
    ]]><lineannotation><emphasis role="bold">&lt;!-- the transactional advice kicks in here... --&gt;</emphasis></lineannotation><![CDATA[
[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
[DataSourceTransactionManager] - Acquired Connection
        [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

    ]]><lineannotation><emphasis role="bold">&lt;!-- the <literal>insertFoo(..)</literal> method from <classname>DefaultFooService</classname> throws an exception... --&gt;</emphasis></lineannotation><![CDATA[
[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should
        rollback on java.lang.UnsupportedOperationException
[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo
        due to throwable [java.lang.UnsupportedOperationException]

   ]]><lineannotation><emphasis role="bold">&lt;!-- and the transaction is rolled back (by default, <classname>RuntimeException</classname> instances cause rollback) --&gt;</emphasis></lineannotation><![CDATA[
[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection
        [org.apache.commons.dbcp.PoolableConnection@a53de4]
[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
[DataSourceUtils] - Returning JDBC Connection to DataSource

Exception in thread "main" java.lang.UnsupportedOperationException
	at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
   ]]><lineannotation><emphasis role="bold">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</emphasis></lineannotation><![CDATA[
	at $Proxy0.insertFoo(Unknown Source)
	at Boot.main(Boot.java:11)]]></programlisting>
        </section>
        <section>
            <title>Applying different transactional semantics to different beans</title>
            <para>Let's now consider the scenario where you have a number of service layer objects,
            and you want to apply <emphasis>totally different</emphasis> transactional semantics
            to each group of those objects. You can effect this in Spring by defining
            any number of distinct <literal>&lt;aop:advisor/&gt;</literal> elements
            with differing <literal>'pointcut'</literal> and <emphasis>'advice-ref'</emphasis>
            attribute values.</para>
            <para>By way of an example, let's assume that all of your service layer classes
            are defined in a root <literal>'x.y.service'</literal> package. To make all
            beans that are instances of classes (or - better - implementations of interfaces)
            defined in the service package (or in subpackages) and that have names ending in
            <literal>'Service'</literal> have the default transactional semantics, you could
            write the following configuration:</para>
            <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

<aop:config>

    <aop:pointcut id="serviceOperationWithDefaultTxSemantics"
                    expression="execution(* x.y.service..*Service.*(..))"/>

    <aop:advisor pointcut-ref="serviceOperationWithDefaultTxSemantics" 
                    advice-ref="txAdvice"/>

</aop:config>

]]><lineannotation>&lt;!-- these two beans will have the transactional advice applied to them --&gt;</lineannotation><![CDATA[
<bean id="fooService" class="org.xyz.service.DefaultFooService"/>
<bean id="barService" class="org.xyz.service.extras.SimpleBarService"/>

]]><lineannotation>&lt;!-- ...and these two beans won't --&gt;</lineannotation><![CDATA[
<bean id="fooService" class="org.xyz.SomeService"/> ]]><lineannotation>&lt;!-- (not in the right package) --&gt;</lineannotation><![CDATA[
<bean id="barService" class="org.xyz.service.SimpleBarManager"/> ]]><lineannotation>&lt;!-- (doesn't end in 'Service') --&gt;</lineannotation><![CDATA[

<tx:advice id="txAdvice">
    <tx:attributes>
        <tx:method name="get*" read-only="true"/>
        <tx:method name="*"/>
    </tx:attributes>
</tx:advice>

]]><lineannotation>&lt;!-- other transaction infrastructure beans such as a <interfacename>PlatformTransactionManager</interfacename> omitted... --&gt;</lineannotation><![CDATA[

</beans>]]></programlisting>
        </section>
        <section id="transaction-declarative-annotations">
            <title>Using <interfacename>@Transactional</interfacename></title>
			<note>
				<para>
					<emphasis>Please be aware that the functionality offered by the
					<interfacename>@Transactional</interfacename> annotation and the
					attendant support classes is only available to you if you are using
					at least Java 5 (Tiger).</emphasis>
				</para>
			</note>
            <para>In addition to the XML-based declarative approach to transaction configuration,
            you can also use an annotation-based declarative approach to transaction configuration
            via the <interfacename>@Transactional</interfacename> annotation.</para>
            <para>Declaring transaction semantics directly in the Java source code
            puts the declarations much closer to the affected code, and there is
            generally not much danger of undue coupling, since typically, code that
            is deployed as transactional is always deployed that way.</para>
            <para>The ease-of-use afforded by the use of the <interfacename>@Transactional</interfacename>
            annotation is best illustrated with an example, after which all of the details
            will be explained. Consider the following interface definition:</para>
            <programlisting><lineannotation>&lt;!-- the service (facade) interface that we want to make transactional --&gt;</lineannotation><![CDATA[
]]><emphasis role="bold">@Transactional</emphasis><![CDATA[
public interface FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    void insertFoo(Foo foo);

    void updateFoo(Foo foo);
}]]></programlisting>
            <para>Implementations of the above <interfacename>FooService</interfacename> interfaces
            that are declared as beans in the Spring container can be made transactional by
            adding merely <emphasis>one</emphasis> line of XML configuration, like so:</para>
            <programlisting><lineannotation>&lt;!-- from the file <literal>'context.xml'</literal> --&gt;</lineannotation><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
  
  ]]><lineannotation>&lt;!-- this is the service object that we want to make transactional --&gt;</lineannotation><![CDATA[
  <bean id="fooService" class="x.y.service.DefaultFooService"/>

  ]]><lineannotation>&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</lineannotation><![CDATA[
  ]]><emphasis role="bold"><![CDATA[<tx:annotation-driven/>]]></emphasis><![CDATA[

  ]]><lineannotation>&lt;!-- a <interfacename>PlatformTransactionManager</interfacename> is still required --&gt;</lineannotation><![CDATA[
  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    ]]><lineannotation>&lt;!-- sourced from somewhere else --&gt;</lineannotation><![CDATA[
    <property name="dataSource" ref="dataSource"/>
  </bean>
  
  ]]><lineannotation>&lt;!-- other <literal>&lt;bean/&gt;</literal> definitions here --&gt;</lineannotation><![CDATA[

</beans>]]></programlisting>
            <para>The <interfacename>@Transactional</interfacename> annotation may
            be placed before an interface definition, a method on an interface, a
            class definition, or a method on a class.</para>
            <note>
                <para>The mere presence of the <interfacename>@Transactional</interfacename>
                annotation is not enough to actually turn on the transactional behavior - the
                <interfacename>@Transactional</interfacename> annotation is simply metadata
                that can be consumed by something that is
                <interfacename>@Transactional</interfacename>-aware and that can use the
                transactional metadata to apply transactional behavior.</para>
                <para>In the case of the above example, it is the presence of the
                <literal>&lt;tx:annotation-driven/&gt;</literal> element that
                <emphasis>switches on</emphasis> the transactional behavior.</para>
            </note>
            <para>In keeping with one of the Spring framework's central tenets, namely 'do
            the intuitive thing', Spring's treatment of the <interfacename>@Transactional</interfacename>
            annotation with regard to inheritance just makes sense. If you annotate an interface
            at the class level with the <interfacename>@Transactional</interfacename>
            annotation, then all implementations of that interface will inherit the
            transaction settings applied to the interface. This is the direct
            opposite of the usual semantics that apply to annotations, where annotations on
            interfaces and methods are <emphasis role="bold">never</emphasis> inherited.
            With Spring, you can override the default transaction settings that may be inherited from a
            superclass or interface by specifying your own <interfacename>@Transactional</interfacename>
            values; basically, the most derived location takes precedence when evaluating
            the transaction semantics of a method. In the case of the following example, the
            <interfacename>FooService</interfacename>interface is annotated with default transaction
            settings, but the <interfacename>@Transactional</interfacename> annotation on the
            <literal>updateFoo(Foo)</literal> method on the <classname>DefaultFooService</classname>
            class takes precedence over the transactional settings inherited from the
            <interfacename>FooService</interfacename> interface.</para>
            <programlisting><![CDATA[@Transactional(readOnly = true)
public interface FooService {

    Foo getFoo(String fooName);

    void updateFoo(Foo foo);
}]]></programlisting>
            <programlisting><![CDATA[public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        ]]><lineannotation>// do something</lineannotation><![CDATA[
    }

    ]]><lineannotation>// <emphasis role="bold">these</emphasis> settings have precedence</lineannotation><![CDATA[
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    public void updateFoo(Foo foo) {
        ]]><lineannotation>// do something</lineannotation><![CDATA[
    }
}]]></programlisting>
            <note>Please note that this 'plain common sense' approach to inheriting
            <interfacename>@Transactional</interfacename> settings <emphasis>only</emphasis>
            applies in the case of SpringAOP-driven transaction management. If you are
            using another transaction management strategy, such as AspectJ-driven transactions,
            then the usual Java rules with regard to annotations apply
            (i.e. there is no inheritance).</note>
            <section>
                <title><interfacename>@Transactional</interfacename> settings</title>
                <para>Used in its simplest form, the <interfacename>@Transactional</interfacename> annotation
                specifies that an interface, class, or method must be transactional. The default
                transaction semantics are read/write, <literal>PROPAGATION_REQUIRED</literal>,
                <literal>ISOLATION_DEFAULT</literal>, <literal>TIMEOUT_DEFAULT</literal>, with
                rollback on a <classname>RuntimeException</classname>, but not
                <classname>Exception</classname>.</para>
                    <para>Optional properties of the annotation modify transaction settings.</para>
                    <para>
                        <table>
                            <title>Properties of the <interfacename>Transactional</interfacename> Annotation</title>
                            <tgroup cols="3">
                                <thead>
                                    <row>
                                        <entry>Property</entry>
                                        <entry>Type</entry>
                                        <entry>Description</entry>
                                    </row>
                                </thead>
                                <tbody>
                                    <row>
                                        <entry>
                                            <literal>propagation</literal>
                                        </entry>
                                        <entry>enum: <classname>Propagation</classname></entry>
                                        <entry>optional propagation setting (defaults to <literal>PROPAGATION_REQUIRED</literal>)</entry>
                                    </row>
                                    <row>
                                        <entry>
                                            <literal>isolation</literal>
                                        </entry>
                                        <entry>enum: <classname>Isolation</classname></entry>
                                        <entry>optional isolation level (defaults to <literal>ISOLATION_DEFAULT</literal>)</entry>
                                    </row>
                                    <row>
                                        <entry>
                                            <literal>readOnly</literal>
                                        </entry>
                                        <entry>boolean</entry>
                                        <entry>read/write vs. read-only transaction; defaults to <literal>false</literal>, i.e.
                                        transactions are read/write)</entry>
                                    </row>
                                    <row>
                                        <entry>
                                            <literal>rollbackFor</literal>
                                        </entry>
                                        <entry>an array of <classname>Class</classname> objects, which
                                        must be derived from <classname>Throwable</classname></entry>
                                        <entry>an optional array of exception classes which <emphasis role="bold">must</emphasis>
                                    cause rollback. By default, checked exceptions do not roll
                                    back, unchecked (<classname>RuntimeException</classname> derived) do
                                    cause roll back</entry>
                                    </row>
                                    <row>
                                        <entry>
                                            <literal>rollbackForClassname</literal>
                                        </entry>
                                        <entry>an array of <classname></classname> class names. Classes must be derived
                                        from <classname>Throwable</classname></entry>
                                        <entry>an optional array of names of exception classes that
                                        <emphasis role="bold">must</emphasis> cause rollback</entry>
                                    </row>
                                    <row>
                                        <entry>
                                            <literal>noRollbackFor</literal>
                                        </entry>
                                        <entry>an array of <classname>Class</classname> objects, which
                                        must be derived from <classname>Throwable</classname></entry>
                                        <entry>an optional array of exception classes that must
                                        <emphasis role="bold">not</emphasis> cause rollback.</entry>
                                    </row>
                                    <row>
                                        <entry>
                                            <literal>noRollbackForClassname</literal>
                                        </entry>
                                        <entry>an array of <classname>String</classname> class names, which
                                        must be derived from <classname>Throwable</classname></entry>
                                        <entry>an optional array of names of exception classes which must
                                        <emphasis role="bold">not</emphasis> cause rollback</entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </table>
                    </para>
                    <para><emphasis>We recommend you consult the Javadoc for the
                    <interfacename>@Transactional</interfacename> annotation since it describes the above
                    properties and their attendant values in much greater detail.</emphasis></para>
                </section>
        </section>
        <section id="transaction-declarative-applying-more-than-just-tx-advice">
            <title>Advising transactional operations</title>
            <para>Consider the situation where you have an instance of a class, and
            you would like to execute <emphasis>both</emphasis> transactional
            <emphasis>and</emphasis> (to keep things simple) some basic profiling
            advice . So how do you effect this in the context of using
            <literal>&lt;tx:annotation-driven/&gt;</literal>?</para>
            <para>What we want to see when we invoke the
            <literal>updateFoo(Foo)</literal> method is a) some
            profiling aspect starting up, then b) transactional advice being applied
            (by starting or participating in a transaction depending on the configured
            transactional metadata), then c) the method on the advised object executing,
            then d) the transaction committing (we'll assume a sunny day scenario here),
            and then finally e) the profiling aspect reporting (somehow) exactly
            how long the whole method invocation took.</para>
            <note>
                <para>This chapter is not concerned with explaining AOP (except as it
                applies to transactions). Please see the chapter
                entitled <xref linkend="aop"/> for detailed coverage of the
                various bits and pieces of the following AOP configuration (and AOP
                in general).</para>
            </note>
            <para>Here is the code for a (naively) simple profiling aspect.
            <emphasis>(Please note that the ordering of advice is controlled via the
            <interfacename>Ordered</interfacename> interface. For full details on
            advice ordering, consult the section entitled
            <xref linkend="aop-ataspectj-advice-ordering"/>.)</emphasis></para>
            <programlisting><![CDATA[package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

    private int order;

    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    public Object profile(ProceedingJoinPoint call) throws Throwable {
        Object returnValue;
        StopWatch clock = new StopWatch(getClass().getName());
        try {
            clock.start(call.toShortString());
            returnValue = call.proceed();
        } finally {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
        return returnValue;
    }
}
]]></programlisting>
            <para>Here is the attendant configuration that will effect what we want.</para>
            <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean id="fooService" class="x.y.service.DefaultFooService"/>

    ]]><lineannotation>&lt;!-- the profiling advice --&gt;</lineannotation><![CDATA[
    <bean id="profiler" class="x.y.SimpleProfiler">
        ]]><lineannotation>&lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</lineannotation><![CDATA[
        <property name="order" value="1"/>
    </bean>

    <aop:config>
        
        <aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/>

        ]]><lineannotation>&lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</lineannotation><![CDATA[
        <aop:advisor
                advice-ref="txAdvice"
                pointcut-ref="entryPointMethod"
                order="2"/> ]]><lineannotation>&lt;!-- order value is higher than the profiling aspects --&gt;</lineannotation><![CDATA[

        <aop:aspect id="profilingAspect" ref="profiler">
            <aop:pointcut id="serviceMethodWithReturnValue"
                          expression="execution(!void x.y..*Service.*(..))"/>
            <aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
        </aop:aspect>

    </aop:config>

    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>

    ]]><lineannotation>&lt;!-- other &lt;bean/&gt; definitions such as a <interfacename>DataSource</interfacename> and a <interfacename>PlatformTransactionManager</interfacename> here --&gt;</lineannotation><![CDATA[

</beans>]]></programlisting>
            <para>The result of the above configuration will be a <literal>'fooService'</literal>
            bean that has profiling and transactional aspects applied to it
            <emphasis>in that order</emphasis>. If we wanted the profiling advice to
            execute <emphasis>after</emphasis> the transactional advice on the way in, and
            <emphasis>before</emphasis> the transactional advice on the way out, then we would
            simply swap the value of the profiling aspect bean's <literal>'order'</literal>
            property such that it was higher than the transactional advice's order value.</para>
            <para>The configuration of any number of additional aspects is effected in a
            similar fashion.</para>
        </section>
        <section id="transaction-declarative-aspectj">
            <title>Using <interfacename>@Transactional</interfacename> with AspectJ</title>
            <para>It is also possible to use Spring's <interfacename>@Transactional</interfacename>
            support outside of a Spring container by means of an AspectJ aspect shipped in
            <literal>spring-aspects.jar</literal>. To use this support you first annotate types and methods with the
            <interfacename>@Transactional</interfacename> annotation, and then you must link (weave)
            your application with the
            <classname>org.springframework.transaction.aspectj.AnnotationTransactionAspect</classname>
            defined in <literal>spring-aspects.jar</literal>. The aspect must also be configured with
            a transaction manager. You could of course use Spring to dependency inject the aspect, but
            since we're focusing here on applications running outside of a Spring container, we'll
            show you how to do it programmatically</para>
            <note>
                <para>Prior to continuing, you may well want to read the previous sections entitled
                <xref linkend="transaction-declarative-annotations"/> and <xref linkend="aop"/>
                respectively.</para>
            </note>
            <programlisting><lineannotation>// construct an appropriate transaction manager </lineannotation><![CDATA[
DataSourceTransactionManager txManager = new  DataSourceTransactionManager(getDataSource());

]]><lineannotation>// configure the <classname>AnnotationTransactionAspect</classname> to use it, this must be done before executing any transactional methods</lineannotation><![CDATA[
AnnotationTransactionAspect.aspectOf().setTransactionManager (txManager); ]]></programlisting>
            <para>When using this aspect the <interfacename>@Transactional</interfacename> annotation
            can be used to annotate a type or interface as transactional, and subsequently the execution
            of any <emphasis role="bold">public</emphasis> operation defined by that type will
            have transactional semantics. Transactional semantics for an individual <emphasis role="bold">public</emphasis>
            method can be defined by annotating the corresponding method definition. Note that if
            annotating interface members (as opposed to methods implementing the interface), the
            interface itself should also be annotated as <interfacename>@Transactional</interfacename>.</para>
            <para>To weave your applications with the
            <classname>AnnotationTransactionAspect</classname> you must either build your
            application with AspectJ (see the <ulink url="http://www.eclipse.org/aspectj/doc/ released/devguide/index.html">AspectJ Development Guide</ulink>)
            or use load-time weaving. See <xref linkend="aop-aj-ltw"/> for a discussion of load-time weaving with AspectJ.</para>
        </section>
    </section>
    <section id="transaction-default-settings">
        <title>The default transaction settings</title>
        <para>The default transaction settings (semantics) are as follows:</para>
        <itemizedlist>
            <listitem>
                <para>Exception handling: A <classname>RuntimeException</classname> causes roll-back,
                whereas a normal (checked) <classname>Exception</classname> does not.</para>
            </listitem>
            <listitem>
                <para>Transactions are read/write.</para>
            </listitem>
            <listitem>
                <para>Isolation level: <literal>TransactionDefinition.ISOLATION_DEFAULT</literal></para>
            </listitem>
            <listitem>
                <para>Timeout: <literal>TransactionDefinition.TIMEOUT_DEFAULT</literal></para>
            </listitem>
        </itemizedlist>
        <para>The <interfacename>org.springframework.transaction.TransactionDefinition</interfacename>
        interface contains comprehensive Javadoc-style information concerning the above settings, and
        so will not be repeated here.</para>
    </section>
    <section id="transaction-programmatic">
        <title>Programmatic transaction management</title>
        <para>Spring provides two means of programmatic transaction management:</para>
        <itemizedlist>
            <listitem>
                <para>Using the <classname>TransactionTemplate</classname></para>
            </listitem>
            <listitem>
                <para>Using a <interfacename>PlatformTransactionManager</interfacename>
                implementation directly</para>
            </listitem>
        </itemizedlist>
        <para>If you are going to use programmatic transaction management, the Spring
        team generally recommend the first approach (i.e. using the
        <classname>TransactionTemplate</classname>). The second approach is similar to
        using the JTA <interfacename>UserTransaction</interfacename> API (although
        exception handling is less cumbersome).</para>
        <section>
            <title>Using the <classname>TransactionTemplate</classname></title>
            <para>The <classname>TransactionTemplate</classname> adopts the same
            approach as other Spring <emphasis>templates</emphasis> such as
            <classname>JdbcTemplate</classname> and
            <classname>HibernateTemplate</classname>. It uses a callback approach, to
            free application code from having to do the boilerplate acquisition 
            and release of resources (i.e. no more try/catch/finally/try/catch blocks.)
            Like many of the other template classes in Spring, a
            <classname>TransactionTemplate</classname> instance is threadsafe.</para>
            <para>Application code that must execute in a transaction context looks
            like this. Note that the <interfacename>TransactionCallback</interfacename> can be
            used to return a value:</para>
            <programlisting><![CDATA[Object result = tt.execute(new TransactionCallback() {
    public Object doInTransaction(TransactionStatus status) {
        updateOperation1();
        return resultOfUpdateOperation2();
    }
});]]></programlisting>
            <para>If there is no return value, use the convenient
            <classname>TransactionCallbackWithoutResult</classname> class via a
            Java anonymous class like so:</para>
                <programlisting><![CDATA[tt.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});]]></programlisting>
            <para>Code within the callback can roll the transaction back by calling
            the <literal>setRollbackOnly()</literal> method on the supplied
            <interfacename>TransactionStatus</interfacename> object.</para>
            <para>Application classes wishing to use the
            <classname>TransactionTemplate</classname> must have access to a
            <interfacename>PlatformTransactionManager</interfacename> (which will
            typically be supplied to the class via dependency injection). It is
            easy to unit test such classes with a mock or stub
            <interfacename>PlatformTransactionManager</interfacename>. There is
            no JNDI lookup or <literal>static</literal> shenanigans here: it is a simple
            interface. As usual, you can use Spring to greatly simplify your unit testing.</para>
        </section>
        <section id="transaction-programmatic-ptm">
            <title>Using the <interfacename>PlatformTransactionManager</interfacename></title>
            <para>You can also use the
            <interfacename>org.springframework.transaction.PlatformTransactionManager</interfacename>
            directly to manage your transaction. Simply pass the implementation of
            the <interfacename>PlatformTransactionManager</interfacename> you're
            using to your bean via a bean reference. Then, using the
            <interfacename>TransactionDefinition</interfacename> and
            <interfacename>TransactionStatus</interfacename> objects you can
            initiate transactions, rollback and commit.</para>
           <programlisting><![CDATA[DefaultTransactionDefinition def = new DefaultTransactionDefinition();
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // execute your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);]]></programlisting>
        </section>
    </section>
    <section>
        <title>Choosing between programmatic and declarative transaction management</title>
        <para>Programmatic transaction management is usually a good idea only if
        you have a small number of transactional operations. For example, if you
        have a web application that require transactions only for certain update
        operations, you may not want to set up transactional proxies using Spring
        or any other technology. In this case, using the <classname>TransactionTemplate</classname>
        <emphasis>may</emphasis> be a good approach.</para>
        <para>On the other hand, if your application has numerous transactional
        operations, declarative transaction management is usually worthwhile. It
        keeps transaction management out of business logic, and is not difficult
        to configure in Spring. Using Spring, rather than EJB CMT, the
        configuration cost of declarative transaction management is greatly
        reduced.</para>
    </section>
    <section id="transaction-application-server-integration">
        <title>Application server-specific integration</title>
        <para>Spring's transaction abstraction is generally application server
        agnostic. Additionally, Spring's <classname>JtaTransactionManager</classname> class,
        which can optionally perform a JNDI lookup for the JTA
        <interfacename>UserTransaction</interfacename> and
        <literal>TransactionManager</literal> objects, can be set to autodetect
        the location for the latter object, which varies by application server. Having
        access to the <literal>TransactionManager</literal> instance does allow
        enhanced transaction semantics. Please see the
        <classname>JtaTransactionManager</classname> Javadocs for more details.</para>
        <section>
            <title>BEA WebLogic</title>
            <para>In a WebLogic 7.0, 8.1 or higher environment, you will generally
            prefer to use <classname>WebLogicJtaTransactionManager</classname> instead
            of the stock <classname>JtaTransactionManager</classname> class. This
            special WebLogic-specific subclass of the normal
            <classname>JtaTransactionManager</classname>. It supports the full power of
            Spring's transaction definitions in a WebLogic managed transaction
            environment, beyond standard JTA semantics: features include transaction
            names, per-transaction isolation levels, and proper resuming of
            transactions in all cases.</para>
        </section>
        <section>
            <title>IBM WebSphere</title>
            <para>In a WebSphere 5.1, 5.0 and 4 environment, you may wish to use
            Spring's <classname>WebSphereTransactionManagerFactoryBean</classname>
            class. This is a factory bean which retrieves the JTA
            <literal>TransactionManager</literal> in a WebSphere environment, which
            is done via WebSphere's <literal>static</literal> access methods.
            (These methods are different for each version of WebSphere.)</para>
            <para>Once the JTA <interfacename>TransactionManager</interfacename> instance has
            been obtained via this factory bean, Spring's
            <classname>JtaTransactionManager</classname> may be configured with a
            reference to it, for enhanced transaction semantics over the use of only
            the JTA <interfacename>UserTransaction</interfacename> object.</para>
            <para>Please see the Javadocs for full details.</para>
        </section>
    </section>
    <section>
        <title>Solutions to common problems</title>
        <section>
            <title>Use of the wrong transaction manager for a specific <interfacename>DataSource</interfacename></title>
            <para>Developers should take care to use the correct
            <emphasis><interfacename>PlatformTransactionManager</interfacename></emphasis>
            implementation for their requirements. It is important to understand
            how the Spring transaction abstraction works with JTA global transactions.
            Used properly, there is no conflict here: Spring merely provides a
            straightforward and portable abstraction.</para>
            <para>If you are using global transactions, you <emphasis>must</emphasis> use the Spring
            <classname>org.springframework.transaction.jta.JtaTransactionManager</classname> class
            (or an
            <link linkend="transaction-application-server-integration"> application server-specific subclass</link>
             of it) for all your transactional operations. Otherwise Spring will attempt
             to perform local transactions on resources such as container
             <interfacename>DataSource</interfacename> instances. Such local transactions
             don't make sense, and a good application server will treat them as errors.</para>
        </section>
    </section>
</chapter>