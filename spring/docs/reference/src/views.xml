<chapter id="view">

    <title>Integrating view technologies</title>
    
	<sect1 id="view-introduction">	
		
		<title>Introduction</title>

		<para> 
            Spring is an application framework for all layers: it offers a
			bean configuration foundation, AOP support, a JDBC abstraction
			framework, abstract transaction support, etc. It is a very
			non-intrusive effort.
        </para>

		<para>
			One of the areas in which Spring excels is its separation of view
            technologies from the rest of the MVC framework.  Deciding to use
            Velocity or XSLT in place of an existing JSP for example, is
            primarily a matter of configuration.  This chapter covers the
            major view technologies that work with Spring and touches briefly
            on how to add new ones.  This chapter assumes you are already
            familiar with <xref linkend="mvc-viewresolver"/> which covers the
            basics of how views in general are coupled to the MVC
            framework.</para>
		
	</sect1>
	
	<sect1 id="view-velocity">
	
		<title>Velocity</title>
		
		<para>
		    Velocity is a view technology developed the Jakarta Project. More
		    information about Velocity can be found at
		    http://jakarta.apache.org/velocity. This section describes how to
		    integrate the Velocity view technology for use with Spring.
		</para>
		
		<sect2 id="view-velocity-dependencies">
		
			<title>Dependencies</title> 

            <para>

                There is one dependency that your web application will need to
     			satisfy before working with Velocity, namely that
     			<literal>velocity-1.x.x.jar</literal> needs to be
     			available. Typically this is included in the
     			<literal>WEB-INF/lib</literal> folder where it is guaranteed
     			to be found by a J2EE server and added to the classpath for
     			your application. It is of course assumed that you already
     			have the spring.jar in your <literal>WEB-INF/lib</literal>
     			folder too! The latest stable velocity jar is supplied with
     			the Spring framework and can be copied from the
     			<literal>/lib/velocity</literal> directory.

            </para>
			
		</sect2>
		
		<sect2 id="view-velocity-configuration-dispatcher">

			<title>Dispatcher Servlet Context</title>
			<para>	
			
                The configuration file for your Spring dispatcher servlet
			    (usually <literal>WEB-INF/[servletname]-servlet.xml</literal>)
			    should already contain a bean definition for the view
			    resolver. We'll also add a bean here to configure the Velocity
			    environment. I've chosen to call my dispatcher
			    'frontcontroller' so my config file names reflect this.
  
            </para>

			<para>
				The following code examples show the various configuration
			    files with appropriate comments.
            </para>

			<programlisting><![CDATA[		        
<!-- ===========================================================-->
<!-- View resolver. Required by web framework.                  -->
<!-- ===========================================================-->
<!--
  View resolvers can be configured with ResourceBundles or XML files.  If you need
  different view resolving based on Locale, you have to use the resource bundle resolver, 
  otherwise it makes no difference.  I simply prefer to keep the Spring configs and 
  contexts in XML.  See Spring documentation for more info.
-->
<bean id="viewResolver" class="org.springframework.web.servlet.view.XmlViewResolver">
  <property name="cache"><value>true</value></property>
  <property name="location"><value>/WEB-INF/frontcontroller-views.xml</value></property>
</bean>

<!-- ===========================================================-->
<!-- Velocity configurer.                                       -->
<!-- ===========================================================-->
<!--
  The next bean sets up the Velocity environment for us based on a properties file, the 
  location of which is supplied here and set on the bean in the normal way.  My example shows
  that the bean will expect to find our velocity.properties file in the root of the 
  WEB-INF folder.  In fact, since this is the default location, it's not necessary for me
  to supply it here.  Another possibility would be to specify all of the velocity
  properties here in a property set called "velocityProperties" and dispense with the
  actual velocity.properties file altogether.
-->
<bean 
  id="velocityConfig" 
  class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"
  singleton="true">
  <property name="configLocation"><value>/WEB-INF/velocity.properties</value></property>          
</bean>
				]]></programlisting>
		</sect2>
			
		<sect2 id="view-velocity-configuration-velocityprops">
			
			<title>Velocity.properties</title>

			<para>
				This file contains the values that are passed to the Velocity
			    runtime in order to configure velocity itself. Only a few
			    properties are actually required, but many more optional
			    properties are available - see the Velocity docs for more
			    information. Here, I'm just demonstrating the bare minimum to
			    get Velocity up and running in your Spring MVC application.
			</para>

			<para>

				The main property values concern the location of the Velocity
			    templates themselves. Velocity templates can be loaded from
			    the classpath or the file system and there are pros and cons
			    for both. Loading from the classpath is entirely portable and
			    will work on all target servers, but you may find that the
			    templates clutter your java packages (unless you create a new
			    source tree for them). A further downside of classpath storage
			    is that during development, changing anything in the source
			    tree often causes a refresh of the resource in the
			    <literal>WEB-INF/classes</literal> tree and this in turn may
			    cause your development server to restart the application
			    (hot-deploying of code). This can be irritating. Once most of
			    the development is complete though, you could store the
			    templates in a jar file which would make them available to the
			    application if this were placed in
			    <literal>WEB-INF/lib</literal>

            </para>

			<para> 

                This example stores velocity templates on the file system
                somewhere under <literal>WEB-INF</literal> so that they are
                not directly available to the client browsers, but don't cause
                an application restart in development every time you change
                one. The downside is that the target server may not be able to
                resolve the path to these files correctly, particularly if the
                target server doesn't explode WAR modules on the file
                system. The file method works fine for Tomcat 4.1.x/5.x,
                WebSphere 4.x and WebSphere 5.x. Your mileage may vary.

            </para>

			<programlisting><![CDATA[
#
# velocity.properties - example configuration
#


# uncomment the next two lines to load templates from the 
# classpath (i.e. WEB-INF/classes)
#resource.loader=class
#class.resource.loader.class=org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader

# comment the next two lines to stop loading templates from the
# file system
resource.loader=file
file.resource.loader.class=org.apache.velocity.runtime.resource.loader.FileResourceLoader


# additional config for file system loader only.. tell Velocity where the root
# directory is for template loading.  You can define multiple root directories
# if you wish, I just use the one here.  See the text below for a note about
# the ${webapp.root}
file.resource.loader.path=${webapp.root}/WEB-INF/velocity


# caching should be 'true' in production systems, 'false' is a development
# setting only.  Change to 'class.resource.loader.cache=false' for classpath
# loading
file.resource.loader.cache=false

# override default logging to direct velocity messages
# to our application log for example.  Assumes you have 
# defined a log4j.properties file
runtime.log.logsystem.log4j.category=com.mycompany.myapplication 
			]]></programlisting>		
		        
			<para>

				The file resource loader configuration above uses a marker to
			    denote the root of the web application on the file system
			    <literal>${webapp.root}</literal>. This marker will be
			    translated into the actual OS-specific path by the Spring code
			    prior to supplying the properties to Velocity. This is what
			    makes the file resource loader non-portable in some
			    servers. The actual name of the marker itself can be changed
			    if you consider it important by defining a different
			    "appRootMarker" for VelocityConfigurer. See the Spring
			    documentation for details on how to do this.

            </para>

            <para>

			    Alternatively, you can specify velocity properties directly in
				the bean definition for the Velocity config bean by replacing
				the "configLocation" property with the following inline
				properties..

			</para>

			<programlisting><![CDATA[
<property name="velocityProperties">
  <props>
    <prop key="resource.loader">file</prop>
    <prop key="file.resource.loader.class">org.apache.velocity.runtime.resource.loader.FileResourceLoader</prop>
    <prop key="file.resource.loader.path">${webapp.root}/WEB-INF/velocity</prop>
   	<prop key="file.resource.loader.cache">false</prop>
  </props>
</property>
			]]></programlisting>		

            <para>

                Note that as of Spring version 1.0-m4 you can avoid using a
                properties file or inline properties to define file system
                loading of templates by putting the following property in the
                Velocity config bean which will cause the other values to be 
				figured out.

            </para>

			<programlisting><![CDATA[
<property name="resourceLoaderPath"><value>/WEB-INF/velocity/</value></property>
			]]></programlisting>		
            
        </sect2>
			
		<sect2 id="view-velocity-configuration-viewconfig">
			
			<title>View configuration</title>

			<para>
				The last step in configuration is to define some views that
			    will be rendered with velocity templates. Views are always
			    defined in a consistent manner in Spring context files. As
			    noted earlier, this example uses an XML file to define view
			    beans, but a properties file (ResourceBundle) can also be
			    used. The name of the view definition file was defined earlier
			    in the ViewResolver bean - part of the
			    <literal>WEB-INF/frontcontroller-servlet.xml</literal> file.

		    </para>

			<programlisting><![CDATA[
<!--
  Views can be hierarchical, here's an example of a parent view that 
  simply defines the class to use and sets a default template which
  will normally be overridden in child definitions.
-->
<bean id="parentVelocityView" class="org.springframework.web.servlet.view.velocity.VelocityView">
  <property name="templateName"><value>mainTemplate.vm</value></property>        
</bean>

<!--
  - The main view for the home page.  Since we don't set a template name, the value
  from the parent is used.
-->
<bean id="welcomeView" parent="parentVelocityView">
  <property name="attributes">
    <props>
      <prop key="title">My Velocity Home Page</prop>
    </props>
  </property>     
</bean>  

<!--
  - Another view - this one defines a different velocity template.
-->
<bean id="secondaryView" parent="parentVelocityView">
  <property name="templateName"><value>secondaryTemplate.vm</value></property>  
  <property name="attributes">
    <props>
      <prop key="title">My Velocity Secondary Page</prop>
    </props>
  </property>    
</bean>   
			]]></programlisting>
		</sect2>

		<sect2 id="view-velocity-templates">
			<title>Create templates and test</title>

			<para>

				Finally, you simply need to create the actual velocity
				templates. We have defined views that reference two templates,
				mainTemplate.vm and secondaryTemplate.vm Both of these files
				will live in <literal>WEB-INF/velocity/</literal> as noted in
				the velocity.properties file above. If you chose a classpath
				loader in velocity.properties, these files would live in the
				default package (<literal>WEB-INF/classes</literal>), or in a
				jar file under <literal>WEB-INF/lib</literal>.  Here's what
				our 'secondaryView' might look like (simplified HTML)

            </para>

			<programlisting><![CDATA[
## $title is set in the view definition file for this view.
<html>
  <head><title>$title</title></head>
  <body>
    <h1>This is $title!!</h1>
  </body>
</html>
			]]></programlisting>

                <para>
				    Now, when your controllers return a ModelAndView with the
				    "secondaryView" set as the view to render, Velocity should
				    kick in with the above page.
                </para>

		</sect2>
		
		<sect2 id="view-velocity-forms">

		    <title>Form Handling</title>

			<para>
			
			    Spring provides a tag library for use in JSP's that contains
			    (amongst other things) a
			    <literal><![CDATA[<spring:bind>]]></literal> tag.  This tag
			    primarily enables forms to display the results of failed
			    validations from a <literal>Validator</literal> in the web or
			    business tier.  This behaviour can be simulated with a
			    Velocity macro and some additional Spring functionality.

			</para>

			<para>
			
			    The error messages that are actually produced from the
			    validation of a form submission can be read from a properties
			    file to make them easily maintainable or internationalised.
			    Spring handles this elegantly in its own way and you should
			    refer to the MVC tutorial or relevant parts of the javadocs
			    for details on how this works.  In order to gain access to the
			    messages, the <literal>RequestContext</literal> object needs
			    to be exposed to your Velocity templates in the
			    <literal>VelocityContext</literal>.  Amend your template
			    definition in views.properties or views.xml file to give a
			    name to this attribute (giving it a name is what causes it to
			    be exposed)

			</para>

			<programlisting><![CDATA[
<bean id="welcomeView" parent="parentVelocityView">
  <property name="requestContextAttribute"><value>rc</value></property>  
  <property name="attributes">
    <props>
      <prop key="title">My Velocity Home Page</prop>
    </props>
  </property>     
</bean>
			]]></programlisting>

			<para>

			    The example above is based on our earlier example and sets the
			    RequestContext attribute name to be rc.  All Velocity views
			    that inherit from this parent view will now have an additional
			    object available to them via the reference
			    <literal>$rc</literal>

			</para>

			<para>

			    Next, a velocity macro needs to be defined.  It makes sense to
			    create this macro in a global macro file since it will be
			    reusable across many Velocity templates (html forms).  Refer
			    to the Velocity documentation for more information on creating
			    macros.  

			</para>

			<para>

			    The code below should go into the file VM_global_library.vm in
			    the root directory of your Velocity template location..

			</para>

			<programlisting><![CDATA[
#*
 * showerror
 *
 * display an error for the field name supplied if one exists
 * in the supplied errors object.
 *
 * param $errors the object obtained from RequestContext.getErrors( "formBeanName" )
 * param $field the field name you want to display errors for (if any)
 *
 *#
#macro( showerror $errors $field )
  #if( $errors )
    #if( $errors.getFieldErrors( $field ))
      #foreach($err in $errors.getFieldErrors( $field ))
        <span class="fieldErrorText">$rc.getMessage($err)</span><br />
      #end
    #end
  #end
#end
            ]]></programlisting>

			<para>

			    Finally, in your html forms, you can use code similar to the
			    following to display bound error messages for each input
			    field.

			</para>

			<programlisting><![CDATA[
## set the following variable once somewhere at the top of
## the velocity template
#set ($errors=$rc.getErrors("commandBean"))
<html>
...
<form ...>
  <input name="query" value="$!commandBean.query"><br>
  #showerror($errors "query")
</form>
...
</html>
            ]]></programlisting>

		</sect2>		
		
   		<sect2 id="view-velocity-summary">
			<title>Summary</title> 

            <para>

                To summarize, this is the tree structure of files discussed in
			    the example above. Only a partial tree is shown, some required
			    directories are not highlighted here. Incorrect file locations
			    are probably the major reason for velocity views not working,
			    with incorrect properties in the view definitions a close
			    second.

            </para>

			<programlisting><![CDATA[
ProjectRoot
  |
  +- WebContent
      |
      +- WEB-INF
          |
          +- lib
          |   |
          |   +- velocity-1.3.1.jar
          |   +- spring.jar
          |
          +- velocity
          |   |
          |   +- VM_global_library.vm
          |   +- mainTemplate.vm
          |   +- secondaryTemplate.vm
          |
          +- frontcontroller-servlet.xml
          +- frontcontroller-views.xml
          +- velocity.properties

]]></programlisting>
			
		</sect2>
	</sect1>
	
	
	
	<sect1 id="view-xslt">
		<title>XSLT Views</title>

		<para>

			XSLT is a transformation language for XML and is popular as a view
			technology within web applications.  XSLT can be a good choice as
			a view technology if your application naturally deals with XML, or
			if your model can easily be converted to XML.  The following
			section shows how to produce an XML document as model data and
			have it transformed with XSLT in a Spring application.

		</para>
		
		<sect2 id="view-xslt-firstwords">

			<title>My First Words</title> 

            <para>

			    This example is a trivial Spring application that creates a
			    list of words in the Controller and adds them to the model
			    map.  The map is returned along with the view name of our XSLT
			    view.  See <xref linkend="mvc-controller"/> for details of
			    Spring <literal>Controller</literal>s.  The XSLT view will
			    turn the list of words into a simple XML document ready for
			    transformation.

			</para>
			
		</sect2>


		<sect2 id="view-xslt-config">

			<title>Configuration</title> 

            <para>

			    Configuration is standard for a simple Spring application.
			    The dispatcher servlet config file contains a reference to a
			    <literal>ViewResolver</literal>, URL mappings and a single
			    controller bean..
<programlisting><![CDATA[
<bean id="homeController"class="xslt.HomeController"/> ]]></programlisting>
				..that implements our word generation 'logic'.

             </para>

			 <para>

                The controller logic is encapsulated in a subclass of
                AbstractController, with the handler method being defined like
                so..

<programlisting><![CDATA[
protected ModelAndView handleRequestInternal(
  HttpServletRequest req,
  HttpServletResponse resp)
  throws Exception {
        
  Map map = new HashMap();
  List wordList = new ArrayList();
        
  wordList.add("hello");
  wordList.add("world");
       
  map.put("wordList", wordList);
      
  return new ModelAndView("home", map);
} ]]></programlisting>

			</para>

			<para>
			
			    So far we've done nothing that's XSLT specific.  The model
			    data has been created in the same way as you would for any
			    other Spring MVC application.  Depending on the configuration
			    of the application now, that list of words could be rendered
			    by JSP/JSTL by having them added as request attributes, or
			    they could be handled by Velocity by adding the object to the
			    VelocityContext.  In order to have XSLT render them, they of
			    course have to be converted into an XML document somehow.
			    There are software packages available that will automatically
			    'domify' an object graph, but within Spring, you have complete
			    flexibility to create the DOM from your model in any way you
			    choose.  This prevents the transformation of XML playing too
			    great a part in the structure of your model data which is a
			    danger when using tools to manage the domification process.

	        </para>		
		</sect2>


		<sect2 id="view-xslt-subclassing">

			<title>Convert the model data to XML</title> 

            <para>

			    In order to create a DOM document from our list of words or
			    any other model data, we subclass
			    <literal>org.springframework.web.servlet.view.xslt.AbstractXsltView</literal>.
			    In doing so, we must implement the abstract method
			    <literal>createDomNode()</literal>.  The first parameter
			    passed to this method is our model Map.  Here's the complete
			    listing of the HomePage class in our trivial word application
			    - it uses JDOM to build the XML document before converting it
			    to the required W3C Node, but this is simply because I find
			    JDOM (and Dom4J) easier API's to handle than the W3C API.

<programlisting><![CDATA[
public class HomePage extends AbstractXsltView {

  protected Node createDomNode( 
    Map model, String rootName, HttpServletRequest req, HttpServletResponse res
  ) throws Exception {
        
    org.jdom.Document doc = new org.jdom.Document();
    Element root = new Element(rootName);
    doc.setRootElement(root);
		
    List words = (List) model.get("wordList");
    for (Iterator it = words.iterator(); it.hasNext();) {	
      String nextWord = (String) it.next();	
      Element e = new Element("word");
      e.setText(nextWord);
      root.addContent(e);
    }
		
    // convert JDOM doc to a W3C Node and return
    return new DOMOutputter().output( doc );
  }	

}
]]></programlisting>

			</para>
		</sect2>

		<sect2 id="view-xslt-viewdefinitions">

			<title>Defining the view properties</title> 

            <para>
			    
				The views.properties file (or equivalent xml definition if
				you're using an XML based view resolver as we did in the
				Velocity examples above) looks like this for the one-view
				application that is 'My First Words'..

<programlisting><![CDATA[
home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words
]]></programlisting>

                 Here, you can see how the view is tied in with the HomePage
                 class just written which handles the model domification in
                 the first property '.class'.  The stylesheetLocation property
                 obviously points to the XSLT file which will handle the XML
                 transformation into HTML for us and the final property
                 '.root' is the name that will be used as the root of the XML
                 document.  This gets passed to the HomePage class above in
                 the second parameter to the <literal>createDomNode</literal>
                 method.

			 </para>

			 			
		</sect2>


		<sect2 id="view-xslt-transforming">

			<title>Document transformation</title>

            <para>

			    Finally, we have the XSLT code used for transforming the above
			    document.  As highlighted in the views.properties file, it is
			    called <literal>home.xslt</literal> and it lives in the war
			    file under <literal>WEB-INF/xsl</literal>.

<programlisting><![CDATA[
<?xml version="1.0"?>

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="text/html" omit-xml-declaration="yes"/>

  <xsl:template match="/">	
    <html>
      <head><title>Hello!</title></head>				
      <body>

        <h1>My First Words</h1>
        <xsl:for-each select="wordList/word">
          <xsl:value-of select="."/><br />
        </xsl:for-each> 
				
      </body>
    </html>	
  </xsl:template>
	
</xsl:stylesheet>
]]></programlisting>

			</para>

		</sect2>


		<sect2 id="view-xslt-summary">

			<title>Summary</title> 

            <para>

			    A summary of the files discussed and their location in the WAR
			    file is shown in the simplified WAR structure below.

<programlisting><![CDATA[
ProjectRoot
  |
  +- WebContent
      |
      +- WEB-INF
          |
          +- classes
          |    |
          |    +- xslt
          |    |   |
          |    |   +- HomePageController.class 
          |    |   +- HomePage.class
          |    |
          |    +- views.properties
          |
          +- lib
          |   |
          |   +- spring.jar
          |
          +- xsl
          |   |
          |   +- home.xslt
          |
          +- frontcontroller-servlet.xml

]]></programlisting>

                You will also need to ensure that an XML parser and an XSLT
                engine are available on the classpath.  JDK 1.4 provides them
                by default, and most J2EE containers will also make them
                available by default, but it's a possible source of errors to
                be aware of.
			
			</para>

		</sect2>


	</sect1>



    <sect1 id="view-tapestry">
		<title>Tapestry</title>

		<para>

			intro

		</para>
		
		<sect2 id="view-tapestry-config">

			<title>Configuration</title> 

            <para>

			    config

			</para>
			
		</sect2>


		<sect2 id="view-tapestry-summary">

			<title>Summary</title> 

            <para>

			    summarize files / libs involved
			
			</para>

		</sect2>


	</sect1>


	<sect1 id="view-tiles">
		<title>Tiles</title>

		<para>

			intro

		</para>
		
		<sect2 id="view-tiles-config">

			<title>Configuration</title> 

            <para>

			    config

			</para>
			
		</sect2>


		<sect2 id="view-tiles-summary">

			<title>Summary</title> 

            <para>

			    summarize files / libs involved
			
			</para>

		</sect2>


	</sect1>

</chapter>
