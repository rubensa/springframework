<?xml version="1.0" encoding="UTF-8"?>
<!--$Id$-->
<chapter id="view">
  <title>Integrating view technologies</title>

  <sect1 id="view-introduction">
    <title>Introduction</title>

    <para>One of the areas in which Spring excels is in the separation of view
    technologies from the rest of the MVC framework. For example, deciding to
    use Velocity or XSLT in place of an existing JSP is primarily a matter of
    configuration. This chapter covers the major view technologies that work
    with Spring and touches briefly on how to add new ones. This chapter
    assumes you are already familiar with <xref linkend="mvc-viewresolver" />
    which covers the basics of how views in general are coupled to the MVC
    framework.</para>
  </sect1>

  <sect1 id="view-jsp">
    <title>Using Spring together with JSP &amp; JSTL</title>

    <para>Spring provides a couple of out-of-the-box solutions for JSP and
    JSTL views (which are the most popular ones, incidentally). Using JSP or
    JSTL is done using a normal viewresolver defined in the
    WebApplicationContext. Furthermore, of course you need to write some JSPs
    that will actually render the view. This part describes some of the
    additional features Spring provides to facilitate JSP development.</para>

    <sect2 id="view-jsp-resolver">
      <title>View resolvers</title>

      <para>Just as with any other view technology you're integrating with
      Spring, for JSPs you'll need a view resolver that will resolve your
      views. The most commonly used view resolvers when developing with JSPs
      are the <literal>InternalResourceViewResolver</literal> and the
      <literal>ResourceBundleViewResolver</literal>. Both are declared in the
      WebApplicationContext:</para>

      <programlisting># The ResourceBundleViewResolver:
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;&lt;value&gt;views&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

# And a sample properties file is uses (views.properties in WEB-INF/classes):
welcome.class=org.springframework.web.servlet.view.JstlView
welcome.url=/WEB-INF/jsp/welcome.jsp

productList.class=org.springframework.web.servlet.view.JstlView
productList.url=/WEB-INF/jsp/productlist.jsp</programlisting>

      <para>As you can see, the ResourceBundleViewResolver needs a properties
      file defining the view names mapped to 1) a class and 2) a URL. With a
      ResourceBundleViewResolver you can mix different types of views using
      only one resolver.</para>

      <programlisting>&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
    &lt;property name="viewClass"&gt;&lt;value&gt;org.springframework.web.servlet.view.JstlView&lt;/value&gt;&lt;/property&gt;
    &lt;property name="prefix"&gt;&lt;value&gt;/WEB-INF/jsp/&lt;/value&gt;&lt;/property&gt;
    &lt;property name="suffix"&gt;&lt;value&gt;.jsp&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>The InternalResourceBundleViewResolver can be configured for using
      JSPs as described above. As a best practice, we strongly encourage
      placing your JSP files in a a directory under the WEB-INF directory, so
      there can be no direct access by clients.</para>
    </sect2>

    <sect2 id="view-jsp-jstl">
      <title>'Plain-old' JSPs versus JSTL</title>

      <para>When using Java Standard Tag Library you must use a special view
      class, the <literal>JstlView</literal>, as JSTL needs some preparation
      before things such as the i18N features will work.</para>
    </sect2>

    <sect2 id="view-jsp-tags">
      <title>Additional tags facilitating development</title>

      <para>Spring provides data binding of request parameters to command
      objects as described in earlier chapters. To facilitate the development
      of JSP pages in combination with those data binding features, Spring
      provides a few tags that make things even easier. All Spring tags have
      <emphasis>html escaping</emphasis> features to enable or disable
      escaping of characters.</para>

      <para>The tag library descriptor (TLD) is included in the
      <literal>spring.jar</literal> as well in the distribution itself. More
      information about the individual tags can be found online: <ulink
      url="http://www.springframework.org/docs/taglib/index.html"></ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="view-tiles">
    <title>Using Tiles</title>

    <para>It is possible to integrate Tiles - just as any other view
    technology - in webapplications using Spring. The following describes in a
    broad way how to do this.</para>

    <sect2 id="view-tiles-dependencies">
      <title>Dependencies</title>

      <para>To be able to use Tiles you have to have a couple of additional
      dependencies included in your project. The following is the list of
      dependencies you need.</para>

      <para><itemizedlist spacing="compact">
          <listitem>
            <para><literal>struts version 1.1</literal></para>
          </listitem>

          <listitem>
            <para><literal>commons-beanutils</literal></para>
          </listitem>

          <listitem>
            <para><literal>commons-digester</literal></para>
          </listitem>

          <listitem>
            <para><literal>commons-logging</literal></para>
          </listitem>

          <listitem>
            <para><literal>commons-lang</literal></para>
          </listitem>
        </itemizedlist></para>

      <para>The dependencies are all available in the Spring
      distribution.</para>
    </sect2>

    <sect2 id="view-tiles-integrate">
      <title>How to integrate Tiles</title>

      <para>To be able to use Tiles, you have to configure it using files
      containing definitions (for basic information on definitions and other
      Tiles concepts, please have a look at <ulink
      url="http://jakarta.apache.org/struts"></ulink>. In Spring this is done
      using the <literal>TilesConfigurer</literal>. Have a look at the
      following piece of example ApplicationContext configuration:
      <programlisting>&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles.TilesConfigurer"&gt;
    &lt;property name="factoryClass"&gt;
        &lt;value&gt;org.apache.struts.tiles.xmlDefinition.I18nFactorySet&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="definitions"&gt;
        &lt;list&gt;
            &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
            &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

      <para>As you can see, there are five files containing definitions, which
      are all located in the WEB-INF/defs directory. At initialization of the
      WebApplicationContext, the files will be loaded and the
      definitionsfactory defined by the
      <literal>factoryClass</literal>-property is initialized. After that has
      been done, the tiles includes in the definition files can be used as
      views within your Spring webapplication. To be able to use the views you
      have to have a <literal>ViewResolver</literal> just as with any other
      view technology used with Spring. Below you can find two possibilities,
      the <literal>InternalResourceViewResolver</literal> and the
      <literal>ResourceBundleViewResolver</literal>.</para>

      <sect3 id="view-tiles-internal">
        <title><literal>InternalResourceViewResolver</literal></title>

        <para>The InternalResourceViewResolver instantiates the given
        <literal>viewClass</literal> for each view it has to resolve.
        <programlisting>&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
    &lt;property name="requestContextAttribute"&gt;&lt;value&gt;requestContext&lt;/value&gt;&lt;/property&gt;
    &lt;property name="viewClass"&gt;
        &lt;value&gt;org.springframework.web.servlet.view.tiles.TilesView&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
      </sect3>

      <sect3 id="view-tiles-resource">
        <title><literal>ResourceBundleViewResolver</literal></title>

        <para>The ResourceBundleViewResolver has to be provided with a
        property file containing viewnames and viewclasses the resolver can
        use: <programlisting>&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;&lt;value&gt;views&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting></para>

        <para><programlisting>    ...
    welcomeView.class=org.springframework.web.servlet.view.tiles.TilesView
    welcomeView.url=welcome (&lt;b&gt;this is the name of a definition&lt;/b&gt;)
        
    vetsView.class=org.springframework.web.servlet.view.tiles.TilesView
    vetsView.url=vetsView (&lt;b&gt;again, this is the name of a definition&lt;/b&gt;)
        
    findOwnersForm.class=org.springframework.web.servlet.view.JstlView
    findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp
    ...</programlisting> As you can see, when using the
        ResourceBundleViewResolver, you can mix view using different view
        technologies.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="view-velocity">
    <title>Velocity</title>

    <para>Velocity is a view technology developed by the Jakarta Project. More
    information about Velocity can be found at <ulink
    url="http://jakarta.apache.org/velocity">http://jakarta.apache.org/velocity</ulink>.
    This section describes how to integrate the Velocity view technology for
    use with Spring.</para>

    <sect2 id="view-velocity-dependencies">
      <title>Dependencies</title>

      <para>There are two dependency that your web application will need to
      satisfy before working with Velocity, namely that
      <literal>velocity-1.x.x.jar</literal> and
      <literal>commons-collections.jar</literal> need to be available.
      Typically they are included in the <literal>WEB-INF/lib</literal> folder
      where it is guaranteed to be found by a J2EE server and added to the
      classpath for your application. It is of course assumed that you already
      have the <literal>spring.jar</literal> in your
      <literal>WEB-INF/lib</literal> folder too! The latest stable velocity
      jar and commons collections jar are supplied with the Spring framework
      and can be copied from the <literal>/lib/velocity</literal> or
      <literal>/lib/jakarta-commons</literal> directories.</para>
    </sect2>

    <sect2 id="view-velocity-configuration-dispatcher">
      <title>Dispatcher Servlet Context</title>

      <para>The configuration file for your Spring dispatcher servlet (usually
      <literal>WEB-INF/[servletname]-servlet.xml</literal>) will require a
      bean definition for the view resolver. We'll also add a bean here to
      configure the Velocity environment. I've chosen to call my dispatcher
      'frontcontroller' so my config file names reflect this. This example
      uses the convenience <literal>VelocityViewResolver</literal> as it
      offers the simplest configuration. More flexibility when required can be
      obtained from different types of view resolution strategy.</para>

      <para>The following code examples show the two beans in the simplest
      configuration. See the JavaDocs for these classes for more information
      on the various options available.</para>

      <programlisting>&lt;!-- ===========================================================--&gt;
&lt;!-- Velocity configurer.                                       --&gt;
&lt;!-- ===========================================================--&gt;
&lt;!--
  This bean sets up the Velocity environment for us based on a root path for templates.
  Optionally, a properties file can be specified for more control over the Velocity
  environment, but the defaults are pretty sane for file based template loading.
--&gt;
&lt;bean 
    id="velocityConfig" 
    class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"
    singleton="true"&gt;
    &lt;property name="resourceLoaderPath"&gt;&lt;value&gt;/WEB-INF/velocity/&lt;/value&gt;&lt;/property&gt;          
&lt;/bean&gt;

&lt;!-- ===========================================================--&gt;
&lt;!-- View resolver. Required by web framework.                  --&gt;
&lt;!-- ===========================================================--&gt;
&lt;!--
  View resolvers can also be configured with ResourceBundles or XML files.  If you need
  different view resolving based on Locale, you have to use the resource bundle resolver.
--&gt;
&lt;bean 
    id="viewResolver" 
    class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
    &lt;property name="cache"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
    &lt;property name="prefix"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
    &lt;property name="suffix"&gt;&lt;value&gt;.vm&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>
    </sect2>

    <sect2 id="view-velocity-configuration-velocityprops">
      <title>Velocity.properties</title>

      <para>This file is completely optional, but if specified, contains the
      values that are passed to the Velocity runtime in order to configure
      velocity itself. Only a few properties are actually required, but many
      more optional properties are available - see the Velocity docs for more
      information. If you need this file, specify its location on the
      <literal>VelocityConfigurer</literal> bean definition above.</para>

      <sect3 id="view-velocity-template-locations">
        <title>Template Locations</title>

        <para>The most important property values concern the location of the
        Velocity templates themselves. Velocity templates can be loaded from
        the classpath or the file system and there are pros and cons for both.
        Loading from the classpath is entirely portable and will work on all
        target servers, but you may find that the templates clutter your java
        packages (unless you create a new source tree for them). A further
        downside of classpath storage is that during development, changing
        anything in the source tree often causes a refresh of the resource in
        the <literal>WEB-INF/classes</literal> tree and this in turn may cause
        your development server to restart the application (hot-deploying of
        code). This can be irritating. Once most of the development is
        complete though, you could store the templates in a jar file which
        would make them available to the application if this were placed in
        <literal>WEB-INF/lib</literal></para>
      </sect3>

      <sect3 id="view-velocity-example-velocityproperties">
        <title>Example velocity.properties</title>

        <para>This example stores velocity templates on the file system
        somewhere under <literal>WEB-INF</literal> so that they are not
        directly available to the client browsers, but don't cause an
        application restart in development every time you change one. The
        downside is that the target server may not be able to resolve the path
        to these files correctly, particularly if the target server doesn't
        explode WAR modules on the file system. The file method works fine for
        Tomcat 4.1.x/5.x, WebSphere 4.x and WebSphere 5.x. Your mileage may
        vary.</para>

        <programlisting>#
# velocity.properties - example configuration
#


# uncomment the next two lines to load templates from the 
# classpath (i.e. WEB-INF/classes)
#resource.loader=class
#class.resource.loader.class=org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader

# comment the next two lines to stop loading templates from the
# file system
resource.loader=file
file.resource.loader.class=org.apache.velocity.runtime.resource.loader.FileResourceLoader


# additional config for file system loader only.. tell Velocity where the root
# directory is for template loading.  You can define multiple root directories
# if you wish, I just use the one here.  See the text below for a note about
# the ${webapp.root}
file.resource.loader.path=${webapp.root}/WEB-INF/velocity


# caching should be 'true' in production systems, 'false' is a development
# setting only.  Change to 'class.resource.loader.cache=false' for classpath
# loading
file.resource.loader.cache=false

# override default logging to direct velocity messages
# to our application log for example.  Assumes you have 
# defined a log4j.properties file
runtime.log.logsystem.log4j.category=com.mycompany.myapplication </programlisting>
      </sect3>

      <sect3 id="view-velocity-root-markers">
        <title>Web application root marker</title>

        <para>The file resource loader configuration above uses a marker to
        denote the root of the web application on the file system
        <literal>${webapp.root}</literal>. This marker will be translated into
        the actual OS-specific path by the Spring code prior to supplying the
        properties to Velocity. This is what makes the file resource loader
        non-portable in some servers. The actual name of the marker itself can
        be changed if you consider it important by defining a different
        "appRootMarker" for VelocityConfigurer. See the Spring documentation
        for details on how to do this.</para>
      </sect3>

      <sect3 id="view-velocity-alternate-properties">
        <title>Alternative property specifications</title>

        <para>Alternatively, you can specify velocity properties directly in
        the bean definition for the Velocity config bean by replacing the
        "configLocation" property with the following inline
        properties..</para>

        <programlisting>&lt;property name="velocityProperties"&gt;
    &lt;props&gt;
        &lt;prop key="resource.loader"&gt;file&lt;/prop&gt;
        &lt;prop key="file.resource.loader.class"&gt;org.apache.velocity.runtime.resource.loader.FileResourceLoader&lt;/prop&gt;
        &lt;prop key="file.resource.loader.path"&gt;${webapp.root}/WEB-INF/velocity&lt;/prop&gt;
        &lt;prop key="file.resource.loader.cache"&gt;false&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;</programlisting>
      </sect3>
    </sect2>

    <sect2 id="view-velocity-templates">
      <title>Creating the Velocity templates</title>

      <para>Finally, you simply need to create the actual velocity templates.
      We have defined views that reference two templates, mainTemplate.vm and
      secondaryTemplate.vm Both of these files will live in
      <literal>WEB-INF/velocity/</literal> as noted in the Velocity config
      above. If you chose a classpath loader in velocity.properties, these
      files would live in the default package
      (<literal>WEB-INF/classes</literal>), or in a jar file under
      <literal>WEB-INF/lib</literal>. Here's what our<literal>
      /WEB-INF/velocity/firstView.vm</literal> template might look
      like.</para>

      <programlisting>## model objects are set in the controller and referenced
## via bean properties or method names.  See the Velocity 
## docs for info
&lt;html&gt;
    &lt;head&gt;&lt;title&gt;$title&lt;/title&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;This is $title!!&lt;/h1&gt;

        Model Value: $model.value
        Model Method Return Value: $model.getReturnVal()

    &lt;/body&gt;
&lt;/html&gt;</programlisting>

      <para>Now, when your controllers return a ModelAndView with the
      "firstView" set as the view to render, Velocity should kick in with the
      above page.</para>
    </sect2>

    <sect2 id="view-velocity-forms">
      <title>Form Handling</title>

      <para>Spring provides a tag library for use in JSP's that contains
      (amongst other things) a <literal>&lt;spring:bind&gt;</literal> tag.
      This tag primarily enables forms to display the results of failed
      validations from a <literal>Validator</literal> in the web or business
      tier. This behaviour can be simulated with a Velocity macro and some
      additional Spring functionality.</para>

      <sect3 id="view-velocity-validation">
        <title>Validation errors</title>

        <para>The error messages that are actually produced from the
        validation of a form submission can be read from a properties file to
        make them easily maintainable or internationalised. Spring handles
        this elegantly in its own way and you should refer to the MVC tutorial
        or relevant parts of the javadocs for details on how this works. In
        order to gain access to the messages, the
        <literal>RequestContext</literal> object needs to be exposed to your
        Velocity templates in the <literal>VelocityContext</literal>. Amend
        your configurer definition in *-servlet.xml or your individual view
        definitions in views.properties or views.xml file to give a name to
        this attribute (giving it a name is what causes it to be
        exposed)</para>

        <programlisting>&lt;bean 
    id="viewResolver" 
    class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
     &lt;!-- other props omitted --&gt;
    &lt;property name="requestContextAttribute"&gt;&lt;value&gt;rc&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>The example above is based on our earlier example and sets the
        RequestContext attribute name to be rc. All Velocity views that are
        resolved by this bean will now have an additional object available to
        them via the reference <literal>$rc</literal></para>
      </sect3>

      <sect3 id="view-velocity-macrohelper">
        <title>Velocity macro helper</title>

        <para>Next, a velocity macro needs to be defined. It makes sense to
        create this macro in a global macro file since it will be reusable
        across many Velocity templates (html forms). Refer to the Velocity
        documentation for more information on creating macros.</para>

        <para>The code below should go into the file VM_global_library.vm in
        the root directory of your Velocity template location..</para>

        <programlisting>#*
 * showerror
 *
 * display an error for the field name supplied if one exists
 * in the supplied errors object.
 *
 * param $errors the object obtained from RequestContext.getErrors( "formBeanName" )
 * param $field the field name you want to display errors for (if any)
 *
 *#
#macro( showerror $errors $field )
    #if( $errors )
        #if( $errors.getFieldErrors( $field ))
            #foreach($err in $errors.getFieldErrors( $field ))
                &lt;span class="fieldErrorText"&gt;$rc.getMessage($err)&lt;/span&gt;&lt;br /&gt;
            #end
        #end
    #end
#end      </programlisting>
      </sect3>

      <sect3 id="view-velocity-validationmessages">
        <title>Associating error messages with the HTML field</title>

        <para>Finally, in your html forms, you can use code similar to the
        following to display bound error messages for each input field.</para>

        <programlisting>## set the following variable once somewhere at the top of
## the velocity template
#set ($errors=$rc.getErrors("commandBean"))
&lt;html&gt;
...
&lt;form ...&gt;
    &lt;input name="query" value="$!commandBean.query"&gt;&lt;br&gt;
    #showerror($errors "query")
&lt;/form&gt;
...
&lt;/html&gt;        </programlisting>
      </sect3>
    </sect2>

    <sect2 id="view-velocity-summary">
      <title>Summary</title>

      <para>To summarize, this is the tree structure of files discussed in the
      example above. Only a partial tree is shown, some required directories
      are not highlighted here. Incorrect file locations are probably the
      major reason for velocity views not working, with incorrect properties
      in the view definitions a close second.</para>

      <programlisting>ProjectRoot
  |
  +- WebContent
      |
      +- WEB-INF
          |
          +- lib
          |   |
          |   +- velocity-1.3.1.jar
          |   +- spring.jar
          |
          +- velocity
          |   |
          |   +- VM_global_library.vm
          |   +- mainTemplate.vm
          |   +- secondaryTemplate.vm
          |
          +- frontcontroller-servlet.xml
          +- frontcontroller-views.xml
          +- velocity.properties</programlisting>
    </sect2>
  </sect1>

  <sect1 id="view-xslt">
    <title>XSLT Views</title>

    <para>XSLT is a transformation language for XML and is popular as a view
    technology within web applications. XSLT can be a good choice as a view
    technology if your application naturally deals with XML, or if your model
    can easily be converted to XML. The following section shows how to produce
    an XML document as model data and have it transformed with XSLT in a
    Spring application.</para>

    <sect2 id="view-xslt-firstwords">
      <title>My First Words</title>

      <para>This example is a trivial Spring application that creates a list
      of words in the Controller and adds them to the model map. The map is
      returned along with the view name of our XSLT view. See <xref
      linkend="mvc-controller" /> for details of Spring
      <literal>Controller</literal>s. The XSLT view will turn the list of
      words into a simple XML document ready for transformation.</para>

      <sect3 id="view-xslt-beandefs">
        <title>Bean definitions</title>

        <para>Configuration is standard for a simple Spring application. The
        dispatcher servlet config file contains a reference to a
        <literal>ViewResolver</literal>, URL mappings and a single controller
        bean.. <programlisting>&lt;bean id="homeController"class="xslt.HomeController"/&gt; </programlisting>
        ..that implements our word generation 'logic'.</para>
      </sect3>

      <sect3 id="view-xslt-controllercode">
        <title>Standard MVC controller code</title>

        <para>The controller logic is encapsulated in a subclass of
        AbstractController, with the handler method being defined like so..
        <programlisting>protected ModelAndView handleRequestInternal(
    HttpServletRequest req,
    HttpServletResponse resp)
    throws Exception {
        
    Map map = new HashMap();
    List wordList = new ArrayList();
        
    wordList.add("hello");
    wordList.add("world");
       
    map.put("wordList", wordList);
      
    return new ModelAndView("home", map);
} </programlisting></para>

        <para>So far we've done nothing that's XSLT specific. The model data
        has been created in the same way as you would for any other Spring MVC
        application. Depending on the configuration of the application now,
        that list of words could be rendered by JSP/JSTL by having them added
        as request attributes, or they could be handled by Velocity by adding
        the object to the VelocityContext. In order to have XSLT render them,
        they of course have to be converted into an XML document somehow.
        There are software packages available that will automatically 'domify'
        an object graph, but within Spring, you have complete flexibility to
        create the DOM from your model in any way you choose. This prevents
        the transformation of XML playing too great a part in the structure of
        your model data which is a danger when using tools to manage the
        domification process.</para>
      </sect3>

      <sect3 id="view-xslt-subclassing">
        <title>Convert the model data to XML</title>

        <para>In order to create a DOM document from our list of words or any
        other model data, we subclass
        <literal>org.springframework.web.servlet.view.xslt.AbstractXsltView</literal>.
        In doing so, we must implement the abstract method
        <literal>createDomNode()</literal>. The first parameter passed to this
        method is our model Map. Here's the complete listing of the HomePage
        class in our trivial word application - it uses JDOM to build the XML
        document before converting it to the required W3C Node, but this is
        simply because I find JDOM (and Dom4J) easier API's to handle than the
        W3C API. <programlisting>
package xslt;

// imports omitted for brevity

public class HomePage extends AbstractXsltView {

    protected Node createDomNode( 
        Map model, String rootName, HttpServletRequest req, HttpServletResponse res
    ) throws Exception {
        
        org.jdom.Document doc = new org.jdom.Document();
        Element root = new Element(rootName);
        doc.setRootElement(root);

        List words = (List) model.get("wordList");
        for (Iterator it = words.iterator(); it.hasNext();) {
            String nextWord = (String) it.next();
            Element e = new Element("word");
            e.setText(nextWord);
            root.addContent(e);
        }

        // convert JDOM doc to a W3C Node and return
        return new DOMOutputter().output( doc );
    }

}</programlisting></para>

        <sect4>
          <title>Adding stylesheet parameters</title>

          <para>A series of parameter name/value pairs can optionally be
          defined by your subclass which will be added to the transformation
          object. The parameter names must match those defined in your XSLT
          template declared with <literal>&lt;xsl:param
          name="myParam"&gt;defaultValue&lt;/xsl:param&gt;</literal> To
          specify the parameters, override the method
          <literal>getParameters()</literal> from AbstractXsltView and return
          a <literal>Map</literal> of the name/value pairs.</para>
        </sect4>

        <sect4 id="view-xslt-formathelper">
          <title>Formatting dates and currency</title>

          <para>Unlike JSTL and Velocity, XSLT has relatively poor support for
          locale based currency and date formatting. In recognition of the
          fact, Spring provides a helper class that you can use from within
          your <literal>createDomNode()</literal> methods to get such support.
          See the javadocs for
          <literal>org.springframework.web.servlet.view.xslt.FormatHelper</literal></para>
        </sect4>
      </sect3>

      <sect3 id="view-xslt-viewdefinitions">
        <title>Defining the view properties</title>

        <para>The views.properties file (or equivalent xml definition if
        you're using an XML based view resolver as we did in the Velocity
        examples above) looks like this for the one-view application that is
        'My First Words'.. <programlisting>home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words</programlisting> Here, you can see how the view is tied in
        with the HomePage class just written which handles the model
        domification in the first property '.class'. The stylesheetLocation
        property obviously points to the XSLT file which will handle the XML
        transformation into HTML for us and the final property '.root' is the
        name that will be used as the root of the XML document. This gets
        passed to the HomePage class above in the second parameter to the
        <literal>createDomNode</literal> method.</para>
      </sect3>

      <sect3 id="view-xslt-transforming">
        <title>Document transformation</title>

        <para>Finally, we have the XSLT code used for transforming the above
        document. As highlighted in the views.properties file, it is called
        <literal>home.xslt</literal> and it lives in the war file under
        <literal>WEB-INF/xsl</literal>. <programlisting>&lt;?xml version="1.0"?&gt;

&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:output method="text/html" omit-xml-declaration="yes"/&gt;

    &lt;xsl:template match="/"&gt;
        &lt;html&gt;
            &lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;

                &lt;h1&gt;My First Words&lt;/h1&gt;
                &lt;xsl:for-each select="wordList/word"&gt;
                    &lt;xsl:value-of select="."/&gt;&lt;br /&gt;
                &lt;/xsl:for-each&gt; 

            &lt;/body&gt;
        &lt;/html&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</programlisting></para>
      </sect3>
    </sect2>

    <sect2 id="view-xslt-summary">
      <title>Summary</title>

      <para>A summary of the files discussed and their location in the WAR
      file is shown in the simplified WAR structure below. <programlisting>ProjectRoot
  |
  +- WebContent
      |
      +- WEB-INF
          |
          +- classes
          |    |
          |    +- xslt
          |    |   |
          |    |   +- HomePageController.class 
          |    |   +- HomePage.class
          |    |
          |    +- views.properties
          |
          +- lib
          |   |
          |   +- spring.jar
          |
          +- xsl
          |   |
          |   +- home.xslt
          |
          +- frontcontroller-servlet.xml</programlisting> You will also need
      to ensure that an XML parser and an XSLT engine are available on the
      classpath. JDK 1.4 provides them by default, and most J2EE containers
      will also make them available by default, but it's a possible source of
      errors to be aware of.</para>
    </sect2>
  </sect1>

  <sect1 id="view-document">
    <title>Document views (PDF/Excel)</title>

    <sect2 id="view-document-intro">
      <title>Introduction</title>

      <para>Returning an HTML page isn't always the best way for the user to
      view the model output, and Spring makes it simple to generate a PDF
      document or an Excel spreadsheet dynamically from the model data. The
      document is the view and will be streamed from the server with the
      correct content type to (hopefully) enable the client PC to run their
      spreadsheet or PDF viewer application in response.</para>

      <para>In order to use Excel views, you need to add the 'poi' library to
      your classpath, and for PDF generation, the iText.jar. Both are included
      in the main Spring distribution.</para>
    </sect2>

    <sect2 id="view-document-config">
      <title>Configuration and setup</title>

      <para>Document based views are handled in an almost identical fashion to
      XSLT views, and the following sections build upon the previous one by
      demonstrating how the same controller used in the XSLT example is
      invoked to render the same model as both a PDF document and an Excel
      spreadsheet (which can also be viewed or manipulated in Open
      Office).</para>

      <sect3 id="view-document-configviews">
        <title>Document view definitions</title>

        <para>Firstly, let's amend the views.properties file (or xml
        equivalent) and add a simple view definition for both document types.
        The entire file now looks like this with the XSLT view shown from
        earlier.. <programlisting>home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words

xl.class=excel.HomePage

pdf.class=pdf.HomePage</programlisting> <emphasis>If you want to start with a
        template spreadsheet to add your model data to, specify the location
        as the 'url' property in the view definition</emphasis></para>
      </sect3>

      <sect3 id="view-document-configcontroller">
        <title>Controller code</title>

        <para>The controller code we'll use remains exactly the same from the
        XSLT example earlier other than to change the name of the view to use.
        Of course, you could be clever and have this selected based on a URL
        parameter or some other logic - proof that Spring really is very good
        at decoupling the views from the controllers!</para>
      </sect3>

      <sect3 id="view-document-configsubclasses">
        <title>Subclassing for Excel views</title>

        <para>Exactly as we did for the XSLT example, we'll subclass suitable
        abstract classes in order to implement custom behaviour in generating
        our output documents. For Excel, this involves writing a subclass of
        <literal>org.springframework.web.servlet.view.document.AbstractExcelView</literal>
        and implementing the <literal>buildExcelDocument</literal></para>

        <para>Here's the complete listing for our Excel view which displays
        the word list from the model map in consecutive rows of the first
        column of a new spreadsheet.. <programlisting>package excel;

// imports omitted for brevity

public class HomePage extends AbstractExcelView {

    protected void buildExcelDocument(
        Map model,
        HSSFWorkbook wb,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
    
        HSSFSheet sheet;
        HSSFRow sheetRow;
        HSSFCell cell;

        // Go to the first sheet
        // getSheetAt: only if wb is created from an existing document
        //sheet = wb.getSheetAt( 0 );
        sheet = wb.createSheet("Spring");
        sheet.setDefaultColumnWidth((short)12);

        // write a text at A1
        cell = getCell( sheet, 0, 0 );
        setText(cell,"Spring-Excel test");

        List words = (List ) model.get("wordList");
        for (int i=0; i &lt; words.size(); i++) {
            cell = getCell( sheet, 2+i, 0 );
            setText(cell, (String) words.get(i));

        }
    }
}</programlisting></para>

        <para>If you now amend the controller such that it returns
        <literal>xl</literal> as the name of the view (<literal>return new
        ModelAndView("xl", map);</literal>) and run your application again,
        you should find that the Excel spreadsheet is created and downloaded
        automagically when you request the same page as before.</para>
      </sect3>

      <sect3 id="view-document-configsubclasspdf">
        <title>Subclassing for PDF views</title>

        <para>The PDF version of the word list is even simpler. This time, the
        class extends
        <literal>org.springframework.web.servlet.view.document.AbstractPdfView</literal>
        and implements the <literal>buildPdfDocument()</literal> method as
        follows.. <programlisting>package pdf;

// imports omitted for brevity

public class PDFPage extends AbstractPdfView {

    protected void buildPdfDocument(
        Map model,
        Document doc,
        PdfWriter writer,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
        
        List words = (List) model.get("wordList");
        
        for (int i=0; i&lt;words.size(); i++)
            doc.add( new Paragraph((String) words.get(i)));
    
    }
}</programlisting> Once again, amend the controller to return the
        <literal>pdf</literal> view with a <literal>return new
        ModelAndView("pdf", map);</literal> and reload the URL in your
        application. This time a PDF document should appear listing each of
        the words in the model map.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="view-tapestry">
    <title>Tapestry</title>

    <para>Tapestry is a powerful, component-oriented web application framework
    from Apache's Jakarta project (<ulink
    url="http://jakarta.apache.org/tapestry"></ulink>). Spring Framework is a
    powerful J2EE application framework which is built around the concept of a
    lightweight container. While Spring has its own powerful web ui layer,
    there are a number of unique advantages to building a J2EE application
    using a combination of Tapestry for the web ui, and the Spring container
    for the lower layers. This document attempts to detail a few best
    practices for combining these two frameworks. It is expected that you are
    relatively familiar with both Tapestry and Spring Framework basics, so
    they will not be explained here. General introductory documentation for
    both Tapestry and Spring Framework are available on their respective web
    sites.</para>

    <sect2 id="view-tapestry-architecture">
      <title>Architecture</title>

      <para>A typical layered J2EE application built with Tapestry and Spring
      will consist of a top UI layer built with Tapestry, and a number of
      lower layers, hosted out of one or more Spring Application
      Contexts.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>User Interface Layer:</emphasis></para>

          <para>- concerned with the user interface</para>

          <para>- contains some application logic</para>

          <para>- provided by Tapestry</para>

          <para>- aside from providing UI via Tapestry, code in this layer
          does its work via objects which implement interfaces from the
          Service Layer. The actual objects which implement these service
          layer interfaces are obtained from a Spring Application
          Context.</para>
        </listitem>

        <listitem>
          <para><emphasis>Service Layer:</emphasis></para>

          <para>- application specific 'service' code</para>

          <para>- works with domain objects, and uses the Mapper API to get
          those domain objects into and out of some sort of repository
          (database)</para>

          <para>- hosted in one or more Spring contexts</para>

          <para>- code in this layer manipulates objects in the domain model,
          in an application specific fashion. It does its work via other code
          in this layer, and via the Mapper API. An object in this layer is
          given the specific mapper implementations it needs to work with, via
          the Spring context.</para>

          <para>- since code in this layer is hosted in the Spring context, it
          may be transactionally wrapped by the Spring context, as opposed to
          managing its own transactions</para>
        </listitem>

        <listitem>
          <para><emphasis>Domain Model:</emphasis></para>

          <para>- domain specific object hierarchy, which deals with data and
          logic specific to this domain</para>

          <para>- although the domain object hierarchy is built with the idea
          that it is persisted somehow and makes some general concessions to
          this (for example, bidirectional relationships), it generally has no
          knowledge of other layers. As such, it may be tested in isolation,
          and used with different mapping implementations for production vs.
          testing.</para>

          <para>- these objects may be standalone, or used in conjunction with
          a Spring application context to take advantage of some of the
          benefits of the context, e.g., isolation, inversion of control,
          different strategy implementations, etc.</para>
        </listitem>

        <listitem>
          <para><emphasis>Data Source Layer:</emphasis></para>

          <para>- Mapper API (also called Data Access Objects): an API used to
          persist the domain model to a repository of some sort (generally a
          DB, but could be the filesystem, memeory, etc.)</para>

          <para>- Mapper API implementations: one or more specific
          implementations of the Mapper API, for example, a Hibernate-specific
          mapper, a JDO-specific mapper, JDBC-specific mapper, or a memory
          mapper.</para>

          <para>- mapper implementations live in one or more Spring
          Application Contexts. A service layer object is given the mapper
          objects it needs to work with via the context.</para>
        </listitem>

        <listitem>
          <para><emphasis>Database, filesystem, or other
          repositories:</emphasis></para>

          <para>- objects in the domain model are stored into one or more
          repositories via one or more mapper implementations</para>

          <para>- a repository may be very simpe (e.g. filesystem), or may
          have its own representation of the data from the domain model (i.e.
          a schema in a db). It does not know about other layers
          howerver.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="view-tapestry-implementation">
      <title>Implementation</title>

      <para>The only real question (which needs to be addressed by this
      document), is how Tapestry pages get access to service implementations,
      which are simply beans defined in an instance of the Spring Application
      Context.</para>

      <sect3 id="view-tapestry-context">
        <title>Sample application context</title>

        <para>Assume we have the following simple Application Context
        definition, in xml form: <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
        "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
 
&lt;beans&gt;
 
    &lt;!-- ========================= GENERAL DEFINITIONS ========================= --&gt;
 
    &lt;!-- ========================= PERSISTENCE DEFINITIONS ========================= --&gt;
 
    &lt;!-- the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;&lt;value&gt;java:DefaultDS&lt;/value&gt;&lt;/property&gt;
        &lt;property name="resourceRef"&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!-- define a Hibernate Session factory via a Spring LocalSessionFactoryBean --&gt;
    &lt;bean id="hibSessionFactory" 
        class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource"&gt;&lt;ref bean="dataSource"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!--
     - Defines a transaction manager for usage in business or data access objects.
     - No special treatment by the context, just a bean instance available as reference
     - for business objects that want to handle transactions, e.g. via TransactionTemplate.
     --&gt;
    &lt;bean id="transactionManager" 
        class="org.springframework.transaction.jta.JtaTransactionManager"&gt;
    &lt;/bean&gt;
 
    &lt;bean id="mapper" 
        class="com.whatever.dataaccess.mapper.hibernate.MapperImpl"&gt;
        &lt;property name="sessionFactory"&gt;&lt;ref bean="hibSessionFactory"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
   
    &lt;!-- ========================= BUSINESS DEFINITIONS ========================= --&gt;
 
    &lt;!-- AuthenticationService, including tx interceptor --&gt;
    &lt;bean id="authenticationServiceTarget"
        class="com.whatever.services.service.user.AuthenticationServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="authenticationService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="authenticationServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
    &lt;!-- UserService, including tx interceptor --&gt;
    &lt;bean id="userServiceTarget"
        class="com.whatever.services.service.user.UserServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="userService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="userServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
 &lt;/beans&gt;</programlisting> Inside the Tapestry application, we need to
        load this application context, and allow Tapestry pages to get the
        authenticationService and userService beans, which implement the
        AuthenticationService and UserService interfaces, respectively.</para>
      </sect3>

      <sect3 id="view-tapestry-appctx">
        <title>Obtaining beans in Tapestry pages</title>

        <para>At this point, the application context is available to a web
        application by calling Spring's static utility function
        <literal>WebApplicationContextUtils.getApplicationContext(servletContext)</literal>,
        where servletContext is the standard <literal>ServletContext</literal>
        from the J2EE Servlet specification. As such, one simple mechanism for
        a page to get an instance of the UserService, for example, would be
        with code such as: <programlisting>    WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(
        getRequestCycle().getRequestContext().getServlet().getServletContext());
    UserService userService = (UserService) appContext.getBean("userService");
    ... some code which uses UserService</programlisting> This mechanism does
        work. It can be made a lot less verbose by encapsulating most of the
        functionality in a method in the base class for the page or component.
        However, in some respects it goes against the Inversion of Control
        approach which Spring encourages, which is being used in other layers
        of this app, in that ideally you would like the page to not have to
        ask the context for a specific bean by name, and in fact, the page
        would ideally not know about the context at all.</para>

        <para>Luckily, there is a mechanism to allow this. We rely upon the
        fact that Tapestry already has a mechanism to declaratively add
        properties to a page, and it is in fact the preferred approach to
        manage all properties on a page in this declarative fashion, so that
        Tapestry can properly manage their lifecycle as part of the page and
        component lifecycle.</para>
      </sect3>

      <sect3 id="view-tapestry-exposeappctx">
        <title>Exposing the application context to Tapestry</title>

        <para>First we need to make the <literal>ApplicationContext</literal>
        available to the Tapestry page or Component without having to have the
        <literal>ServletContext</literal>; this is because at the stage in the
        page's/component's lifecycle when we need to access the
        <literal>ApplicationContext</literal>, the
        <literal>ServletContext</literal> won't be easily available to the
        page, so we can't use
        <literal>WebApplicationContextUtils.getApplicationContext(servletContext)</literal>
        directly. One way is by defining a custom version of the Tapestry
        IEngine which exposes this for us: <programlisting>package com.whatever.web.xportal;
...
import ...
...
public class MyEngine extends org.apache.tapestry.engine.BaseEngine {
 
    public static final String APPLICATION_CONTEXT_KEY = "appContext";
 
    /**
     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)
     */
    protected void setupForRequest(RequestContext context) {
        super.setupForRequest(context);
     
        // insert ApplicationContext in global, if not there
        Map global = (Map) getGlobal();
        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);
        if (ac == null) {
            ac = WebApplicationContextUtils.getWebApplicationContext(
                context.getServlet().getServletContext()
            );
            global.put(APPLICATION_CONTEXT_KEY, ac);
        }
    }
}</programlisting>This engine class places the Spring Application Context as
        an attribute called "appContext" in this Tapestry app's 'Global'
        object. Make sure to register the fact that this special IEngine
        instance should be used for this Tapestry application, with an entry
        in the Tapestry application definition file. For example:
        <programlisting>file: xportal.application:
 
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE application PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
&lt;application
    name="Whatever xPortal"
    engine-class="com.whatever.web.xportal.MyEngine"&gt;
&lt;/application&gt;</programlisting></para>
      </sect3>

      <sect3 id="view-tapestry-componentdefs">
        <title>Component definition files</title>

        <para>Now in our page or component definition file (*.page or *.jwc),
        we simply add property-specification elements to grab the beans we
        need out of the ApplicationContext, and create page or component
        properties for them. For example: <programlisting>    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;</programlisting> The OGNL expression
        inside the property-specification specifies the initial value for the
        property, as a bean obtained from the context. The entire page
        definition might look like this: <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE page-specification PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
     
&lt;page-specification class="com.whatever.web.xportal.pages.Login"&gt;
 
    &lt;property-specification name="username" type="java.lang.String"/&gt;
    &lt;property-specification name="password" type="java.lang.String"/&gt;
    &lt;property-specification name="error" type="java.lang.String"/&gt;
    &lt;property-specification name="callback" type="org.apache.tapestry.callback.ICallback" persistent="yes"/&gt;
    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;
   
    &lt;bean name="delegate" class="com.whatever.web.xportal.PortalValidationDelegate"/&gt;
 
    &lt;bean name="validator" class="org.apache.tapestry.valid.StringValidator" lifecycle="page"&gt;
        &lt;set-property name="required" expression="true"/&gt;
        &lt;set-property name="clientScriptingEnabled" expression="true"/&gt;
    &lt;/bean&gt;
 
    &lt;component id="inputUsername" type="ValidField"&gt;
        &lt;static-binding name="displayName" value="Username"/&gt;
        &lt;binding name="value" expression="username"/&gt;
        &lt;binding name="validator" expression="beans.validator"/&gt;
    &lt;/component&gt;
   
    &lt;component id="inputPassword" type="ValidField"&gt;
        &lt;binding name="value" expression="password"/&gt;
       &lt;binding name="validator" expression="beans.validator"/&gt;
       &lt;static-binding name="displayName" value="Password"/&gt;
       &lt;binding name="hidden" expression="true"/&gt;
    &lt;/component&gt;
 
&lt;/page-specification&gt;</programlisting></para>
      </sect3>

      <sect3 id="view-tapestry-getters">
        <title>Adding abstract accessors</title>

        <para>Now in the Java class definition for the page or component
        itself, all we need to do is add an abstract getter method for the
        properties we have defined, to access them. When the page or component
        is actually loaded by Tapestry, it performs runtime code
        instrumentation on the classfile to add the properties which have been
        defined, and hook up the abstract getter methods to the newly created
        fields. For example: <programlisting>    // our UserService implementation; will come from page definition
    public abstract UserService getUserService();
    // our AuthenticationService implementation; will come from page definition
    public abstract AuthenticationService getAuthenticationService();</programlisting>
        For completeness, the entire Java class, for a login page in this
        example, might look like this: <programlisting>package com.whatever.web.xportal.pages;
 
/**
 *  Allows the user to login, by providing username and password.
 *  After succesfully logging in, a cookie is placed on the client browser
 *  that provides the default username for future logins (the cookie
 *  persists for a week).
 */
public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
 
    /** the key under which the authenticated user object is stored in the visit as */
    public static final String USER_KEY = "user";
   
    /**
     * The name of a cookie to store on the user's machine that will identify
     * them next time they log in.
     **/
    private static final String COOKIE_NAME = Login.class.getName() + ".username";  
    private final static int ONE_WEEK = 7 * 24 * 60 * 60;
 
    // --- attributes
 
    public abstract String getUsername();
    public abstract void setUsername(String username);
 
    public abstract String getPassword();
    public abstract void setPassword(String password);
 
    public abstract ICallback getCallback();
    public abstract void setCallback(ICallback value);
    
    public abstract UserService getUserService();
 
    public abstract AuthenticationService getAuthenticationService();
 
    // --- methods
 
    protected IValidationDelegate getValidationDelegate() {
        return (IValidationDelegate) getBeans().getBean("delegate");
    }
 
    protected void setErrorField(String componentId, String message) {
        IFormComponent field = (IFormComponent) getComponent(componentId);
        IValidationDelegate delegate = getValidationDelegate();
        delegate.setFormComponent(field);
        delegate.record(new ValidatorException(message));
    }
 
    /**
     *  Attempts to login. 
     *
     *  &lt;p&gt;If the user name is not known, or the password is invalid, then an error
     *  message is displayed.
     *
     **/
    public void attemptLogin(IRequestCycle cycle) {
     
        String password = getPassword();
 
        // Do a little extra work to clear out the password.
 
        setPassword(null);
        IValidationDelegate delegate = getValidationDelegate();
 
        delegate.setFormComponent((IFormComponent) getComponent("inputPassword"));
        delegate.recordFieldInputValue(null);
 
        // An error, from a validation field, may already have occured.
 
        if (delegate.getHasErrors())
            return;
 
        try {
            User user = getAuthenticationService().login(getUsername(), getPassword());
           loginUser(user, cycle);
        }
        catch (FailedLoginException ex) {
            this.setError("Login failed: " + ex.getMessage());
            return;
        }
    }
 
    /**
     *  Sets up the {@link User} as the logged in user, creates
     *  a cookie for their username (for subsequent logins),
     *  and redirects to the appropriate page, or
     *  a specified page).
     *
     **/
    public void loginUser(User user, IRequestCycle cycle) {
     
        String username = user.getUsername();
 
        // Get the visit object; this will likely force the
        // creation of the visit object and an HttpSession.
 
        Map visit = (Map) getVisit();
        visit.put(USER_KEY, user);
 
        // After logging in, go to the MyLibrary page, unless otherwise
        // specified.
 
        ICallback callback = getCallback();
 
        if (callback == null)
            cycle.activate("Home");
        else
            callback.performCallback(cycle);
 
        // I've found that failing to set a maximum age and a path means that
        // the browser (IE 5.0 anyway) quietly drops the cookie.
 
        IEngine engine = getEngine();
        Cookie cookie = new Cookie(COOKIE_NAME, username);
        cookie.setPath(engine.getServletPath());
        cookie.setMaxAge(ONE_WEEK);
 
        // Record the user's username in a cookie
 
        cycle.getRequestContext().addCookie(cookie);
 
        engine.forgetPage(getPageName());
    }
   
    public void pageBeginRender(PageEvent event) {
        if (getUsername() == null)
            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));
    }
}</programlisting></para>
      </sect3>
    </sect2>

    <sect2 id="view-tapestry-summary">
      <title>Summary</title>

      <para>In this example, we've managed to allow service beans defined in
      the Spring <literal>ApplicationContext</literal> to be provided to the
      page in a declarative fashion. The page class does not know where the
      service implementations are coming from, and in fact it is easy to slip
      in another implementation, for example, during testing. This inversion
      of control is one of the prime goals and benefits of the Spring
      Framework, and we have managed to extend it all the way up the J2EE
      stack in this Tapestry application.</para>
    </sect2>
  </sect1>
</chapter>