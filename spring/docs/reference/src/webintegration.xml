<?xml version="1.0" encoding="UTF-8"?>
<chapter id="webintegration">
	<title>Integrating with other web frameworks</title>
	<sect1 id="intro">
		<title>Introduction</title>
		<para>Spring can be easily integrated into any Java-based web framework.  
    All you need to do is to declare the 
    <ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderListener.html">
    <literal>ContextLoaderListener</literal></ulink> in your <literal>web.xml</literal> and use a 
    <emphasis>contextConfigLocation</emphasis> &lt;context-param&gt; to set which context files 
    to load.</para>
		<para>The &lt;context-param&gt;: <programlisting>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;</programlisting></para>
		<para>The &lt;listener&gt;: <programlisting>&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</programlisting></para>
		<para><emphasis role="bold">NOTE:</emphasis> Listeners were added to 
    the Servlet API in version 2.3. If you have a Servlet 2.2 container, you can 
    use the <ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderServlet.html">
    <literal>ContextLoaderServlet</literal></ulink> to achieve this same functionality.</para>
		<para>If you don't specify the <emphasis>contextConfigLocation</emphasis> 
    context parameter, the <literal>ContextLoaderListener</literal> will look 
    for a <emphasis>/WEB-INF/applicationContext.xml</emphasis> file to load. 
    Once the context files are loaded, Spring creates a 
    <ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/WebApplicationContext.html">
    <literal>WebApplicationContext</literal></ulink> object based on the bean 
    definitions and puts it into the <literal>ServletContext</literal>.</para>
		<para>All Java web frameworks are built on top of the Servlet API, so you 
    can use the following code to get the <literal>ApplicationContext</literal> 
    that Spring created.</para>
    <programlisting>WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</programlisting>
		<para>The <ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/support/WebApplicationContextUtils.html">
    <literal>WebApplicationContextUtils</literal></ulink> class is for convenience, 
    so you don't have to remember the name of the <literal>ServletContext</literal> 
    attribute. Its <emphasis>getWebApplicationContext()</emphasis> method will 
    return null if an object doesn't exist under the 
    <literal>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</literal> 
    key. Rather than risk getting NullPointerExceptions in your application, 
    it's better to use the <emphasis>getRequiredWebApplicationContext()</emphasis>
    method. This method throws an Exception when the 
    <emphasis>ApplicationContext</emphasis> is missing.</para>
		<para>Once you have a reference to the <literal>WebApplicationContext</literal>, 
    you can retrieve beans by their name or type. Most developers retrieve beans 
    by name, then cast them to one of their implemented interfaces.</para>
		<para>Fortunately, most of the frameworks in this section have simpler 
    ways of looking up beans. Not only do they make it easy to get beans from 
    the <literal>BeanFactory</literal>, but they also allow you to use dependency 
    injection on their controllers. Each framework section has more detail on 
    its specific integration strategies.</para>
	</sect1>	
	<sect1 id="jsf">
		<title>JavaServer Faces</title>
		<para>JavaServer Faces (JSF) is a component-based, event-driven web framework. 
    According to Sun Microsystem's <ulink url="http://java.sun.com/j2ee/javaserverfaces/overview.html">
    JSF Overview</ulink>, JSF technology includes:</para>
   		<itemizedlist>
   			<listitem>
   				<para>A set of APIs for representing UI components and managing 
                their state, handling events and input validation, defining page 
                navigation, and supporting internationalization and accessibility.
   				</para>
   			</listitem>
   			<listitem>
   				<para>A JavaServer Pages (JSP) custom tag library for expressing a 
                JavaServer Faces interface within a JSP page.</para>
   			</listitem>
   		</itemizedlist>
		<sect2 id="jsf-delegatingvariableresolver">
			<title>DelegatingVariableResolver</title>
			<para>The easiest way to integrate your Spring middle-tier with your JSF 
	    web layer is to  use the 
	    <ulink url="http://www.springframework.org/docs/api/org/springframework/web/jsf/DelegatingVariableResolver.html">
		<literal>DelegatingVariableResolver</literal></ulink> class. To configure 
	    this variable resolver in your application, you'll need to edit your 
	    <emphasis>faces-context.xml</emphasis>. After the opening <literal>
		&lt;faces-config&gt;</literal> element, add an <literal>&lt;application&gt;</literal> 
	    element and a <literal>&lt;variable-resolver&gt;</literal> element within it.  
	    The value of the variable resolver should reference Spring's 
	    <literal>DelegatingVariableResolver</literal>: <programlisting>&lt;faces-config&gt;
	    &lt;application&gt;
	        &lt;variable-resolver&gt;org.springframework.web.jsf.DelegatingVariableResolver&lt;/variable-resolver&gt;
	        &lt;locale-config&gt;
	            &lt;default-locale&gt;en&lt;/default-locale&gt;
	            &lt;supported-locale&gt;en&lt;/supported-locale&gt;
	            &lt;supported-locale&gt;es&lt;/supported-locale&gt;
	        &lt;/locale-config&gt;
	        &lt;message-bundle&gt;messages&lt;/message-bundle&gt;
	    &lt;/application&gt;</programlisting></para>
			<para>By specifying Spring's variable resolver, you can configure Spring 
	    beans as managed properties of your managed beans. The 
	    <literal>DelegatingVariableResolver</literal> will first delegate value lookups 
	    to the default resolver of the underlying JSF implementation, and then to 
	    Spring's root <literal>WebApplicationContext</literal>. This allows you to 
	    easily inject dependencies into your JSF-managed beans.</para>
			<para>Managed beans are defined in your <literal>faces-config.xml</literal> 
	    file. Below is an example where #{userManager} is a bean that's retrieved 
	    from Spring's <literal>BeanFactory</literal>. <programlisting>&lt;managed-bean&gt;
	    &lt;managed-bean-name&gt;userList&lt;/managed-bean-name&gt;
	    &lt;managed-bean-class&gt;com.whatever.jsf.UserList&lt;/managed-bean-class&gt;
	    &lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;
	    &lt;managed-property&gt;
	        &lt;property-name&gt;userManager&lt;/property-name&gt;
	        &lt;value&gt;#{userManager}&lt;/value&gt;
	    &lt;/managed-property&gt;
	&lt;/managed-bean&gt;</programlisting></para>
			<para>The <literal>DelegatingVariableResolver</literal> is the recommended 
	    strategy for integrating JSF and Spring. If you're looking for more robust 
	    integration features, you might take a look at the 
		<ulink url="http://jsf-spring.sourceforge.net/">JSF-Spring</ulink> project.</para>
		</sect2>
		<sect2 id="jsf-facescontextutils">
			<title>FacesContextUtils</title>
			<para>A custom VariableResolver works well when mapping your properties 
	    to beans in <emphasis>faces-config.xml</emphasis>, but at times you may need to grab a bean explicitly.  The 
		<ulink url="http://www.springframework.org/docs/api/org/springframework/web/jsf/FacesContextUtils.html">
		<literal>FacesContextUtils</literal></ulink> class makes this easy. It's similar to 
		<literal>WebApplicationContextUtils</literal>, except that it takes a <literal>FacesContext</literal> 
		parameter rather than a <literal>ServletContext</literal> parameter.
		<programlisting>ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());</programlisting></para>
		</sect2>
	</sect1>
	<sect1 id="struts">
		<title>Struts</title>
		<para><ulink url="http://struts.apache.org">Struts</ulink> is the
    <emphasis>de facto</emphasis> web framework for Java applications, mainly 
    because it was one of the first to be released (June 2001). Invented by 
    Craig McClanahan, Struts is an open source project hosted by the Apache 
    Software Foundation. At the time, it greatly simplified the JSP/Servlet 
    programming paradigm and won over many developers who were using 
    proprietary frameworks. It simplified the programming model, it was open 
    source, and it had a large community, which allowed the project to grow 
    and become popular among Java web developers.</para>
		<para>To integrate your Struts application with Spring, you have two 
    options:</para>
		<itemizedlist>
   			<listitem>
   				<para>Configure Spring to manage your Actions as beans, using the 
					<literal>ContextLoaderPlugin</literal>, and set their 
					dependencies in a Spring context file.</para>
   			</listitem>
   			<listitem>
   				<para>Subclass Spring's <emphasis>ActionSupport</emphasis> 
					classes and grab your Spring-managed beans explicitly using 
					a <emphasis>getWebApplicationContext()</emphasis> method.</para>
   			</listitem>
   		</itemizedlist>
		<sect2 id="struts-contextloaderplugin">
			<title>ContextLoaderPlugin</title>
			<para>The <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/ContextLoaderPlugIn.html">
        <literal>ContextLoaderPlugin</literal></ulink> is a Struts 1.1+ plug-in 
        that loads a Spring context file for the Struts 
        <literal>ActionServlet</literal>. This context refers to the root 
        <literal>WebApplicationContext</literal> (loaded by the 
        <literal>ContextLoaderListener</literal>) as its parent. The default 
        name of the context file is the name of the mapped servlet, plus 
        <emphasis>-servlet.xml</emphasis>. If <literal>ActionServlet</literal> 
        is defined in web.xml as 
        <literal>&lt;servlet-name&gt;action&lt;/servlet-name&gt;</literal>, the 
        default is <emphasis>/WEB-INF/action-servlet.xml</emphasis>.</para>
			<para>To configure this plug-in, add the following XML to the plug-ins section near the bottom of your 
			<emphasis>struts-config.xml</emphasis> file:
			<programlisting>&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"/&gt;</programlisting></para>
			<para>The location of the context configuration files can be 
            customized using the "contextConfigLocation" property.
            <programlisting>&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"&gt;
    &lt;set-property property="contextConfigLocation"
        value="/WEB-INF/action-servlet.xml.xml,
               /WEB-INF/applicationContext.xml"/&gt;
&lt;/plug-in&gt;</programlisting></para>
			<para>It is possible to use this plugin to load all your context files, which can be useful when using testing tools
        like StrutsTestCase.  StrutsTestCase's <literal>MockStrutsTestCase</literal> won't initialize Listeners on startup
        so putting all your context files in the plugin is a workaround.  A 
        <ulink url="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1088866&amp;group_id=39190&amp;atid=424562">
        bug has been filed</ulink> for this issue.</para>
			<para>After configuring this plug-in in <emphasis>struts-config.xml</emphasis>, you can configure your Action to be 
			managed by Spring. Spring 1.1.3 provides two ways to do this:</para>
			<itemizedlist>
	   			<listitem>
	   				<para>Override Struts' default <literal>RequestProcessor</literal>
					with Spring's <literal>DelegatingRequestProcessor</literal>.</para>
	   			</listitem>
	   			<listitem>
	   				<para>Use the <emphasis>DelegatingActionProxy</emphasis> class 
					in the type attribute of your <literal>&lt;action-mapping&gt;</literal>.</para>
	   			</listitem>
	   		</itemizedlist>
			<para>Both of these methods allow you to manage your Actions and 
        their dependencies in the <emphasis>action-context.xml</emphasis> file. 
        The bridge between the Action in <emphasis>struts-config.xml</emphasis> 
        and <emphasis>action-servlet.xml</emphasis> is built with the 
        action-mapping's "path" and the bean's "name". If you have the 
        following in your <emphasis>struts-config.xml</emphasis> file:
		<programlisting>&lt;action path="/users" .../&gt;</programlisting></para>
			<para>You must define that Action's bean with the "/users" name in
        <emphasis>action-servlet.xml</emphasis>:
			<programlisting>&lt;bean name="/users" .../&gt;</programlisting></para>
			<sect3 id="struts-delegatingrequestprocessor">
				<title>DelegatingRequestProcessor</title>
				<para>To configure the <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingRequestProcessor.html">
	        <literal>DelegatingRequestProcessor</literal></ulink> in your 
	        <emphasis>struts-config.xml</emphasis> file, override the "processorClass" 
	        property in the &lt;controller&gt; element. These lines follow the 
	        &lt;action-mapping&gt; element. <programlisting>&lt;controller&gt;
	    &lt;set-property property="processorClass" 
	        value="org.springframework.web.struts.DelegatingRequestProcessor"/&gt;
	&lt;/controller&gt;</programlisting></para>
				<para>After adding this setting, your Action will automatically be 
	        looked up in Spring's context file, no matter what the type. In fact, 
	        you don't even need to specify a type. Both of the following snippets 
	        will work: <programlisting>&lt;action path="/user" type="com.whatever.struts.UserAction"/&gt;		
	&lt;action path="/user"/&gt;</programlisting></para>
				<para>If you're using Struts' <emphasis>modules</emphasis> feature, 
	        your bean names must contain the module prefix. For example, an action 
	        defined as <literal>&lt;action path="/user"/&gt;</literal> with module 
	        prefix "admin" requires a bean name with <literal>&lt;bean name="/admin/user"/&gt;</literal>.</para>
				<para><emphasis role="bold">NOTE:</emphasis> If you're using Tiles 
	        in your Struts application, you must configure your &lt;controller&gt;
	        with the <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingTilesRequestProcessor.html">
			<literal>DelegatingTilesRequestProcessor</literal></ulink>.</para>
			</sect3>
			<sect3 id="struts-delegatingactionproxy">
				<title>DelegatingActionProxy</title>
				<para>If you have a custom <literal>RequestProcessor</literal> and 
	        can't use the <literal>DelegatingTilesRequestProcessor</literal>, you can 
	        use the <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingActionProxy.html">
	        <literal>DelegatingActionProxy</literal></ulink> as the type in your 
	        action-mapping. <programlisting>&lt;action path="/user" type="org.springframework.web.struts.DelegatingActionProxy"
	    name="userForm" scope="request" validate="false" parameter="method"&gt;
	        &lt;forward name="list" path="/userList.jsp"/&gt;
	        &lt;forward name="edit" path="/userForm.jsp"/&gt;
	&lt;/action&gt;</programlisting></para>
				<para>The bean definition in <emphasis>action-servlet.xml</emphasis> 
	        remains the same, whether you use a custom <literal>RequestProcessor</literal>
	        or the <literal>DelegatingActionProxy</literal>.</para>
				<para>If you define your Action in a context file, the full feature set of Spring's
          bean container will be available for it: dependency injection as well as the option
          to instantiate a new Action instance for each request. To activate the latter,
          add <emphasis>singleton="false"</emphasis> to your Action's bean definition.
		<programlisting>&lt;bean name="/user" <emphasis>singleton="false"</emphasis> autowire="byName"
	    class="org.example.web.UserAction"/&gt;</programlisting></para>
			</sect3>
		</sect2>
		<sect2 id="struts-actionsupport">
			<title>ActionSupport Classes</title>
			<para>As previously mentioned, you can retrieve the
        <literal>WebApplicationContext</literal> from the <literal>ServletContext</literal>
        using the WebApplicationContextUtils class. An easier way is to extend
        Spring's Action classes for Struts. For example, instead of subclassing
        Struts' Action class, you can subclass Spring's
        <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html">
        <literal>ActionSupport</literal></ulink> class.</para>
			<para>The <literal>ActionSupport</literal> class provides additional
        convenience methods, like <emphasis>getWebApplicationContext()</emphasis>.
        Below is an example of how you might use this in an Action:
		<programlisting>public class UserAction extends DispatchActionSupport {

    public ActionForward execute(ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response)
            throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("entering 'delete' method...");
        }

        WebApplicationContext ctx = getWebApplicationContext();
        UserManager mgr = (UserManager) ctx.getBean("userManager");

        // talk to manager for business logic

        return mapping.findForward("success");
    }
}</programlisting></para>
		<para>Spring includes subclasses for all of the standard Struts Actions
    - the Spring versions merely have <emphasis>Support</emphasis> appended to
    the name:

    <itemizedlist spacing="compact">
	<listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html"><literal>ActionSupport</literal></ulink>,</para></listitem>
    <listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DispatchActionSupport.html"><literal>DispatchActionSupport</literal></ulink>,</para></listitem>
    <listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/LookupDispatchActionSupport.html"><literal>LookupDispatchActionSupport</literal></ulink> and</para></listitem>
    <listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/MappingDispatchActionSupport.html"><literal>MappingDispatchActionSupport</literal></ulink>.</para></listitem>
    </itemizedlist>
    </para>

		<para>The recommended strategy is to use the approach that best suits
    your project. Subclassing makes your code more readable, and you know
    exactly how your dependencies are resolved. However, using the
    <literal>ContextLoaderPlugin</literal> allow you to easily add new
    dependencies in your context XML file. Either way, Spring provides some
    nice options for integrating the two frameworks.</para>
		</sect2>
	</sect1>
	<sect1 id="view-tapestry">
		<title>Tapestry</title>
		<para>Tapestry is a powerful, component-oriented web application framework
    from Apache's Jakarta project (<ulink url="http://jakarta.apache.org/tapestry"/>). While Spring has its
    own powerful web ui layer, there are a number of unique advantages to
    building a J2EE application using a combination of Tapestry for the web
    ui, and the Spring container for the lower layers. This document attempts
    to detail a few best practices for combining these two frameworks. It is
    expected that you are relatively familiar with both Tapestry and Spring
    Framework basics, so they will not be explained here. General introductory
    documentation for both Tapestry and Spring Framework are available on
    their respective web sites.</para>
		<sect2 id="view-tapestry-architecture">
			<title>Architecture</title>
			<para>A typical layered J2EE application built with Tapestry and Spring
      will consist of a top UI layer built with Tapestry, and a number of
      lower layers, hosted out of one or more Spring Application
      Contexts.</para>
			<itemizedlist>
				<listitem>
					<para>
						<emphasis>User Interface Layer:</emphasis>
					</para>
					<para>- concerned with the user interface</para>
					<para>- contains some application logic</para>
					<para>- provided by Tapestry</para>
					<para>- aside from providing UI via Tapestry, code in this layer
          does its work via objects which implement interfaces from the
          Service Layer. The actual objects which implement these service
          layer interfaces are obtained from a Spring Application
          Context.</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Service Layer:</emphasis>
					</para>
					<para>- application specific 'service' code</para>
					<para>- works with domain objects, and uses the Mapper API to get
          those domain objects into and out of some sort of repository
          (database)</para>
					<para>- hosted in one or more Spring contexts</para>
					<para>- code in this layer manipulates objects in the domain model,
          in an application specific fashion. It does its work via other code
          in this layer, and via the Mapper API. An object in this layer is
          given the specific mapper implementations it needs to work with, via
          the Spring context.</para>
					<para>- since code in this layer is hosted in the Spring context, it
          may be transactionally wrapped by the Spring context, as opposed to
          managing its own transactions</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Domain Model:</emphasis>
					</para>
					<para>- domain specific object hierarchy, which deals with data and
          logic specific to this domain</para>
					<para>- although the domain object hierarchy is built with the idea
          that it is persisted somehow and makes some general concessions to
          this (for example, bidirectional relationships), it generally has no
          knowledge of other layers. As such, it may be tested in isolation,
          and used with different mapping implementations for production vs.
          testing.</para>
					<para>- these objects may be standalone, or used in conjunction with
          a Spring application context to take advantage of some of the
          benefits of the context, e.g., isolation, inversion of control,
          different strategy implementations, etc.</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Data Source Layer:</emphasis>
					</para>
					<para>- Mapper API (also called Data Access Objects): an API used to
          persist the domain model to a repository of some sort (generally a
          DB, but could be the filesystem, memory, etc.)</para>
					<para>- Mapper API implementations: one or more specific
          implementations of the Mapper API, for example, a Hibernate-specific
          mapper, a JDO-specific mapper, JDBC-specific mapper, or a memory
          mapper.</para>
					<para>- mapper implementations live in one or more Spring
          Application Contexts. A service layer object is given the mapper
          objects it needs to work with via the context.</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Database, filesystem, or other
          repositories:</emphasis>
					</para>
					<para>- objects in the domain model are stored into one or more
          repositories via one or more mapper implementations</para>
					<para>- a repository may be very simple (e.g. filesystem), or may
          have its own representation of the data from the domain model (i.e.
          a schema in a db). It does not know about other layers
          howerver.</para>
				</listitem>
			</itemizedlist>
		</sect2>
		<sect2 id="view-tapestry-implementation">
			<title>Implementation</title>
			<para>The only real question (which needs to be addressed by this
      document), is how Tapestry pages get access to service implementations,
      which are simply beans defined in an instance of the Spring Application
      Context.</para>
			<sect3 id="view-tapestry-context">
				<title>Sample application context</title>
				<para>Assume we have the following simple Application Context
        definition, in xml form: <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
        "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
 
&lt;beans&gt;
 
    &lt;!-- ========================= GENERAL DEFINITIONS ========================= --&gt;
 
    &lt;!-- ========================= PERSISTENCE DEFINITIONS ========================= --&gt;
 
    &lt;!-- the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;&lt;value&gt;java:DefaultDS&lt;/value&gt;&lt;/property&gt;
        &lt;property name="resourceRef"&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!-- define a Hibernate Session factory via a Spring LocalSessionFactoryBean --&gt;
    &lt;bean id="hibSessionFactory" 
        class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource"&gt;&lt;ref bean="dataSource"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!--
     - Defines a transaction manager for usage in business or data access objects.
     - No special treatment by the context, just a bean instance available as reference
     - for business objects that want to handle transactions, e.g. via TransactionTemplate.
     --&gt;
    &lt;bean id="transactionManager" 
        class="org.springframework.transaction.jta.JtaTransactionManager"&gt;
    &lt;/bean&gt;
 
    &lt;bean id="mapper" 
        class="com.whatever.dataaccess.mapper.hibernate.MapperImpl"&gt;
        &lt;property name="sessionFactory"&gt;&lt;ref bean="hibSessionFactory"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
   
    &lt;!-- ========================= BUSINESS DEFINITIONS ========================= --&gt;
 
    &lt;!-- AuthenticationService, including tx interceptor --&gt;
    &lt;bean id="authenticationServiceTarget"
        class="com.whatever.services.service.user.AuthenticationServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="authenticationService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="authenticationServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
    &lt;!-- UserService, including tx interceptor --&gt;
    &lt;bean id="userServiceTarget"
        class="com.whatever.services.service.user.UserServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="userService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="userServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
 &lt;/beans&gt;</programlisting> Inside the Tapestry application, we need to
        load this application context, and allow Tapestry pages to get the
        authenticationService and userService beans, which implement the
        AuthenticationService and UserService interfaces, respectively.</para>
			</sect3>
			<sect3 id="view-tapestry-appctx">
				<title>Obtaining beans in Tapestry pages</title>
				<para>At this point, the application context is available to a web
        application by calling Spring's static utility function
        <literal>WebApplicationContextUtils.getApplicationContext(servletContext)</literal>,
        where servletContext is the standard <literal>ServletContext</literal>
        from the J2EE Servlet specification. As such, one simple mechanism for
        a page to get an instance of the UserService, for example, would be
        with code such as: <programlisting>    WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(
        getRequestCycle().getRequestContext().getServlet().getServletContext());
    UserService userService = (UserService) appContext.getBean("userService");
    ... some code which uses UserService</programlisting> This mechanism does
        work. It can be made a lot less verbose by encapsulating most of the
        functionality in a method in the base class for the page or component.
        However, in some respects it goes against the Inversion of Control
        approach which Spring encourages, which is being used in other layers
        of this app, in that ideally you would like the page to not have to
        ask the context for a specific bean by name, and in fact, the page
        would ideally not know about the context at all.</para>
				<para>Luckily, there is a mechanism to allow this. We rely upon the
        fact that Tapestry already has a mechanism to declaratively add
        properties to a page, and it is in fact the preferred approach to
        manage all properties on a page in this declarative fashion, so that
        Tapestry can properly manage their lifecycle as part of the page and
        component lifecycle.</para>
			</sect3>
			<sect3 id="view-tapestry-exposeappctx">
				<title>Exposing the application context to Tapestry</title>
				<para>First we need to make the <literal>ApplicationContext</literal>
        available to the Tapestry page or Component without having to have the
        <literal>ServletContext</literal>; this is because at the stage in the
        page's/component's lifecycle when we need to access the
        <literal>ApplicationContext</literal>, the
        <literal>ServletContext</literal> won't be easily available to the
        page, so we can't use
        <literal>WebApplicationContextUtils.getApplicationContext(servletContext)</literal>
        directly. One way is by defining a custom version of the Tapestry
        IEngine which exposes this for us: <programlisting>package com.whatever.web.xportal;
...
import ...
...
public class MyEngine extends org.apache.tapestry.engine.BaseEngine {
 
    public static final String APPLICATION_CONTEXT_KEY = "appContext";
 
    /**
     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)
     */
    protected void setupForRequest(RequestContext context) {
        super.setupForRequest(context);
     
        // insert ApplicationContext in global, if not there
        Map global = (Map) getGlobal();
        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);
        if (ac == null) {
            ac = WebApplicationContextUtils.getWebApplicationContext(
                context.getServlet().getServletContext()
            );
            global.put(APPLICATION_CONTEXT_KEY, ac);
        }
    }
}</programlisting>This engine class places the Spring Application Context as
        an attribute called "appContext" in this Tapestry app's 'Global'
        object. Make sure to register the fact that this special IEngine
        instance should be used for this Tapestry application, with an entry
        in the Tapestry application definition file. For example:
        <programlisting>file: xportal.application:
 
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE application PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
&lt;application
    name="Whatever xPortal"
    engine-class="com.whatever.web.xportal.MyEngine"&gt;
&lt;/application&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="view-tapestry-componentdefs">
				<title>Component definition files</title>
				<para>Now in our page or component definition file (*.page or *.jwc),
        we simply add property-specification elements to grab the beans we
        need out of the ApplicationContext, and create page or component
        properties for them. For example: <programlisting>    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;</programlisting> The OGNL expression
        inside the property-specification specifies the initial value for the
        property, as a bean obtained from the context. The entire page
        definition might look like this: <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE page-specification PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
     
&lt;page-specification class="com.whatever.web.xportal.pages.Login"&gt;
 
    &lt;property-specification name="username" type="java.lang.String"/&gt;
    &lt;property-specification name="password" type="java.lang.String"/&gt;
    &lt;property-specification name="error" type="java.lang.String"/&gt;
    &lt;property-specification name="callback" type="org.apache.tapestry.callback.ICallback" persistent="yes"/&gt;
    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;
   
    &lt;bean name="delegate" class="com.whatever.web.xportal.PortalValidationDelegate"/&gt;
 
    &lt;bean name="validator" class="org.apache.tapestry.valid.StringValidator" lifecycle="page"&gt;
        &lt;set-property name="required" expression="true"/&gt;
        &lt;set-property name="clientScriptingEnabled" expression="true"/&gt;
    &lt;/bean&gt;
 
    &lt;component id="inputUsername" type="ValidField"&gt;
        &lt;static-binding name="displayName" value="Username"/&gt;
        &lt;binding name="value" expression="username"/&gt;
        &lt;binding name="validator" expression="beans.validator"/&gt;
    &lt;/component&gt;
   
    &lt;component id="inputPassword" type="ValidField"&gt;
        &lt;binding name="value" expression="password"/&gt;
       &lt;binding name="validator" expression="beans.validator"/&gt;
       &lt;static-binding name="displayName" value="Password"/&gt;
       &lt;binding name="hidden" expression="true"/&gt;
    &lt;/component&gt;
 
&lt;/page-specification&gt;</programlisting>
				</para>
			</sect3>
			<sect3 id="view-tapestry-getters">
				<title>Adding abstract accessors</title>
				<para>Now in the Java class definition for the page or component
        itself, all we need to do is add an abstract getter method for the
        properties we have defined, to access them. When the page or component
        is actually loaded by Tapestry, it performs runtime code
        instrumentation on the classfile to add the properties which have been
        defined, and hook up the abstract getter methods to the newly created
        fields. For example: <programlisting>    // our UserService implementation; will come from page definition
    public abstract UserService getUserService();
    // our AuthenticationService implementation; will come from page definition
    public abstract AuthenticationService getAuthenticationService();</programlisting>
        For completeness, the entire Java class, for a login page in this
        example, might look like this: <programlisting>package com.whatever.web.xportal.pages;
 
/**
 *  Allows the user to login, by providing username and password.
 *  After successfully logging in, a cookie is placed on the client browser
 *  that provides the default username for future logins (the cookie
 *  persists for a week).
 */
public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
 
    /** the key under which the authenticated user object is stored in the visit as */
    public static final String USER_KEY = "user";
   
    /**
     * The name of a cookie to store on the user's machine that will identify
     * them next time they log in.
     **/
    private static final String COOKIE_NAME = Login.class.getName() + ".username";  
    private final static int ONE_WEEK = 7 * 24 * 60 * 60;
 
    // --- attributes
 
    public abstract String getUsername();
    public abstract void setUsername(String username);
 
    public abstract String getPassword();
    public abstract void setPassword(String password);
 
    public abstract ICallback getCallback();
    public abstract void setCallback(ICallback value);
    
    public abstract UserService getUserService();
 
    public abstract AuthenticationService getAuthenticationService();
 
    // --- methods
 
    protected IValidationDelegate getValidationDelegate() {
        return (IValidationDelegate) getBeans().getBean("delegate");
    }
 
    protected void setErrorField(String componentId, String message) {
        IFormComponent field = (IFormComponent) getComponent(componentId);
        IValidationDelegate delegate = getValidationDelegate();
        delegate.setFormComponent(field);
        delegate.record(new ValidatorException(message));
    }
 
    /**
     *  Attempts to login. 
     *
     *  &lt;p&gt;If the user name is not known, or the password is invalid, then an error
     *  message is displayed.
     *
     **/
    public void attemptLogin(IRequestCycle cycle) {
     
        String password = getPassword();
 
        // Do a little extra work to clear out the password.
 
        setPassword(null);
        IValidationDelegate delegate = getValidationDelegate();
 
        delegate.setFormComponent((IFormComponent) getComponent("inputPassword"));
        delegate.recordFieldInputValue(null);
 
        // An error, from a validation field, may already have occurred.
 
        if (delegate.getHasErrors())
            return;
 
        try {
            User user = getAuthenticationService().login(getUsername(), getPassword());
           loginUser(user, cycle);
        }
        catch (FailedLoginException ex) {
            this.setError("Login failed: " + ex.getMessage());
            return;
        }
    }
 
    /**
     *  Sets up the {@link User} as the logged in user, creates
     *  a cookie for their username (for subsequent logins),
     *  and redirects to the appropriate page, or
     *  a specified page).
     *
     **/
    public void loginUser(User user, IRequestCycle cycle) {
     
        String username = user.getUsername();
 
        // Get the visit object; this will likely force the
        // creation of the visit object and an HttpSession.
 
        Map visit = (Map) getVisit();
        visit.put(USER_KEY, user);
 
        // After logging in, go to the MyLibrary page, unless otherwise
        // specified.
 
        ICallback callback = getCallback();
 
        if (callback == null)
            cycle.activate("Home");
        else
            callback.performCallback(cycle);
 
        // I've found that failing to set a maximum age and a path means that
        // the browser (IE 5.0 anyway) quietly drops the cookie.
 
        IEngine engine = getEngine();
        Cookie cookie = new Cookie(COOKIE_NAME, username);
        cookie.setPath(engine.getServletPath());
        cookie.setMaxAge(ONE_WEEK);
 
        // Record the user's username in a cookie
 
        cycle.getRequestContext().addCookie(cookie);
 
        engine.forgetPage(getPageName());
    }
   
    public void pageBeginRender(PageEvent event) {
        if (getUsername() == null)
            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));
    }
}</programlisting>
				</para>
			</sect3>
		</sect2>
		<sect2 id="view-tapestry-summary">
			<title>Summary</title>
			<para>In this example, we've managed to allow service beans defined in
      the Spring <literal>ApplicationContext</literal> to be provided to the
      page in a declarative fashion. The page class does not know where the
      service implementations are coming from, and in fact it is easy to slip
      in another implementation, for example, during testing. This inversion
      of control is one of the prime goals and benefits of the Spring
      Framework, and we have managed to extend it all the way up the J2EE
      stack in this Tapestry application.</para>
		</sect2>
	</sect1>
	<sect1 id="webwork">
		<title>WebWork</title>
		<para><ulink url="http://www.opensymphony.com/webwork">WebWork</ulink>
    is a web framework designed with simplicity in mind. It's built on top of 
    <ulink url="http://www.opensymphony.com/xwork">XWork</ulink>, which is a 
    generic command framework. XWork also has an IoC container, but it isn't 
    as full-featured as Spring and won't be covered in this section. WebWork 
    controllers are called Actions, mainly because they must implement the 
    <ulink url="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/Action.html">
    <literal>Action</literal></ulink> interface. The 
    <ulink url="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ActionSupport.html">
    <literal>ActionSupport</literal></ulink> class implements this interface, 
    and it is most common parent class for WebWork actions.</para>
		<para>WebWork maintains its own Spring integration project, located on 
    java.net in the <ulink url="https://xwork-optional.dev.java.net/">
    xwork-optional</ulink> project. Currently, three options are available for 
    integrating WebWork with Spring:</para>
		<itemizedlist>
			<listitem>
				<para><emphasis role="bold">SpringObjectFactory</emphasis>: 
            override XWork's default 
            <ulink url="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ObjectFactory.html">
            <literal>ObjectFactory</literal></ulink> so XWork will look for 
            Spring beans in the root <literal>WebApplicationContext</literal>.</para>
			</listitem>
			<listitem>
				<para><emphasis role="bold">ActionAutowiringInterceptor:</emphasis> 
            use an interceptor to  automatically wire an Action's dependencies 
            as they're created.</para>
			</listitem>
			<listitem>
				<para><emphasis role="bold">SpringExternalReferenceResolver:</emphasis> 
            look up Spring beans based on the name defined in an &lt;external-ref&gt; 
            element of an &lt;action&gt; element.</para>
			</listitem>
		</itemizedlist>
		<para>All of these strategies are explained in further detail in 
    <ulink url="http://wiki.opensymphony.com/display/WW/WebWork+2+Spring+Integration">
    WebWork's Documentation</ulink>.</para>
	</sect1>
</chapter>
