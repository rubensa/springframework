<?xml version="1.0" encoding="UTF-8"?>
<chapter id="webintegration">
	<title>Integrating with other web frameworks</title>
	<section id="intro">
		<title>Introduction</title>
		<para>
			Spring can be easily integrated into any Java-based web framework. All you need to do
			is to declare the
			<ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderListener.html"><classname>ContextLoaderListener</classname></ulink>
			in your <literal>web.xml</literal> file and use an <literal>contextConfigLocation</literal>
			&lt;context-param&gt; to set which context files to load.
		</para>
		<para>
			Find below the &lt;context-param&gt; configuration:
		</para>
		<programlisting><![CDATA[<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/applicationContext*.xml</param-value>
</context-param>]]></programlisting>
		<para>
			Find below the &lt;listener&gt; configuration:
		</para>
		<programlisting><![CDATA[<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>]]></programlisting>
		<note>
			<para>
				Listeners were added to the Servlet API in version 2.3. If you have a Servlet 2.2
				container, you can use the
				<ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderServlet.html"><classname>ContextLoaderServlet</classname></ulink>
				to achieve this same functionality.
			</para>
		</note>
		<para>
			If you don't specify the <literal>contextConfigLocation</literal> 
			context parameter, the <classname>ContextLoaderListener</classname> will look 
			for a file called <literal>/WEB-INF/applicationContext.xml</literal> to load. 
			Once the context files are loaded, Spring creates a
			<ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/WebApplicationContext.html"><classname>WebApplicationContext</classname></ulink>
			object based on the bean definitions and puts it into the <interface>ServletContext</interface>.
		</para>
		<para>
			All Java web frameworks are built on top of the Servlet API, so you can use the following
			code to get the <interface>ApplicationContext</interface> that Spring created.
		</para>
		<programlisting><![CDATA[WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);]]></programlisting>
		<para>
			The <ulink url="http://www.springframework.org/docs/api/org/springframework/web/context/support/WebApplicationContextUtils.html"><classname>WebApplicationContextUtils</classname></ulink>
			class is for convenience, so you don't have to remember the name of the
			<interface>ServletContext</interface> attribute. Its <emphasis>getWebApplicationContext()</emphasis>
			method will return <literal>null</literal> if an object doesn't exist under the
			<literal>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</literal> key. Rather
			than risk getting <classname>NullPointerExceptions</classname> in your application, it's
			better to use the <literal>getRequiredWebApplicationContext()</literal> method. This
			method throws an exception when the <interface>ApplicationContext</interface> is missing.
		</para>
		<para>
			Once you have a reference to the <classname>WebApplicationContext</classname>, 
			you can retrieve beans by their name or type. Most developers retrieve beans 
			by name, then cast them to one of their implemented interfaces.
		</para>
		<para>
			Fortunately, most of the frameworks in this section have simpler 
			ways of looking up beans. Not only do they make it easy to get beans from 
			a Spring container, but they also allow you to use dependency 
			injection on their controllers. Each framework section has more detail on 
			its specific integration strategies.
		</para>
	</section>	
	<section id="jsf">
		<title>JavaServer Faces</title>
		<para>
			JavaServer Faces (JSF) is a component-based, event-driven web framework. 
			According to Sun Microsystem's
			<ulink url="http://java.sun.com/j2ee/javaserverfaces/overview.html">JSF Overview</ulink>,
			JSF technology includes:
		</para>
   		<itemizedlist>
   			<listitem>
   				<para>
   					A set of APIs for representing UI components and managing 
					their state, handling events and input validation, defining page 
					navigation, and supporting internationalization and accessibility.
   				</para>
   			</listitem>
   			<listitem>
   				<para>
   					A JavaServer Pages (JSP) custom tag library for expressing a 
					JavaServer Faces interface within a JSP page.
				</para>
   			</listitem>
   		</itemizedlist>
		<section id="jsf-delegatingvariableresolver">
			<title>DelegatingVariableResolver</title>
			<para>
				The easiest way to integrate your Spring middle-tier with your JSF 
				web layer is to use the 
				<ulink url="http://www.springframework.org/docs/api/org/springframework/web/jsf/DelegatingVariableResolver.html">
				<classname>DelegatingVariableResolver</classname></ulink> class. To configure 
				this variable resolver in your application, you'll need to edit your 
				<emphasis>faces-context.xml</emphasis>. After the opening <literal>
				&lt;faces-config&gt;</literal> element, add an <literal>&lt;application&gt;</literal> 
				element and a <literal>&lt;variable-resolver&gt;</literal> element within it.  
				The value of the variable resolver should reference Spring's 
				<classname>DelegatingVariableResolver</classname>:
			</para>
			<programlisting><![CDATA[<faces-config>
  <application>
	  <variable-resolver>org.springframework.web.jsf.DelegatingVariableResolver</variable-resolver>
	  <locale-config>
	    <default-locale>en</default-locale>
	    <supported-locale>en</supported-locale>
	    <supported-locale>es</supported-locale>
	  </locale-config>
	  <message-bundle>messages</message-bundle>
	</application>
</faces-config>]]></programlisting>
			<para>
				By specifying Spring's variable resolver, you can configure Spring 
				beans as managed properties of your managed beans. The 
				<classname>DelegatingVariableResolver</classname> will first delegate value
				lookups to the default resolver of the underlying JSF implementation, and
				then to Spring's root <classname>WebApplicationContext</classname>. This
				allows you to easily inject dependencies into your JSF-managed beans.
			</para>
			<para>
				Managed beans are defined in your <literal>faces-config.xml</literal> 
				file. Below is an example where #{userManager} is a bean that's retrieved 
				from Spring's <interface>BeanFactory</interface>.
			</para>
			<programlisting><![CDATA[<managed-bean>
  <managed-bean-name>userList</managed-bean-name>
	<managed-bean-class>com.whatever.jsf.UserList</managed-bean-class>
  <managed-bean-scope>request</managed-bean-scope>
  <managed-property>
    <property-name>userManager</property-name>
    <value>#{userManager}</value>
  </managed-property>
</managed-bean>]]></programlisting>
			<para>
				The <classname>DelegatingVariableResolver</classname> is the recommended 
				strategy for integrating JSF and Spring. If you're looking for more robust 
				integration features, you might take a look at the 
				<ulink url="http://jsf-spring.sourceforge.net/">JSF-Spring</ulink> project.
			</para>
		</section>
		<section id="jsf-facescontextutils">
			<title>FacesContextUtils</title>
			<para>
				A custom <interfacename>VariableResolver</interfacename> works well when mapping
				your properties to beans in <emphasis>faces-config.xml</emphasis>, but at times
				you may need to grab a bean explicitly.  The
				<ulink url="http://www.springframework.org/docs/api/org/springframework/web/jsf/FacesContextUtils.html">
				<classname>FacesContextUtils</classname></ulink> class makes this easy. It's
				similar to <classname>WebApplicationContextUtils</classname>, except that it
				takes a <classname>FacesContext</classname> parameter rather than a
				<interface>ServletContext</interface> parameter.
			</para>
			<programlisting><![CDATA[ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());]]></programlisting>
		</section>
	</section>
	<section id="struts">
		<title>Struts</title>
		<para>
			<ulink url="http://struts.apache.org">Struts</ulink> is the
			<emphasis>de facto</emphasis> web framework for Java applications, mainly 
			because it was one of the first to be released (June 2001). Invented by 
			Craig McClanahan, Struts is an open source project hosted by the Apache 
			Software Foundation. At the time, it greatly simplified the JSP/Servlet 
			programming paradigm and won over many developers who were using 
			proprietary frameworks. It simplified the programming model, it was open 
			source, and it had a large community, which allowed the project to grow 
			and become popular among Java web developers.
		</para>
		<para>
			To integrate your Struts application with Spring, you have two options:
		</para>
		<itemizedlist>
   			<listitem>
   				<para>
   					Configure Spring to manage your Actions as beans, using the 
					<classname>ContextLoaderPlugin</classname>, and set their 
					dependencies in a Spring context file.
				</para>
   			</listitem>
   			<listitem>
   				<para>
   					Subclass Spring's <classname>ActionSupport</classname> 
					classes and grab your Spring-managed beans explicitly using 
					a <emphasis>getWebApplicationContext()</emphasis> method.
				</para>
   			</listitem>
   		</itemizedlist>
		<section id="struts-contextloaderplugin">
			<title>ContextLoaderPlugin</title>
			<para>
				The <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/ContextLoaderPlugIn.html"><classname>ContextLoaderPlugin</classname></ulink>
				is a Struts 1.1+ plug-in that loads a Spring context file for the Struts 
				<classname>ActionServlet</classname>. This context refers to the root 
				<classname>WebApplicationContext</classname> (loaded by the 
				<classname>ContextLoaderListener</classname>) as its parent. The default 
				name of the context file is the name of the mapped servlet, plus 
				<emphasis>-servlet.xml</emphasis>. If <classname>ActionServlet</classname> 
				is defined in web.xml as 
				<literal>&lt;servlet-name&gt;action&lt;/servlet-name&gt;</literal>, the 
				default is <emphasis>/WEB-INF/action-servlet.xml</emphasis>.
			</para>
			<para>
				To configure this plug-in, add the following XML to the plug-ins section near
				the bottom of your <emphasis>struts-config.xml</emphasis> file:
			</para>
			<programlisting><![CDATA[<plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"/>]]></programlisting>
			<para>
				The location of the context configuration files can be customized using the
				<literal>contextConfigLocation</literal> property.
            </para>
            <programlisting><![CDATA[<plug-in className="org.springframework.web.struts.ContextLoaderPlugIn">
  <set-property property="contextConfigLocation"
      value="/WEB-INF/action-servlet.xml.xml,/WEB-INF/applicationContext.xml"/>
</plug-in>]]></programlisting>
			<para>
				It is possible to use this plugin to load all your context files, which can be
				useful when using testing tools like StrutsTestCase. StrutsTestCase's
				<classname>MockStrutsTestCase</classname> won't initialize Listeners on startup
				so putting all your context files in the plugin is a workaround. (A 
				<ulink url="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1088866&amp;group_id=39190&amp;atid=424562">
				bug has been filed</ulink> for this issue, but has been closed as a 'Wont Fix').
			</para>
			<para>
				After configuring this plug-in in <emphasis>struts-config.xml</emphasis>, you can
				configure your <classname>Action</classname> to be managed by Spring. Spring (1.1.3+)
				provides two ways to do this:
			</para>
			<itemizedlist>
	   			<listitem>
	   				<para>
	   					Override Struts' default <classname>RequestProcessor</classname>
						with Spring's <classname>DelegatingRequestProcessor</classname>.
						</para>
	   			</listitem>
	   			<listitem>
	   				<para>
	   					Use the <classname>DelegatingActionProxy</classname> class 
						in the <literal>type</literal> attribute of your
						<literal>&lt;action-mapping&gt;</literal>.
					</para>
	   			</listitem>
	   		</itemizedlist>
			<para>
				Both of these methods allow you to manage your Actions and 
				their dependencies in the <emphasis>action-context.xml</emphasis> file. 
				The bridge between the Action in <emphasis>struts-config.xml</emphasis> 
				and <emphasis>action-servlet.xml</emphasis> is built with the 
				action-mapping's "path" and the bean's "name". If you have the 
				following in your <emphasis>struts-config.xml</emphasis> file:
			</para>
			<programlisting><![CDATA[<action path="/users" .../>]]></programlisting>
			<para>
				You must define that Action's bean with the "/users" name in
				<emphasis>action-servlet.xml</emphasis>:
			</para>
			<programlisting><![CDATA[<bean name="/users" .../>]]></programlisting>
			<section id="struts-delegatingrequestprocessor">
				<title>DelegatingRequestProcessor</title>
				<para>
					To configure the <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingRequestProcessor.html">
					<literal>DelegatingRequestProcessor</literal></ulink> in your 
					<emphasis>struts-config.xml</emphasis> file, override the "processorClass" 
					property in the &lt;controller&gt; element. These lines follow the 
					&lt;action-mapping&gt; element.
				</para>
				<programlisting><![CDATA[<controller>
  <set-property property="processorClass"
      value="org.springframework.web.struts.DelegatingRequestProcessor"/>
</controller>]]></programlisting>
				<para>
					After adding this setting, your Action will automatically be 
					looked up in Spring's context file, no matter what the type. In fact, 
					you don't even need to specify a type. Both of the following snippets 
					will work:
				</para>
				<programlisting><![CDATA[<action path="/user" type="com.whatever.struts.UserAction"/>		
	<action path="/user"/>]]></programlisting>
				<para>
					If you're using Struts' <emphasis>modules</emphasis> feature, 
					your bean names must contain the module prefix. For example, an action 
					defined as <literal>&lt;action path="/user"/&gt;</literal> with module 
					prefix "admin" requires a bean name with
					<literal>&lt;bean name="/admin/user"/&gt;</literal>.
				</para>
				<note>
					<para>
						If you are using Tiles in your Struts application, you must configure your
						&lt;controller&gt; with the
						<ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingTilesRequestProcessor.html"><classname>DelegatingTilesRequestProcessor</classname></ulink>
						instead.
					</para>
				</note>
			</section>
			<section id="struts-delegatingactionproxy">
				<title>DelegatingActionProxy</title>
				<para>
					If you have a custom <classname>RequestProcessor</classname> and 
					can't use the <classname>DelegatingRequestProcessor</classname> or
					<classname>DelegatingTilesRequestProcessor</classname> approaches, you can 
					use the <ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingActionProxy.html">
					<classname>DelegatingActionProxy</classname></ulink> as the type in your 
					action-mapping.
				</para>
				<programlisting><![CDATA[<action path="/user" type="org.springframework.web.struts.DelegatingActionProxy"
    name="userForm" scope="request" validate="false" parameter="method">
  <forward name="list" path="/userList.jsp"/>
  <forward name="edit" path="/userForm.jsp"/>
</action>]]></programlisting>
				<para>
					The bean definition in <emphasis>action-servlet.xml</emphasis> 
					remains the same, whether you use a custom <literal>RequestProcessor</literal>
					or the <classname>DelegatingActionProxy</classname>.
				</para>
				<para>
					If you define your <classname>Action</classname> in a context file, the
					full feature set of Spring's bean container will be available for it:
					dependency injection as well as the option to instantiate a new
					<classname>Action</classname> instance for each request. To activate the latter,
					add <emphasis>singleton="false"</emphasis> to your Action's bean definition.
				</para>
				<programlisting><![CDATA[<bean name="/user" singleton="false" autowire="byName"
    class="org.example.web.UserAction"/>]]></programlisting>
			</section>
		</section>
		<section id="struts-actionsupport">
			<title>ActionSupport Classes</title>
			<para>
				As previously mentioned, you can retrieve the
				<classname>WebApplicationContext</classname> from the <interface>ServletContext</interface>
				using the <classname>WebApplicationContextUtils</classname> class. An
				easier way is to extend	Spring's <classname>Action</classname> classes for
				Struts. For example, instead of subclassing Struts'
				<classname>Action</classname> class, you can subclass Spring's
				<ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html">
				<classname>ActionSupport</classname></ulink> class.
			</para>
			<para>
				The <classname>ActionSupport</classname> class provides additional
				convenience methods, like <emphasis>getWebApplicationContext()</emphasis>.
				Below is an example of how you might use this in an Action:
			</para>
		<programlisting><![CDATA[public class UserAction extends DispatchActionSupport {

    public ActionForward execute(ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("entering 'delete' method...");
        }
        WebApplicationContext ctx = getWebApplicationContext();
        UserManager mgr = (UserManager) ctx.getBean("userManager");
        // talk to manager for business logic
        return mapping.findForward("success");
    }
}]]></programlisting>
		<para>
			Spring includes subclasses for all of the standard Struts Actions
			- the Spring versions merely have <emphasis>Support</emphasis> appended to the name:
			<itemizedlist spacing="compact">
			<listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html"><classname>ActionSupport</classname></ulink>,</para></listitem>
			<listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/DispatchActionSupport.html"><literal>DispatchActionSupport</literal></ulink>,</para></listitem>
			<listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/LookupDispatchActionSupport.html"><literal>LookupDispatchActionSupport</literal></ulink> and</para></listitem>
			<listitem><para><ulink url="http://www.springframework.org/docs/api/org/springframework/web/struts/MappingDispatchActionSupport.html"><literal>MappingDispatchActionSupport</literal></ulink>.</para></listitem>
			</itemizedlist>
		</para>

		<para>
			The recommended strategy is to use the approach that best suits
			your project. Subclassing makes your code more readable, and you know
			exactly how your dependencies are resolved. However, using the
			<classname>ContextLoaderPlugin</classname> allow you to easily add new
			dependencies in your context XML file. Either way, Spring provides some
			nice options for integrating the two frameworks.
			</para>
		</section>
	</section>
	<section id="view-tapestry">
		<title>Tapestry</title>
		<para>
			Tapestry is a powerful, component-oriented web application framework
			from Apache's Jakarta project (<ulink url="http://jakarta.apache.org/tapestry"/>).
			While Spring has its own powerful web ui layer, there are a number of unique
			advantages to building a J2EE application using a combination of Tapestry for
			the web	ui, and the Spring container for the lower layers. This document
			attempts to detail a few best practices for combining these two frameworks.
			(It is expected that you are relatively familiar with both Tapestry and Spring
			Framework basics, so they will not be explained here; general introductory
			documentation for both Tapestry and Spring Framework is available on
			their respective web sites.)
		</para>
		<section id="view-tapestry-architecture">
			<title>Architectural Overview</title>
			<para>
				A typical layered J2EE application built with Tapestry and Spring
				will consist of a top UI layer built with Tapestry, and a number of
				lower layers, all wired together by one or more Spring containers.
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<emphasis>User Interface Layer:</emphasis>
					</para>
					<para>- concerned with the user interface</para>
					<para>- contains some application logic</para>
					<para>- provided by Tapestry</para>
					<para>
						- aside from providing UI via Tapestry, code in this layer
						does its work via objects which implement interfaces from the
						Service Layer. The actual objects which implement these service
						layer interfaces are obtained from a Spring container.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Service Layer:</emphasis>
					</para>
					<para>- application specific 'service' code</para>
					<para>
						- works with domain objects, and uses the Mapper API to get
						those domain objects into and out of some sort of repository
						(database).
					</para>
					<para>- hosted in one or more Spring contexts</para>
					<para>
						- code in this layer manipulates objects in the domain model,
						in an application specific fashion. It does its work via other code
						in this layer, and via the Mapper API. An object in this layer is
						given the specific mapper implementations it needs to work with, via
						a Spring container.
					</para>
					<para>
						- since code in this layer is hosted in a Spring container, it
						may be transactionally wrapped by a Spring container, as opposed to
						managing its own transactions.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Domain Model:</emphasis>
					</para>
					<para>
						- domain specific object hierarchy, which deals with data and
						logic specific to this domain.
					</para>
					<para>
						- although the domain object hierarchy is built with the idea
						that it is persisted somehow and makes some general concessions to
						this (for example, bidirectional relationships), it generally has no
						knowledge of other layers. As such, it may be tested in isolation,
						and used with different mapping implementations for production vs.
						testing.
					</para>
					<para>
						- these objects may be standalone, or used in conjunction with
						a Spring container to take advantage of some of the benefits of the
						container, e.g. isolation, IoC, different strategy implementations, etc.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Data Source Layer:</emphasis>
					</para>
					<para>
						- Mapper (also called Data Access Object): an API used to
						persist the domain model to a repository of some sort (generally a
						relational database, but it could be the filesystem, memory, etc.)
					</para>
					<para>
						- Mapper API implementations: one or more specific
						implementations of the Mapper API, for example, a Hibernate-specific
						mapper, a JDO-specific mapper, JDBC-specific mapper, etc.
					</para>
					<para>
						- mapper implementations live in one or more Spring containers. A
						service layer object is given the mapper objects it needs to work with
						via the container(s).
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Database, filesystem, or other repositories:</emphasis>
					</para>
					<para>
						- objects in the domain model are stored into one or more
						repositories via one or more mapper implementations.
					</para>
					<para>
						- a repository may be very simple (e.g. filesystem), or may
						have its own representation of the data from the domain model (i.e.
						a schema in a database). It does not know about other layers however.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section id="view-tapestry-implementation">
			<title>Implementation</title>
			<para>
				The only real question (which needs to be addressed by this
				document), is how Tapestry pages get access to service implementations,
				which are simply beans defined in one or more Spring containers.
			</para>
			<section id="view-tapestry-context">
				<title>Sample application context</title>
				<para>
					Assume we have the following simple Spring container definition (in the
					ubiquitous XML format):
				</para>
				<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
        "http://www.springframework.org/dtd/spring-beans.dtd">
 
<beans>
    <!-- the DataSource -->
    <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
        <property name="jndiName" value="java:DefaultDS"/>
    </bean>
 
    <!-- define a Hibernate Session factory via a Spring LocalSessionFactoryBean -->
    <bean id="hibSessionFactory" 
          class="org.springframework.orm.hibernate.LocalSessionFactoryBean">
        <property name="dataSource" ref="dataSource"/>
    </bean>
 
    <!--
     - Defines a transaction manager for usage in business or data access objects.
     - No special treatment by the container, just a bean instance available as reference
     - for business objects that want to handle transactions, e.g. via TransactionTemplate.
     -->
    <bean id="transactionManager" 
          class="org.springframework.transaction.jta.JtaTransactionManager"/>
 
    <bean id="mapper" 
          class="com.whatever.dataaccess.mapper.hibernate.MapperImpl">
        <property name="sessionFactory" ref="hibSessionFactory"/>
    </bean>

    <!-- (transactional) AuthenticationService -->
    <bean id="authenticationService" 
          class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
        <property name="transactionManager" ref="transactionManager"/>
        <property name="target">
            <bean class="com.whatever.services.service.user.AuthenticationServiceImpl">
                <property name="mapper" ref="mapper"/>
            </bean>
        </property>
        <property name="proxyInterfacesOnly" value="true"/>
        <property name="transactionAttributes">
            <value>
                *=PROPAGATION_REQUIRED
            </value>
        </property>
    </bean>  
 
    <!-- (transactional) UserService -->
    <bean id="userService" 
          class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
        <property name="transactionManager" ref="transactionManager"/>
        <property name="target">
             <bean class="com.whatever.services.service.user.UserServiceImpl">
                 <property name="mapper" ref="mapper"/>
             </bean>
        </property>
        <property name="proxyInterfacesOnly" value="true"/>
        <property name="transactionAttributes">
            <value>
                *=PROPAGATION_REQUIRED
            </value>
        </property>
    </bean>  
 
 </beans>]]></programlisting>
				<para>
					Inside the Tapestry application, we need to
					load this application context, and allow Tapestry pages to get the
					authenticationService and userService beans, which implement the
					AuthenticationService and UserService interfaces, respectively.
				</para>
			</section>
			<section id="view-tapestry-appctx">
				<title>Obtaining beans in Tapestry pages</title>
				<para>
					At this point, the application context is available to a web
					application by calling Spring's static utility function
					<literal>WebApplicationContextUtils.getApplicationContext(servletContext)</literal>,
					where servletContext is the standard <interface>ServletContext</interface>
					from the J2EE Servlet specification. As such, one simple mechanism for
					a page to get an instance of the UserService, for example, would be
					with code such as:
				</para>
				<programlisting><![CDATA[WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(
        getRequestCycle().getRequestContext().getServlet().getServletContext());
UserService userService = (UserService) appContext.getBean("userService");
]]><lineannotation>... some code which uses UserService</lineannotation></programlisting>
				<para>
					This mechanism does
					work. It can be made a lot less verbose by encapsulating most of the
					functionality in a method in the base class for the page or component.
					However, in some respects it goes against the Inversion of Control
					approach which Spring encourages, which is being used in other layers
					of this app, in that ideally you would like the page to not have to
					ask the context for a specific bean by name, and in fact, the page
					would ideally not know about the context at all.
				</para>
				<para>
					Luckily, there is a mechanism to allow this. We rely upon the
					fact that Tapestry already has a mechanism to declaratively add
					properties to a page, and it is in fact the preferred approach to
					manage all properties on a page in this declarative fashion, so that
					Tapestry can properly manage their lifecycle as part of the page and
					component lifecycle.
				</para>
			</section>
			<section id="view-tapestry-exposeappctx">
				<title>Exposing the application context to Tapestry</title>
				<para>
					First we need to make the <interface>ApplicationContext</interface>
					available to the Tapestry page or Component without having to have the
					<interface>ServletContext</interface>; this is because at the stage in the
					page's/component's lifecycle when we need to access the
					<interface>ApplicationContext</interface>, the
					<interface>ServletContext</interface> won't be easily available to the
					page, so we can't use
					<literal>WebApplicationContextUtils.getApplicationContext(servletContext)</literal>
					directly. One way is by defining a custom version of the Tapestry
					<interfacename>IEngine</interfacename> which exposes this for us:
				</para>
				<programlisting><![CDATA[package com.whatever.web.xportal;

import ...

public class MyEngine extends org.apache.tapestry.engine.BaseEngine {
 
    public static final String APPLICATION_CONTEXT_KEY = "appContext";
 
    /**
     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)
     */
    protected void setupForRequest(RequestContext context) {
        super.setupForRequest(context);
     
        // insert ApplicationContext in global, if not there
        Map global = (Map) getGlobal();
        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);
        if (ac == null) {
            ac = WebApplicationContextUtils.getWebApplicationContext(
                context.getServlet().getServletContext()
            );
            global.put(APPLICATION_CONTEXT_KEY, ac);
        }
    }
}]]></programlisting>
				<para>
					This engine class places the Spring Application Context as
					an attribute called "appContext" in this Tapestry app's 'Global'
					object. Make sure to register the fact that this special IEngine
					instance should be used for this Tapestry application, with an entry
					in the Tapestry application definition file. For example:
				</para>
				<programlisting><lineannotation>file: xportal.application:</lineannotation><![CDATA[ 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE application PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd">
<application
    name="Whatever xPortal"
    engine-class="com.whatever.web.xportal.MyEngine">
</application>]]></programlisting>
			</section>
			<section id="view-tapestry-componentdefs">
				<title>Component definition files</title>
				<para>
					Now in our page or component definition file (*.page or *.jwc),
					we simply add property-specification elements to grab the beans we
					need out of the <interfacename>ApplicationContext</interfacename>,
					and create page or component properties for them. For example:
				</para>
				<programlisting><![CDATA[    <property-specification name="userService"
                            type="com.whatever.services.service.user.UserService">
        global.appContext.getBean("userService")
    </property-specification>
    <property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService">
        global.appContext.getBean("authenticationService")
    </property-specification>]]></programlisting>
				<para>
					The OGNL expression	inside the property-specification specifies the
					initial value for the property, as a bean obtained from the context.
					The entire page definition might look like this:
				</para>
				<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE page-specification PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd">
     
<page-specification class="com.whatever.web.xportal.pages.Login">
 
    <property-specification name="username" type="java.lang.String"/>
    <property-specification name="password" type="java.lang.String"/>
    <property-specification name="error" type="java.lang.String"/>
    <property-specification name="callback" type="org.apache.tapestry.callback.ICallback" persistent="yes"/>
    <property-specification name="userService"
                            type="com.whatever.services.service.user.UserService">
        global.appContext.getBean("userService")
    </property-specification>
    <property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService">
        global.appContext.getBean("authenticationService")
    </property-specification>
   
    <bean name="delegate" class="com.whatever.web.xportal.PortalValidationDelegate"/>
 
    <bean name="validator" class="org.apache.tapestry.valid.StringValidator" lifecycle="page">
        <set-property name="required" expression="true"/>
        <set-property name="clientScriptingEnabled" expression="true"/>
    </bean>
 
    <component id="inputUsername" type="ValidField">
        <static-binding name="displayName" value="Username"/>
        <binding name="value" expression="username"/>
        <binding name="validator" expression="beans.validator"/>
    </component>
   
    <component id="inputPassword" type="ValidField">
        <binding name="value" expression="password"/>
       <binding name="validator" expression="beans.validator"/>
       <static-binding name="displayName" value="Password"/>
       <binding name="hidden" expression="true"/>
    </component>
 
</page-specification>]]></programlisting>
			</section>
			<section id="view-tapestry-getters">
				<title>Adding abstract accessors</title>
				<para>
					Now in the Java class definition for the page or component
					itself, all we need to do is add an abstract getter method for the
					properties we have defined, to access them. When the page or component
					is actually loaded by Tapestry, it performs runtime code
					instrumentation on the classfile to add the properties which have been
					defined, and hook up the abstract getter methods to the newly created
					fields. For example:
				</para>
				<programlisting><![CDATA[// our UserService implementation; will come from page definition
public abstract UserService getUserService();
// our AuthenticationService implementation; will come from page definition
public abstract AuthenticationService getAuthenticationService();]]></programlisting>
				<para>
					For completeness, the entire Java class, for a login page in this
					example, might look like this:
				</para>
				<programlisting><![CDATA[package com.whatever.web.xportal.pages;
 
/**
 *  Allows the user to login, by providing username and password.
 *  After successfully logging in, a cookie is placed on the client browser
 *  that provides the default username for future logins (the cookie
 *  persists for a week).
 */
public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
 
    /** the key under which the authenticated user object is stored in the visit as */
    public static final String USER_KEY = "user";
   
    /**
     * The name of a cookie to store on the user's machine that will identify
     * them next time they log in.
     **/
    private static final String COOKIE_NAME = Login.class.getName() + ".username";  
    private final static int ONE_WEEK = 7 * 24 * 60 * 60;
 
    public abstract String getUsername();
    public abstract void setUsername(String username);
 
    public abstract String getPassword();
    public abstract void setPassword(String password);
 
    public abstract ICallback getCallback();
    public abstract void setCallback(ICallback value);
    
    public abstract UserService getUserService();
    public abstract AuthenticationService getAuthenticationService();
 
    protected IValidationDelegate getValidationDelegate() {
        return (IValidationDelegate) getBeans().getBean("delegate");
    }
 
    protected void setErrorField(String componentId, String message) {
        IFormComponent field = (IFormComponent) getComponent(componentId);
        IValidationDelegate delegate = getValidationDelegate();
        delegate.setFormComponent(field);
        delegate.record(new ValidatorException(message));
    }
 
    /**
     *  Attempts to login. 
     *
     *  If the user name is not known, or the password is invalid, then an error
     *  message is displayed.
     **/
    public void attemptLogin(IRequestCycle cycle) {
     
        String password = getPassword();
 
        // Do a little extra work to clear out the password.
        setPassword(null);
        IValidationDelegate delegate = getValidationDelegate();
 
        delegate.setFormComponent((IFormComponent) getComponent("inputPassword"));
        delegate.recordFieldInputValue(null);
 
        // An error, from a validation field, may already have occurred.
        if (delegate.getHasErrors()) {
            return;
        }
 
        try {
            User user = getAuthenticationService().login(getUsername(), getPassword());
           loginUser(user, cycle);
        }
        catch (FailedLoginException ex) {
            this.setError("Login failed: " + ex.getMessage());
            return;
        }
    }
 
    /**
     *  Sets up the {@link User} as the logged in user, creates
     *  a cookie for their username (for subsequent logins),
     *  and redirects to the appropriate page, or
     *  a specified page).
     **/
    public void loginUser(User user, IRequestCycle cycle) {
     
        String username = user.getUsername();
 
        // Get the visit object; this will likely force the
        // creation of the visit object and an HttpSession.
        Map visit = (Map) getVisit();
        visit.put(USER_KEY, user);
 
        // After logging in, go to the MyLibrary page, unless otherwise specified.
        ICallback callback = getCallback();
 
        if (callback == null) {
            cycle.activate("Home");
        }
        else {
            callback.performCallback(cycle);
        }
 
        // I've found that failing to set a maximum age and a path means that
        // the browser (IE 5.0 anyway) quietly drops the cookie.
 
        IEngine engine = getEngine();
        Cookie cookie = new Cookie(COOKIE_NAME, username);
        cookie.setPath(engine.getServletPath());
        cookie.setMaxAge(ONE_WEEK);
 
        // Record the user's username in a cookie
        cycle.getRequestContext().addCookie(cookie);
        engine.forgetPage(getPageName());
    }
   
    public void pageBeginRender(PageEvent event) {
        if (getUsername() == null) {
            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));
        }
    }
}]]></programlisting>
			</section>
		</section>
		<section id="view-tapestry-summary">
			<title>Summary</title>
			<para>
				In this example, we've managed to allow service beans defined in
				the Spring <interface>ApplicationContext</interface> to be provided to the
				page in a declarative fashion. The page class does not know where the
				service implementations are coming from, and in fact it is easy to slip
				in another implementation, for example, during testing. This inversion
				of control is one of the prime goals and benefits of the Spring
				Framework, and we have managed to extend it all the way up the J2EE
				stack in this Tapestry application.
			</para>
		</section>
	</section>
	<section id="webwork">
		<title>WebWork</title>
		<para>
			<ulink url="http://www.opensymphony.com/webwork">WebWork</ulink>
			is a web framework designed with simplicity in mind. It's built on top of 
			<ulink url="http://www.opensymphony.com/xwork">XWork</ulink>, which is a 
			generic command framework. XWork also has an IoC container, but it isn't 
			as full-featured as Spring and won't be covered in this section. WebWork 
			controllers are called Actions, mainly because they must implement the 
			<ulink url="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/Action.html">
			<literal>Action</literal></ulink> interface. The 
			<ulink url="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ActionSupport.html">
			<classname>ActionSupport</classname></ulink> class implements this interface, 
			and it is most common parent class for WebWork actions.
		</para>
		<para>
			WebWork maintains its own Spring integration project, located on 
			java.net in the <ulink url="https://xwork-optional.dev.java.net/">
			xwork-optional</ulink> project. Currently, three options are available for 
			integrating WebWork with Spring:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					<classname>SpringObjectFactory</classname>: 
					override XWork's default 
					<ulink url="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ObjectFactory.html">
					<classname>ObjectFactory</classname></ulink> so XWork will look for 
					Spring beans in the root <classname>WebApplicationContext</classname>.
				</para>
			</listitem>
			<listitem>
				<para>
					<classname>ActionAutowiringInterceptor:</classname> 
					use an interceptor to  automatically wire an Action's dependencies 
					as they're created.
				</para>
			</listitem>
			<listitem>
				<para>
					<classname>SpringExternalReferenceResolver:</classname> 
					look up Spring beans based on the name defined in an &lt;external-ref&gt; 
					element of an &lt;action&gt; element.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			All of these strategies are explained in further detail in
			<ulink url="http://wiki.opensymphony.com/display/WW/Other+Spring+Integration">
			WebWork's reference documentation</ulink>.
		</para>
	</section>
	<section id="webintegration-resources">
		<title>Further Resources</title>
		<para>
            Find below links to further resources about the various web frameworks
            described in this chapter.
        </para>
		<itemizedlist>
			<listitem>
				<para>The <ulink url="http://java.sun.com/javaee/javaserverfaces/">JSF</ulink> homepage</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://jakarta.apache.org/tapestry/">Tapestry</ulink> homepage</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://www.opensymphony.com/webwork/">WebWork</ulink> homepage</para>
			</listitem>
		</itemizedlist>
	</section>
</chapter>
