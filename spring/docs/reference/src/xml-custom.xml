<?xml version="1.0" encoding="UTF-8" ?>
<appendix id="extensible-xml">
    <title>Extensible XML authoring</title>
    <section>
        <title>Introduction</title>
        <para>Since version 2.0, Spring has featured a mechanism for schema-based extensions
        to the basic Spring XML format for defining and configuring beans. This section is
        devoted to detailing how you would go about writing your own custom XML bean definition
        parsers and integrating such parsers into the Spring IoC container. </para>
    	<para>To facilitate the authoring of configuration files using a schema-aware XML editor,
    	Spring's extensible XML configuration mechanism is based on XML Schema. If you are
    	not familiar with Spring's current XML configuration extensions that come with the
    	standard Spring distribution, please first read the appendix entitled
    	<xref linkend="xsd-config"/>.</para>
    	<para>Creating new XML configuration extensions can be done by following a (relatively)
    	simple process of authoring an XML schema, coding a <interfacename>NamespaceHandler</interfacename>
    	implementation, coding one or more <interfacename>BeanDefinitionParser</interfacename> instances
    	and registering the	<interfacename>NamespaceHandler</interfacename> and the schema in a dedicated
    	properties file. What follows is a description of each of these steps. For the example,
    	we will create an XML extension (a custom XML element) that allows us to configure objects of
    	type <classname>SimpleDateFormat</classname> directly in a Spring IoC container.</para>
    </section>
    <section id="extensible-xml-schema">
    	<title>Authoring the schema</title>
    	<para>Creating an XML configuration extension for use with Spring's IoC container
    	starts with authoring an XML Schema to describe the extension. What follows
    	is the schema we'll use to configure <classname>SimpleDateFormat</classname>
    	objects. The emphasized line contains an extension base for all tags that
    	will be identifiable (meaning they have an <literal>id</literal> attribute
    	that will be used as the bean identifier in the container).</para>
    	<programlisting><lineannotation>&lt;!-- myns.xsd (inside package org/springframework/samples/xml) --&gt;</lineannotation><![CDATA[

<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns="http://www.springframework.org/schema/myns"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:beans="http://www.springframework.org/schema/beans"
    targetNamespace="http://www.mycompany.com/schema/myns"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified">

   <xsd:import namespace="http://www.springframework.org/schema/beans"/>
   
   <xsd:element name="dateformat">
      <xsd:complexType>
         <xsd:complexContent>]]>
            <emphasis role="bold"><![CDATA[<xsd:extension base="beans:identifiedType">]]></emphasis><![CDATA[
               <xsd:attribute name="lenient" type="xsd:boolean"/>
               <xsd:attribute name="pattern" type="xsd:string" use="required"/>
            </xsd:extension>
         </xsd:complexContent>
      </xsd:complexType>
   </xsd:element>
   
</xsd:schema>]]></programlisting>
		<para>The above schema will be used to configure <classname>SimpleDateFormat</classname>
		objects, directly in an XML application context file using the
		<literal>myns:dateformat</literal> configuration directive. As noted above, the
		<literal>id</literal> attribute will (<emphasis>in this case</emphasis>) be used
		as the bean identifier for the <classname>SimpleDateFormat</classname> bean.</para>
		<programlisting><![CDATA[<myns:dateformat id="dateFormat" 
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/>
]]></programlisting>
		<para>Note that after we've created the infrastructure classes, the above snippet of XML
		will essentially be exactly the same as the following XML snippet. In other words,
		we're just creating a bean in the container, identified by the name
		<literal>'dateFormat'</literal> of type <classname>SimpleDateFormat</classname>, with a
		couple of properties set.</para>
		<programlisting><![CDATA[<bean id="dateFormat" class="java.text.SimpleDateFormat">
    <constructor-arg value="yyyy-HH-dd HH:mm"/>
    <property name="lenient" value="true"/>
</bean>]]></programlisting>
		<note>
			<para>The schema-based approach to creating configuration format allows for
			tight integration with an IDE that has a schema-aware XML editor. Using a properly
			authored schema, you can use autocompletion to have a user choose between several
			configuration options defined in the enumeration.</para>
		</note>
	</section>
	<section>
		<title>Coding a <interfacename>NamespaceHandler</interfacename></title>
		<para>In addition to the schema, we need a <interfacename>NamespaceHandler</interfacename>
		that will parse all elements of this specific namespace Spring encounters
		while parsing configuration files. The <interfacename>NamespaceHandler</interfacename>
		should in our case take care of the parsing of the <literal>myns:dateformat</literal>
		element.</para>
		<para>The <interfacename>NamespaceHandler</interfacename> interface is pretty simple in that 
		it only features three methods:</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para><literal>init()</literal> - allows for initialization of
				the <interfacename>NamespaceHandler</interfacename> and will be called by Spring before the handler is used</para>
			</listitem>
			<listitem>
				<para><literal>BeanDefinition parse(Element element, ParserContext parserContext)</literal> - 
				called when Spring encounters a top-level element (not nested inside a bean definition
				or a different namespace). This method can register bean definitions itself and/or
				return a bean definition.</para>
			</listitem>
			<listitem>
				<para><literal>BeanDefinitionHolder decorate(Node element, BeanDefinitionHolder definition, ParserContext parserContext)</literal> -
				called when Spring encounters an attribute or nested element of a different namespace, inside
				for example the Spring namespace. The decoration of one or more bean definitions is used
				for example with the out-of-the-box scopes Spring 2.0 comes with (see
				<xref linkend="beans-factory-scopes"/> for more information about scopes). We'll
				start by highlighting a simple example, without using decoration, after which we will
				show decoration in a somewhat more advanced example.</para>
			</listitem>
		</itemizedlist>
		<para>Although it is perfectly possible to code your own
		<interfacename>NamespaceHandler</interfacename> for the entire namespace
		(and hence provide code that parses each and every element in the namespace),
		it is often the case that <emphasis>each top-level XML element in a Spring XML
		configuration file results in a single bean definition</emphasis> (as in our
		case, where the <literal>myns:dateformat</literal> element results in a 
		<classname>SimpleDateFormat</classname> bean definition). Spring features a
		number of convenience classes that support this scenario. In this example,
		we'll use the most often used convenience class which is the
		<classname>NamespaceHandlerSupport</classname> class:</para>
		<programlisting><![CDATA[package org.springframework.samples.xml;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport {
    
    public void init() {]]><emphasis role="bold"><![CDATA[
        registerBeanDefinitionParser("dateformat", 
                new SimpleDateFormatBeanDefinitionParser());        
    ]]></emphasis>}
}</programlisting>
	</section>
	<section>
		<title>Coding a <interfacename>BeanDefinitionParser</interfacename></title>
		<para>The namespace handler shown above registers <literal>BeanDefinitionParsers</literal>.
		A <interfacename>BeanDefinitionParser</interfacename> will be used if the
		namespace handler encounters an XML element of the type that has been mapped
		to this specific bean definition parser (which is <literal>dateformat</literal> in this
		case). In other words, the <interfacename>BeanDefinitionParser</interfacename> is
		responsible for parsing one distinct top-level XML element defined in the schema. 
		In the parser, we'll have access to the XML element (and thus it's subelements too)
		so that we can parse our custom XML content, as can be seen in the following example:</para>
		<programlisting><![CDATA[package org.springframework.samples.xml;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

import java.text.SimpleDateFormat;

public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {

   protected Class getBeanClass(Element element) {
      return SimpleDateFormat.class;
   }

   protected void doParse(Element element, BeanDefinitionBuilder bean) {
      ]]><lineannotation>// never null since the schema requires it</lineannotation><![CDATA[
      String pattern = element.getAttribute("pattern");
      bean.addConstructorArg(pattern);

      String lenient = element.getAttribute("lenient");
      if (StringUtils.hasText(lenient)) {
         bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
      }
   }
}]]></programlisting>
	</section>
	<section>
		<title>Registering the handler and the schema</title>
		<para>We're done implementing the <interfacename>NamespaceHandler</interfacename> and the <interfacename>BeanDefinitionParser</interfacename> that will
		take care of parsing the custom XML Schema for us. We now have the following artifacts:</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para><classname>org.springframework.samples.xml.MyNamespaceHandler</classname> - 
				namespace handler that will register one or more <interfacename>BeanDefinitionParser</interfacename> instances</para>
			</listitem>
			<listitem>
				<para><classname>org.springframework.samples.xml.SimpleDateFormatBeanDefinitionParser</classname> - 
				used my the namespace handler to parse elements of type <literal>dateformat</literal></para>
			</listitem>
			<listitem>
				<para><literal>org/springframework/samples/xml/myns.xsd</literal> - the actual schema that 
				will be used in the Spring configuration files 
				(<emphasis role="bold">note that this file needs to be on the classpath, alongside your 
				namespace handler and parser classes as we'll see later on</emphasis>)</para>
			</listitem>
		</itemizedlist>
		<para>The last thing we need to do is to get the namespace ready for use by registering
		it in two special purpose properties files. These properties files are both placed in the META-INF
		directory and can, for example, be distributed alongside your binary classes in a JAR file. Spring will 
		automatically pick up the new namespaces and handlers once it finds the properties
		files on the classpath.</para>
		<section>
			<title><literal>META-INF/spring.handlers</literal></title>
			<para>The properties file called <literal>spring.handlers</literal> contains a mapping
			of XML Schema URIs to namespace handler classes. So for our example, we need to 
			specify the following here:</para>
			<programlisting><![CDATA[http\://www.mycompany.com/schema/myns=org.springframework.samples.xml.MyNamespaceHandler]]></programlisting>
		</section>
		<section>
			<title><literal>META-INF/spring.schemas</literal></title>
			<para>The properties file called <literal>spring.schemas</literal> contains a mapping
			of XML Schema locations (referred to along with the schema declaration in XML files
			that use the schema as part of the <literal>xsi:schemaLocation</literal> attribute)
			to classpath resources. This file is needed to prevent Spring from having to use a default
			<interfacename>EntityResolver</interfacename> that requires Internet access to retrieve the 
			schema file. If you specify the mapping in this properties file, Spring will
			search for the schema on the classpath (in this case <literal>'myns.xsd'</literal>
			in the <literal>'org.springframework.samples.xml'</literal> package):</para>
			<programlisting><![CDATA[http\://www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd]]></programlisting>
		</section>
	</section>
</appendix>
